<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>v8-JIT部分源码分析 | V1NKe的心情垃圾桶</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="v8," />
  

  <meta name="description" content="v8">
<meta name="keywords" content="v8">
<meta property="og:type" content="article">
<meta property="og:title" content="v8-JIT部分源码分析">
<meta property="og:url" content="http://yoursite.com/2019/11/11/v8-JIT部分源码分析/index.html">
<meta property="og:site_name" content="V1NKe的心情垃圾桶">
<meta property="og:description" content="v8">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/v8-JIT部分源码分析/11D7EBAA-064E-4A4C-87C2-E33695440086.png">
<meta property="og:image" content="http://yoursite.com/v8-JIT部分源码分析/60DC1A9C-7607-4CCE-847C-C9BD1EEEBD6F.png">
<meta property="og:image" content="http://yoursite.com/v8-JIT部分源码分析/B3DEC9EE-31C1-47BE-BE8D-E59A774F0F6A.png">
<meta property="og:image" content="http://yoursite.com/v8-JIT部分源码分析/DEC70B02-F924-4BD3-8D09-191C1B1C9F32.png">
<meta property="og:image" content="http://yoursite.com/v8-JIT部分源码分析/73CE78E6-8CC5-4B78-8646-F51B372148B4.png">
<meta property="og:updated_time" content="2021-04-16T09:39:09.210Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="v8-JIT部分源码分析">
<meta name="twitter:description" content="v8">
<meta name="twitter:image" content="http://yoursite.com/v8-JIT部分源码分析/11D7EBAA-064E-4A4C-87C2-E33695440086.png">

  

  
    <link rel="icon" href="/haimian.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x01-前言"><span class="toc-text">0x01 前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x02-正文"><span class="toc-text">0x02 正文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InliningPhase："><span class="toc-text">InliningPhase：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InliningPhase：-1"><span class="toc-text">InliningPhase：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EarlyGraphTrimmingPhase："><span class="toc-text">EarlyGraphTrimmingPhase：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TyperPhase："><span class="toc-text">TyperPhase：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TypedLoweringPhase："><span class="toc-text">TypedLoweringPhase：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DeadCodeElimination"><span class="toc-text">DeadCodeElimination</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JSCreateLowering"><span class="toc-text">JSCreateLowering:</span></a></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-v8-JIT部分源码分析" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">v8-JIT部分源码分析</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2019.11.11</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>V1NKe</span>
        </span>
      

      


      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <h3 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h3><p>吃灰很久了…是之前实习的时候分析的，后续因为某种原因没有继续搞浏览器了，所以就一直没管。现在让我看我也看不太懂了…所以就索性发出来好了，能帮助到别人就更好了，帮不到就当一个古老随笔了。如果有什么疑问的话，也别问我，因为我也不知道。</p>
<h3 id="0x02-正文"><a href="#0x02-正文" class="headerlink" title="0x02 正文"></a>0x02 正文</h3><p>测试代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">opt</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i &lt; <span class="number">100000</span>;i++)&#123;</span><br><span class="line">    opt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">opt();</span><br></pre></td></tr></table></figure>
<p>程序执行流程：</p>
<p>总体流程在<code>PipelineImpl::OptimizeGraph</code>，分了好几个阶段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> PipelineImpl::OptimizeGraph(Linkage* linkage) &#123;</span><br><span class="line">  PipelineData* data = <span class="keyword">this</span>-&gt;data_;</span><br><span class="line"></span><br><span class="line">  data-&gt;BeginPhaseKind(<span class="string">"V8.TFLowering"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Type the graph and keep the Typer running such that new nodes get</span></span><br><span class="line">  <span class="comment">// automatically typed when they are created.</span></span><br><span class="line">  Run&lt;TyperPhase&gt;(data-&gt;CreateTyper());                                  <span class="comment">//typer阶段</span></span><br><span class="line">  RunPrintAndVerify(TyperPhase::phase_name());</span><br><span class="line">  Run&lt;TypedLoweringPhase&gt;();                                             <span class="comment">//typerlowering</span></span><br><span class="line">  RunPrintAndVerify(TypedLoweringPhase::phase_name());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (data-&gt;info()-&gt;is_loop_peeling_enabled()) &#123;</span><br><span class="line">    Run&lt;LoopPeelingPhase&gt;();                                             <span class="comment">//loopeeling</span></span><br><span class="line">    RunPrintAndVerify(LoopPeelingPhase::phase_name(), <span class="literal">true</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Run&lt;LoopExitEliminationPhase&gt;();                                     <span class="comment">//LoopExitElimination</span></span><br><span class="line">    RunPrintAndVerify(LoopExitEliminationPhase::phase_name(), <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (FLAG_turbo_load_elimination) &#123;</span><br><span class="line">    Run&lt;LoadEliminationPhase&gt;();                                         <span class="comment">//LoadElimination</span></span><br><span class="line">    RunPrintAndVerify(LoadEliminationPhase::phase_name());</span><br><span class="line">  &#125;</span><br><span class="line">  data-&gt;DeleteTyper();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (FLAG_turbo_escape) &#123;</span><br><span class="line">    Run&lt;EscapeAnalysisPhase&gt;();                                          <span class="comment">//EscapeAnalysis</span></span><br><span class="line">    <span class="keyword">if</span> (data-&gt;compilation_failed()) &#123;</span><br><span class="line">      info()-&gt;AbortOptimization(</span><br><span class="line">          BailoutReason::kCyclicObjectStateDetectedInEscapeAnalysis);</span><br><span class="line">      data-&gt;EndPhaseKind();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    RunPrintAndVerify(EscapeAnalysisPhase::phase_name());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (FLAG_assert_types) &#123;</span><br><span class="line">    Run&lt;TypeAssertionsPhase&gt;();                                          <span class="comment">//TypeAssertions</span></span><br><span class="line">    RunPrintAndVerify(TypeAssertionsPhase::phase_name());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Perform simplified lowering. This has to run w/o the Typer decorator,</span></span><br><span class="line">  <span class="comment">// because we cannot compute meaningful types anyways, and the computed types</span></span><br><span class="line">  <span class="comment">// might even conflict with the representation/truncation logic.</span></span><br><span class="line">    Run&lt;SimplifiedLoweringPhase&gt;();                                      <span class="comment">//SimplifiedLowering</span></span><br><span class="line">  RunPrintAndVerify(SimplifiedLoweringPhase::phase_name(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// From now on it is invalid to look at types on the nodes, because the types</span></span><br><span class="line">  <span class="comment">// on the nodes might not make sense after representation selection due to the</span></span><br><span class="line">  <span class="comment">// way we handle truncations; if we'd want to look at types afterwards we'd</span></span><br><span class="line">  <span class="comment">// essentially need to re-type (large portions of) the graph.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// In order to catch bugs related to type access after this point, we now</span></span><br><span class="line">  <span class="comment">// remove the types from the nodes (currently only in Debug builds).</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">  Run&lt;UntyperPhase&gt;();</span><br><span class="line">  RunPrintAndVerify(UntyperPhase::phase_name(), <span class="literal">true</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>../../src/runtime/runtime-compiler.cc:228</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">RUNTIME_FUNCTION(Runtime_CompileForOnStackReplacement) &#123;</span><br><span class="line">  <span class="function">HandleScope <span class="title">scope</span><span class="params">(isolate)</span></span>;</span><br><span class="line">  DCHECK_EQ(<span class="number">1</span>, args.length());</span><br><span class="line">  CONVERT_ARG_HANDLE_CHECKED(JSFunction, function, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Only reachable when OST is enabled.</span></span><br><span class="line">  CHECK(FLAG_use_osr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Determine frame triggering OSR request.</span></span><br><span class="line">  <span class="function">JavaScriptFrameIterator <span class="title">it</span><span class="params">(isolate)</span></span>;</span><br><span class="line">  JavaScriptFrame* frame = it.frame();</span><br><span class="line">  DCHECK_EQ(frame-&gt;function(), *function);</span><br><span class="line">  DCHECK(frame-&gt;is_interpreted());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Determine the entry point for which this OSR request has been fired and</span></span><br><span class="line">  <span class="comment">// also disarm all back edges in the calling code to stop new requests.</span></span><br><span class="line">  BailoutId ast_id = DetermineEntryAndDisarmOSRForInterpreter(frame);</span><br><span class="line">  DCHECK(!ast_id.IsNone());</span><br><span class="line"></span><br><span class="line">  MaybeHandle&lt;Code&gt; maybe_result;</span><br><span class="line">  <span class="keyword">if</span> (IsSuitableForOnStackReplacement(isolate, function)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (FLAG_trace_osr) &#123;</span><br><span class="line">      PrintF(<span class="string">"[OSR - Compiling: "</span>);</span><br><span class="line">      function-&gt;PrintName();</span><br><span class="line">      PrintF(<span class="string">" at AST id %d]\n"</span>, ast_id.ToInt());</span><br><span class="line">    &#125;</span><br><span class="line">    maybe_result = Compiler::GetOptimizedCodeForOSR(function, ast_id, frame);     <span class="comment">//important</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><code>../../src/codegen/compiler.cc:2280</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MaybeHandle&lt;Code&gt; Compiler::GetOptimizedCodeForOSR(Handle&lt;JSFunction&gt; function,</span><br><span class="line">                                                   BailoutId osr_offset,</span><br><span class="line">                                                   JavaScriptFrame* osr_frame) &#123;</span><br><span class="line">  DCHECK(!osr_offset.IsNone());</span><br><span class="line">  DCHECK_NOT_NULL(osr_frame);</span><br><span class="line">  <span class="keyword">return</span> GetOptimizedCode(function, ConcurrencyMode::kNotConcurrent, osr_offset,    <span class="comment">//important</span></span><br><span class="line">                          osr_frame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>../../src/codegen/compiler.cc:899</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">MaybeHandle&lt;Code&gt; GetOptimizedCode(Handle&lt;JSFunction&gt; function,</span><br><span class="line">                                   ConcurrencyMode mode,</span><br><span class="line">                                   BailoutId osr_offset = BailoutId::None(),</span><br><span class="line">                                   JavaScriptFrame* osr_frame = <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  Isolate* isolate = function-&gt;GetIsolate();</span><br><span class="line">  Handle&lt;SharedFunctionInfo&gt; shared(function-&gt;shared(), isolate);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make sure we clear the optimization marker on the function so that we</span></span><br><span class="line">  <span class="comment">// don't try to re-optimize.</span></span><br><span class="line">  <span class="keyword">if</span> (function-&gt;HasOptimizationMarker()) &#123;</span><br><span class="line">    function-&gt;ClearOptimizationMarker();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shared-&gt;optimization_disabled() &amp;&amp;</span><br><span class="line">      shared-&gt;disable_optimization_reason() == BailoutReason::kNeverOptimize) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaybeHandle&lt;Code&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isolate-&gt;debug()-&gt;needs_check_on_function_call()) &#123;</span><br><span class="line">    <span class="comment">// Do not optimize when debugger needs to hook into every call.</span></span><br><span class="line">    <span class="keyword">return</span> MaybeHandle&lt;Code&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If code was pending optimization for testing, delete remove the entry</span></span><br><span class="line">  <span class="comment">// from the table that was preventing the bytecode from being flushed</span></span><br><span class="line">  <span class="keyword">if</span> (V8_UNLIKELY(FLAG_testing_d8_test_runner)) &#123;</span><br><span class="line">    PendingOptimizationTable::FunctionWasOptimized(isolate, function);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Handle&lt;Code&gt; cached_code;</span><br><span class="line">  <span class="keyword">if</span> (GetCodeFromOptimizedCodeCache(function, osr_offset)</span><br><span class="line">          .ToHandle(&amp;cached_code)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (FLAG_trace_opt) &#123;</span><br><span class="line">      PrintF(<span class="string">"[found optimized code for "</span>);</span><br><span class="line">      function-&gt;ShortPrint();</span><br><span class="line">      <span class="keyword">if</span> (!osr_offset.IsNone()) &#123;</span><br><span class="line">        PrintF(<span class="string">" at OSR AST id %d"</span>, osr_offset.ToInt());</span><br><span class="line">      &#125;</span><br><span class="line">      PrintF(<span class="string">"]\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cached_code;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reset profiler ticks, function is no longer considered hot.</span></span><br><span class="line">  DCHECK(shared-&gt;is_compiled());</span><br><span class="line">  function-&gt;feedback_vector().set_profiler_ticks(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  VMState&lt;COMPILER&gt; state(isolate);</span><br><span class="line">  TimerEventScope&lt;TimerEventOptimizeCode&gt; optimize_code_timer(isolate);</span><br><span class="line">  <span class="function">RuntimeCallTimerScope <span class="title">runtimeTimer</span><span class="params">(isolate,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     RuntimeCallCounterId::kOptimizeCode)</span></span>;</span><br><span class="line">  TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT(<span class="string">"v8.compile"</span>), <span class="string">"V8.OptimizeCode"</span>);</span><br><span class="line"></span><br><span class="line">  DCHECK(!isolate-&gt;has_pending_exception());</span><br><span class="line">  <span class="function">PostponeInterruptsScope <span class="title">postpone</span><span class="params">(isolate)</span></span>;</span><br><span class="line">  <span class="keyword">bool</span> has_script = shared-&gt;script().IsScript();</span><br><span class="line">  <span class="comment">// BUG(5946): This DCHECK is necessary to make certain that we won't</span></span><br><span class="line">  <span class="comment">// tolerate the lack of a script without bytecode.</span></span><br><span class="line">  DCHECK_IMPLIES(!has_script, shared-&gt;HasBytecodeArray());</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;OptimizedCompilationJob&gt; job(</span><br><span class="line">      compiler::Pipeline::NewCompilationJob(isolate, function, has_script));</span><br><span class="line">  OptimizedCompilationInfo* compilation_info = job-&gt;compilation_info();</span><br><span class="line"></span><br><span class="line">  compilation_info-&gt;SetOptimizingForOsr(osr_offset, osr_frame);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do not use TurboFan if we need to be able to set break points.</span></span><br><span class="line">  <span class="keyword">if</span> (compilation_info-&gt;shared_info()-&gt;HasBreakInfo()) &#123;</span><br><span class="line">    compilation_info-&gt;AbortOptimization(BailoutReason::kFunctionBeingDebugged);</span><br><span class="line">    <span class="keyword">return</span> MaybeHandle&lt;Code&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do not use TurboFan if optimization is disabled or function doesn't pass</span></span><br><span class="line">  <span class="comment">// turbo_filter.</span></span><br><span class="line">  <span class="keyword">if</span> (!FLAG_opt || !shared-&gt;PassesFilter(FLAG_turbo_filter)) &#123;</span><br><span class="line">    compilation_info-&gt;AbortOptimization(BailoutReason::kOptimizationDisabled);</span><br><span class="line">    <span class="keyword">return</span> MaybeHandle&lt;Code&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// In case of concurrent recompilation, all handles below this point will be</span></span><br><span class="line">  <span class="comment">// allocated in a deferred handle scope that is detached and handed off to</span></span><br><span class="line">  <span class="comment">// the background thread when we return.</span></span><br><span class="line">  base::Optional&lt;CompilationHandleScope&gt; compilation;</span><br><span class="line">  <span class="keyword">if</span> (mode == ConcurrencyMode::kConcurrent) &#123;</span><br><span class="line">    compilation.emplace(isolate, compilation_info);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// All handles below will be canonicalized.</span></span><br><span class="line">  <span class="function">CanonicalHandleScope <span class="title">canonical</span><span class="params">(isolate)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reopen handles in the new CompilationHandleScope.</span></span><br><span class="line">  compilation_info-&gt;ReopenHandlesInNewHandleScope(isolate);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mode == ConcurrencyMode::kConcurrent) &#123;</span><br><span class="line">    <span class="keyword">if</span> (GetOptimizedCodeLater(job.get(), isolate)) &#123;</span><br><span class="line">      job.release();  <span class="comment">// The background recompile job owns this now.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Set the optimization marker and return a code object which checks it.</span></span><br><span class="line">      function-&gt;SetOptimizationMarker(OptimizationMarker::kInOptimizationQueue);</span><br><span class="line">      DCHECK(function-&gt;IsInterpreted() ||</span><br><span class="line">             (!function-&gt;is_compiled() &amp;&amp; function-&gt;shared().IsInterpreted()));</span><br><span class="line">      DCHECK(function-&gt;shared().HasBytecodeArray());</span><br><span class="line">      <span class="keyword">return</span> BUILTIN_CODE(isolate, InterpreterEntryTrampoline);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (GetOptimizedCodeNow(job.get(), isolate))                                <span class="comment">//important</span></span><br><span class="line">      <span class="keyword">return</span> compilation_info-&gt;code();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><code>../../src/codegen/compiler.cc:739</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetOptimizedCodeNow</span><span class="params">(OptimizedCompilationJob* job, Isolate* isolate)</span> </span>&#123;</span><br><span class="line">  TimerEventScope&lt;TimerEventRecompileSynchronous&gt; timer(isolate);</span><br><span class="line">  <span class="function">RuntimeCallTimerScope <span class="title">runtimeTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      isolate, RuntimeCallCounterId::kRecompileSynchronous)</span></span>;</span><br><span class="line">  OptimizedCompilationInfo* compilation_info = job-&gt;compilation_info();</span><br><span class="line">  TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT(<span class="string">"v8.compile"</span>),</span><br><span class="line">               <span class="string">"V8.RecompileSynchronous"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (job-&gt;PrepareJob(isolate) != CompilationJob::SUCCEEDED ||</span><br><span class="line">      job-&gt;ExecuteJob() != CompilationJob::SUCCEEDED ||                        <span class="comment">//important</span></span><br><span class="line">      job-&gt;FinalizeJob(isolate) != CompilationJob::SUCCEEDED) &#123;</span><br><span class="line">    <span class="keyword">if</span> (FLAG_trace_opt) &#123;</span><br><span class="line">      PrintF(<span class="string">"[aborted optimizing "</span>);</span><br><span class="line">      compilation_info-&gt;closure()-&gt;ShortPrint();</span><br></pre></td></tr></table></figure>
<p><code>../../src/codegen/compiler.cc:227</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CompilationJob::Status OptimizedCompilationJob::ExecuteJob() &#123;</span><br><span class="line">  DisallowHeapAccess no_heap_access;</span><br><span class="line">  <span class="comment">// Delegate to the underlying implementation.</span></span><br><span class="line">  DCHECK_EQ(state(), State::kReadyToExecute);</span><br><span class="line">  <span class="function">ScopedTimer <span class="title">t</span><span class="params">(&amp;time_taken_to_execute_)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> UpdateState(ExecuteJobImpl(), State::kReadyToFinalize);              <span class="comment">//important</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>../../src/compiler/pipeline.cc:1092</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PipelineCompilationJob::Status PipelineCompilationJob::ExecuteJobImpl() &#123;</span><br><span class="line">  TRACE_EVENT_WITH_FLOW1(</span><br><span class="line">      TRACE_DISABLED_BY_DEFAULT(<span class="string">"v8.compile"</span>), <span class="string">"v8.optimizingCompile.execute"</span>,</span><br><span class="line">      <span class="keyword">this</span>, TRACE_EVENT_FLAG_FLOW_IN | TRACE_EVENT_FLAG_FLOW_OUT, <span class="string">"function"</span>,</span><br><span class="line">      compilation_info()-&gt;shared_info()-&gt;TraceIDRef());</span><br><span class="line">  <span class="keyword">if</span> (!pipeline_.OptimizeGraph(linkage_)) <span class="keyword">return</span> FAILED;                       <span class="comment">//important</span></span><br><span class="line">  pipeline_.AssembleCode(linkage_);</span><br><span class="line">  <span class="keyword">return</span> SUCCEEDED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>../../src/compiler/pipeline.cc:2388</code></p>
<p>之后往下的就是到我断点的CheckBounds处了，暂且先不讨论。</p>
<p>从<code>../../src/codegen/compiler.cc:739</code>大致就能看出点事来。比如说断点时执行的是ExecuteJob，之前还有个PrepareJob。大概查看一下PrepareJob的引用就能知道该函数执行的是编译优化的前期准备工作。而ExecuteJob则是编译优化的执行工作。</p>
<p>先从准备处开始下手。</p>
<p>首先是该函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">PipelineCompilationJob::Status PipelineCompilationJob::PrepareJobImpl(</span><br><span class="line">    Isolate* isolate) &#123;</span><br><span class="line">  TRACE_EVENT_WITH_FLOW1(</span><br><span class="line">      TRACE_DISABLED_BY_DEFAULT(<span class="string">"v8.compile"</span>), <span class="string">"v8.optimizingCompile.prepare"</span>,</span><br><span class="line">      <span class="keyword">this</span>, TRACE_EVENT_FLAG_FLOW_IN | TRACE_EVENT_FLAG_FLOW_OUT, <span class="string">"function"</span>,</span><br><span class="line">      compilation_info()-&gt;shared_info()-&gt;TraceIDRef());</span><br><span class="line">  <span class="keyword">if</span> (compilation_info()-&gt;bytecode_array()-&gt;length() &gt;</span><br><span class="line">      FLAG_max_optimized_bytecode_size) &#123;</span><br><span class="line">    <span class="keyword">return</span> AbortOptimization(BailoutReason::kFunctionTooBig);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!FLAG_always_opt) &#123;</span><br><span class="line">    compilation_info()-&gt;MarkAsBailoutOnUninitialized();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (FLAG_turbo_loop_peeling) &#123;</span><br><span class="line">    compilation_info()-&gt;MarkAsLoopPeelingEnabled();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (FLAG_turbo_inlining) &#123;</span><br><span class="line">    compilation_info()-&gt;MarkAsInliningEnabled();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (FLAG_inline_accessors) &#123;</span><br><span class="line">    compilation_info()-&gt;MarkAsAccessorInliningEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This is the bottleneck for computing and setting poisoning level in the</span></span><br><span class="line">  <span class="comment">// optimizing compiler.</span></span><br><span class="line">  PoisoningMitigationLevel load_poisoning =</span><br><span class="line">      PoisoningMitigationLevel::kDontPoison;</span><br><span class="line">  <span class="keyword">if</span> (FLAG_untrusted_code_mitigations) &#123;</span><br><span class="line">    <span class="comment">// For full mitigations, this can be changed to</span></span><br><span class="line">    <span class="comment">// PoisoningMitigationLevel::kPoisonAll.</span></span><br><span class="line">    load_poisoning = PoisoningMitigationLevel::kPoisonCriticalOnly;</span><br><span class="line">  &#125;</span><br><span class="line">  compilation_info()-&gt;SetPoisoningMitigationLevel(load_poisoning);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (FLAG_turbo_allocation_folding) &#123;</span><br><span class="line">    compilation_info()-&gt;MarkAsAllocationFoldingEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Determine whether to specialize the code for the function's context.</span></span><br><span class="line">  <span class="comment">// We can't do this in the case of OSR, because we want to cache the</span></span><br><span class="line">  <span class="comment">// generated code on the native context keyed on SharedFunctionInfo.</span></span><br><span class="line">  <span class="comment">// TODO(mythria): Check if it is better to key the OSR cache on JSFunction and</span></span><br><span class="line">  <span class="comment">// allow context specialization for OSR code.</span></span><br><span class="line">  <span class="keyword">if</span> (compilation_info()-&gt;closure()-&gt;raw_feedback_cell().<span class="built_in">map</span>() ==</span><br><span class="line">          ReadOnlyRoots(isolate).one_closure_cell_map() &amp;&amp;</span><br><span class="line">      !compilation_info()-&gt;is_osr()) &#123;</span><br><span class="line">    compilation_info()-&gt;MarkAsFunctionContextSpecializing();</span><br><span class="line">    data_.ChooseSpecializationContext();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (compilation_info()-&gt;is_source_positions_enabled()) &#123;</span><br><span class="line">    SharedFunctionInfo::EnsureSourcePositionsAvailable(</span><br><span class="line">        isolate, compilation_info()-&gt;shared_info());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  data_.set_start_source_position(</span><br><span class="line">      compilation_info()-&gt;shared_info()-&gt;StartPosition());</span><br><span class="line"></span><br><span class="line">  linkage_ = <span class="keyword">new</span> (compilation_info()-&gt;zone()) Linkage(</span><br><span class="line">      Linkage::ComputeIncoming(compilation_info()-&gt;zone(), compilation_info()));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (compilation_info()-&gt;is_osr()) data_.InitializeOsrHelper();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make sure that we have generated the deopt entries code.  This is in order</span></span><br><span class="line">  <span class="comment">// to avoid triggering the generation of deopt entries later during code</span></span><br><span class="line">  <span class="comment">// assembly.</span></span><br><span class="line">  Deoptimizer::EnsureCodeForDeoptimizationEntries(isolate);</span><br><span class="line"></span><br><span class="line">  pipeline_.Serialize();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!FLAG_concurrent_inlining) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!pipeline_.CreateGraph()) &#123;</span><br><span class="line">      CHECK(!isolate-&gt;has_pending_exception());</span><br><span class="line">      <span class="keyword">return</span> AbortOptimization(BailoutReason::kGraphBuildingFailed);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> SUCCEEDED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查输入中的编译优化信息，如有，则在标志中标记并加入。</p>
<p>而后生成IR图表：<code>pipeline_.CreateGraph()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> PipelineImpl::CreateGraph() &#123;</span><br><span class="line">  PipelineData* data = <span class="keyword">this</span>-&gt;data_;</span><br><span class="line"></span><br><span class="line">  data-&gt;BeginPhaseKind(<span class="string">"V8.TFGraphCreation"</span>);</span><br><span class="line"></span><br><span class="line">  Run&lt;GraphBuilderPhase&gt;();</span><br><span class="line">  RunPrintAndVerify(GraphBuilderPhase::phase_name(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Perform function context specialization and inlining (if enabled).</span></span><br><span class="line">  Run&lt;InliningPhase&gt;();</span><br><span class="line">  RunPrintAndVerify(InliningPhase::phase_name(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove dead-&gt;live edges from the graph.</span></span><br><span class="line">  Run&lt;EarlyGraphTrimmingPhase&gt;();</span><br><span class="line">  RunPrintAndVerify(EarlyGraphTrimmingPhase::phase_name(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Determine the Typer operation flags.</span></span><br><span class="line">  &#123;</span><br><span class="line">    SharedFunctionInfoRef shared_info(data-&gt;broker(), info()-&gt;shared_info());</span><br><span class="line">    <span class="keyword">if</span> (is_sloppy(shared_info.language_mode()) &amp;&amp;</span><br><span class="line">        shared_info.IsUserJavaScript()) &#123;</span><br><span class="line">      <span class="comment">// Sloppy mode functions always have an Object for this.</span></span><br><span class="line">      data-&gt;AddTyperFlag(Typer::kThisIsReceiver);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (IsClassConstructor(shared_info.kind())) &#123;</span><br><span class="line">      <span class="comment">// Class constructors cannot be [[Call]]ed.</span></span><br><span class="line">      data-&gt;AddTyperFlag(Typer::kNewTargetIsReceiver);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Run the type-sensitive lowerings and optimizations on the graph.</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (!FLAG_concurrent_inlining) &#123;</span><br><span class="line">      Run&lt;HeapBrokerInitializationPhase&gt;();</span><br><span class="line">      Run&lt;CopyMetadataForConcurrentCompilePhase&gt;();</span><br><span class="line">      data-&gt;broker()-&gt;StopSerializing();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  data-&gt;EndPhaseKind();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从第六行起始就能知道该函数是JIT Lowering中的各个小阶段的执行函数：</p>
<p>先是GraphBuilderPhase、然后InliningPhase、EarlyGraphTrimmingPhase、HeapBrokerInitializationPhase、CopyMetadataForConcurrentCompilePhase。</p>
<p>先从GraphBuilderPhase说起。</p>
<p>我给其中的一些加了注释：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GraphBuilderPhase</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">phase_name</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"V8.TFBytecodeGraphBuilder"</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">(PipelineData* data, Zone* temp_zone)</span> </span>&#123;</span><br><span class="line">    BytecodeGraphBuilderFlags flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查是否有kAnalyzeEnvironmentLiveness标志</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data-&gt;info()-&gt;is_analyze_environment_liveness()) &#123;         </span><br><span class="line">      flags |= BytecodeGraphBuilderFlag::kAnalyzeEnvironmentLiveness;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查是否有kBailoutOnUninitialized标志</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data-&gt;info()-&gt;is_bailout_on_uninitialized()) &#123;</span><br><span class="line">      flags |= BytecodeGraphBuilderFlag::kBailoutOnUninitialized;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    JSFunctionRef closure(data-&gt;broker(), data-&gt;info()-&gt;closure());</span><br></pre></td></tr></table></figure>
<p>跟进JSFunctionRef closure这句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">ObjectRef::ObjectRef(JSHeapBroker* broker, Handle&lt;Object&gt; object,</span></span><br><span class="line"><span class="comment">                     bool check_type)</span></span><br><span class="line"><span class="comment">    : broker_(broker) &#123;</span></span><br><span class="line"><span class="comment">  switch (broker-&gt;mode()) &#123;                 //（JSHeapBroker::kDisabled）</span></span><br><span class="line"><span class="comment">    case JSHeapBroker::kSerialized:</span></span><br><span class="line"><span class="comment">      data_ = broker-&gt;GetData(object);</span></span><br><span class="line"><span class="comment">      break;</span></span><br><span class="line"><span class="comment">    case JSHeapBroker::kSerializing:</span></span><br><span class="line"><span class="comment">      data_ = broker-&gt;GetOrCreateData(object);</span></span><br><span class="line"><span class="comment">      break;</span></span><br><span class="line"><span class="comment">    case JSHeapBroker::kDisabled: &#123;</span></span><br><span class="line"><span class="comment">      RefsMap::Entry* entry =</span></span><br><span class="line"><span class="comment">          broker-&gt;refs_-&gt;LookupOrInsert(object.address(), broker-&gt;zone());</span></span><br><span class="line"><span class="comment">      ObjectData** storage = &amp;(entry-&gt;value);</span></span><br><span class="line"><span class="comment">      if (*storage == nullptr) &#123;</span></span><br><span class="line"><span class="comment">        AllowHandleDereference handle_dereference;</span></span><br><span class="line"><span class="comment">        entry-&gt;value = new (broker-&gt;zone())</span></span><br><span class="line"><span class="comment">            ObjectData(broker, storage, object,</span></span><br><span class="line"><span class="comment">                       object-&gt;IsSmi() ? kSmi : kUnserializedHeapObject);</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">      data_ = *storage;</span></span><br><span class="line"><span class="comment">      break;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    case JSHeapBroker::kRetired:</span></span><br><span class="line"><span class="comment">      UNREACHABLE();</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  if (!data_) &#123;  // TODO(mslekova): Remove once we're on the background thread.</span></span><br><span class="line"><span class="comment">    AllowHandleDereference handle_dereference;</span></span><br><span class="line"><span class="comment">    object-&gt;Print();</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  CHECK_WITH_MSG(data_ != nullptr, "Object is not known to the heap broker");</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line">整个结构的继承性：</span><br><span class="line">ObjectRef：</span><br><span class="line">  HeapObjectRef：</span><br><span class="line">    JSReceiverRef：</span><br><span class="line">      JSObjectRef：</span><br><span class="line">        JSFunctionRef：</span><br></pre></td></tr></table></figure>
<p>接上源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CallFrequency <span class="title">frequency</span><span class="params">(<span class="number">1.0f</span>)</span></span>;                      <span class="comment">//设定调用频率</span></span><br><span class="line">     BuildGraphFromBytecode(</span><br><span class="line">         data-&gt;broker(), temp_zone, closure.shared(), closure.feedback_vector(),</span><br><span class="line">         data-&gt;info()-&gt;osr_offset(), data-&gt;jsgraph(), frequency,</span><br><span class="line">         data-&gt;source_positions(), SourcePosition::kNotInlined, flags,</span><br><span class="line">         &amp;data-&gt;info()-&gt;tick_counter());</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//最后的bytecode  --&gt;  ../../src/compiler/bytecode-graph-builder.cc:4094</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.CreateGraph();</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BytecodeGraphBuilder::CreateGraph() &#123;</span><br><span class="line">  <span class="function">DisallowHeapAccessIf <span class="title">disallow_heap_access</span><span class="params">(FLAG_concurrent_inlining)</span></span>;</span><br><span class="line">  SourcePositionTable::<span class="function">Scope <span class="title">pos_scope</span><span class="params">(source_positions_, start_position_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up the basic structure of the graph. Outputs for &#123;Start&#125; are the formal</span></span><br><span class="line">  <span class="comment">// parameters (including the receiver) plus new target, number of arguments,</span></span><br><span class="line">  <span class="comment">// context and closure.</span></span><br><span class="line">  <span class="keyword">int</span> actual_parameter_count = bytecode_array().parameter_count() + <span class="number">4</span>;             <span class="comment">//定义参数个数</span></span><br><span class="line">  graph()-&gt;SetStart(graph()-&gt;NewNode(common()-&gt;Start(actual_parameter_count)));    <span class="comment">//新建一个start</span></span><br><span class="line">                                                                                   <span class="comment">//结点并设置Start</span></span><br><span class="line">                                            <span class="comment">//common结点统一在common-operator.cc中</span></span><br><span class="line"></span><br><span class="line">  Environment env(this, bytecode_array().register_count(),</span><br><span class="line">                  bytecode_array().parameter_count(),</span><br><span class="line">                  bytecode_array().incoming_new_target_or_generator_register(),</span><br><span class="line">                  graph()-&gt;start());                           </span><br><span class="line">  set_environment(&amp;env);                                       <span class="comment">//初始化环境，设置接收者、参数、注册者</span></span><br><span class="line"></span><br><span class="line">  VisitBytecodes();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Finish the basic structure of the graph.</span></span><br><span class="line">  DCHECK_NE(<span class="number">0u</span>, exit_controls_.size());</span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">const</span> input_count = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(exit_controls_.size());</span><br><span class="line">  Node** <span class="keyword">const</span> inputs = &amp;exit_controls_.front();</span><br><span class="line">  Node* end = graph()-&gt;NewNode(common()-&gt;End(input_count), input_count, inputs);</span><br><span class="line">  graph()-&gt;SetEnd(end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的<code>BytecodeGraphBuilder::CreateGraph()</code>VisitBytecoeds中：</p>
<p>AdvanceToOsrEntryAndPeelLoops();<br>该函数先剥离osr,优化n个循环而后逐字节码迭代。从osr loop循环开始，一直循环到最外圈的loop_0，但是期间不为任何父loop创建跳转节点，但是还原字节码，记录jumploop偏移量并且构建与osrloop对应的新节点，期间还要注意合并环境以及异常处理程序。（只保留最外层loop和osrloop之间相对应的节点）<br>迭代遍历字节码，并检测是否有shot bytecode<br>当不在并发内联并且有shot bytecode时，用shot bytecode优化函数特性去设置计数器的使用。</p>
<p>VisitBytecodes之后，设置IR图的end节点（exit_controls_控制退出函数），结束基本结构。</p>
<h3 id="InliningPhase："><a href="#InliningPhase：" class="headerlink" title="InliningPhase："></a>InliningPhase：</h3><p>继续看，接下来是InliningPhase，部分注释写在里面：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InliningPhase</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">phase_name</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"V8.TFInlining"</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">(PipelineData* data, Zone* temp_zone)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义优化编译信息，例如（kInliningEnabled、kBailoutOnUninitialized）这种标记flag</span></span><br><span class="line">    OptimizedCompilationInfo* info = data-&gt;info();</span><br><span class="line">  <span class="comment">//创建完整节点图reduce实例（Replace、ReduceTop、ReplaceWithValue、pop、push等）</span></span><br><span class="line">    GraphReducer graph_reducer(temp_zone, data-&gt;graph(), &amp;info-&gt;tick_counter(),</span><br><span class="line">                               data-&gt;jsgraph()-&gt;Dead());</span><br><span class="line">  <span class="comment">//创建dead节点消除实例（end、node、loopormerge、loopexit、BranchOrSwitch等）</span></span><br><span class="line">    DeadCodeElimination dead_code_elimination(&amp;graph_reducer, data-&gt;graph(),</span><br><span class="line">                                              data-&gt;common(), temp_zone);</span><br><span class="line">  <span class="comment">//创建冗余检查点消除实例（checkpoint）</span></span><br><span class="line">    <span class="function">CheckpointElimination <span class="title">checkpoint_elimination</span><span class="params">(&amp;graph_reducer)</span></span>;</span><br><span class="line">  <span class="comment">//创建公共操作符reduce实例（branch、merge、phi、return、swith等）</span></span><br><span class="line">    CommonOperatorReducer common_reducer(&amp;graph_reducer, data-&gt;graph(),</span><br><span class="line">                                         data-&gt;broker(), data-&gt;common(),</span><br><span class="line">                                         data-&gt;machine(), temp_zone);</span><br><span class="line">  <span class="comment">//创建对JSConstruct和JSCall节点的reduce实例（ReduceObjectIs、ReduceObjectCreate等）</span></span><br><span class="line">    JSCallReducer call_reducer(&amp;graph_reducer, data-&gt;jsgraph(), data-&gt;broker(),</span><br><span class="line">                               data-&gt;info()-&gt;is_bailout_on_uninitialized()</span><br><span class="line">                                   ? JSCallReducer::kBailoutOnUninitialized</span><br><span class="line">                                   : JSCallReducer::kNoFlags,</span><br><span class="line">                               data-&gt;dependencies());</span><br><span class="line">  <span class="comment">//创建Load、StoreContext节点的reduce实例（ReduceParameter、JSLoadContext、JSStoreContext、SimplifyJSStoreContext、SimplifyJSStoreContext）</span></span><br><span class="line">    <span class="function">JSContextSpecialization <span class="title">context_specialization</span><span class="params">(</span></span></span><br><span class="line">        &amp;graph_reducer, data-&gt;jsgraph(), data-&gt;broker(),</span><br><span class="line">        data-&gt;specialization_context(),</span><br><span class="line">        data-&gt;info()-&gt;is_function_context_specializing()</span><br><span class="line">            ? data-&gt;info()-&gt;closure()</span><br><span class="line">            : MaybeHandle&lt;JSFunction&gt;());</span><br><span class="line">  <span class="comment">//设置JSNativeContextSpecialization-&gt;flag为kNoFlags</span></span><br><span class="line">    JSNativeContextSpecialization::Flags flags =</span><br><span class="line">        JSNativeContextSpecialization::kNoFlags;</span><br><span class="line">  <span class="comment">//根据输入info标识添加相应的flag标识</span></span><br><span class="line">    <span class="keyword">if</span> (data-&gt;info()-&gt;is_accessor_inlining_enabled()) &#123;</span><br><span class="line">      flags |= JSNativeContextSpecialization::kAccessorInliningEnabled;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (data-&gt;info()-&gt;is_bailout_on_uninitialized()) &#123;</span><br><span class="line">      flags |= JSNativeContextSpecialization::kBailoutOnUninitialized;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Passing the OptimizedCompilationInfo's shared zone here as</span></span><br><span class="line">    <span class="comment">// JSNativeContextSpecialization allocates out-of-heap objects</span></span><br><span class="line">    <span class="comment">// that need to live until code generation.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建Load、StoreGlobal节点的reduce实例（LoadGlobal、StoreGlobal、LoadNamed、StoreNamed、ReduceJSAdd、ReduceJSAsyncFunctionEnter等）</span></span><br><span class="line">    <span class="function">JSNativeContextSpecialization <span class="title">native_context_specialization</span><span class="params">(</span></span></span><br><span class="line">        &amp;graph_reducer, data-&gt;jsgraph(), data-&gt;broker(), flags,</span><br><span class="line">        data-&gt;dependencies(), temp_zone, info-&gt;zone());</span><br><span class="line">  <span class="comment">//具体不清楚该函数功能是什么，貌似是关于多态内联的</span></span><br><span class="line">    <span class="function">JSInliningHeuristic <span class="title">inlining</span><span class="params">(&amp;graph_reducer,</span></span></span><br><span class="line">                                 data-&gt;info()-&gt;is_inlining_enabled()</span><br><span class="line">                                     ? JSInliningHeuristic::kGeneralInlining</span><br><span class="line">                                     : JSInliningHeuristic::kRestrictedInlining,</span><br><span class="line">                                 temp_zone, data-&gt;info(), data-&gt;jsgraph(),</span><br><span class="line">                                 data-&gt;broker(), data-&gt;source_positions());</span><br><span class="line">  <span class="comment">//创建JS级别运行调用的lowers（ReduceDeoptimizeNow、ReduceIsSmi、ReduceToString）</span></span><br><span class="line">    JSIntrinsicLowering intrinsic_lowering(&amp;graph_reducer, data-&gt;jsgraph(),</span><br><span class="line">                                           data-&gt;broker());</span><br><span class="line">  <span class="comment">//添加以上各个reduce实例进IR图</span></span><br><span class="line">    AddReducer(data, &amp;graph_reducer, &amp;dead_code_elimination);</span><br><span class="line">    AddReducer(data, &amp;graph_reducer, &amp;checkpoint_elimination);</span><br><span class="line">    AddReducer(data, &amp;graph_reducer, &amp;common_reducer);</span><br><span class="line">    AddReducer(data, &amp;graph_reducer, &amp;native_context_specialization);</span><br><span class="line">    AddReducer(data, &amp;graph_reducer, &amp;context_specialization);</span><br><span class="line">    AddReducer(data, &amp;graph_reducer, &amp;intrinsic_lowering);</span><br><span class="line">    AddReducer(data, &amp;graph_reducer, &amp;call_reducer);</span><br><span class="line">    AddReducer(data, &amp;graph_reducer, &amp;inlining);</span><br><span class="line">  <span class="comment">//执行reduceGraph操作</span></span><br><span class="line">    graph_reducer.ReduceGraph();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>AddReducer</code>会将对应的reducer加入到reducers_中，reducers是vector.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> GraphReducer::AddReducer(Reducer* reducer) &#123;</span><br><span class="line">  reducers_.push_back(reducer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后执行<code>graph_reducer.ReduceGraph()</code></p>
<p>ReducerGraph:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> GraphReducer::ReduceGraph() &#123; ReduceNode(graph()-&gt;end()); &#125;</span><br></pre></td></tr></table></figure>
<p>该函数以graph的end节点开始深度优先搜索。</p>
<p>整个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> GraphReducer::ReduceNode(Node* node) &#123;</span><br><span class="line">  DCHECK(stack_.empty());</span><br><span class="line">  DCHECK(revisit_.empty());</span><br><span class="line">  Push(node);<span class="comment">//将node push 到 stack_中</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!stack_.empty()) &#123; <span class="comment">//stack_不为空</span></span><br><span class="line">      <span class="comment">// Process the node on the top of the stack, potentially pushing more or</span></span><br><span class="line">      <span class="comment">// popping the node off the stack.</span></span><br><span class="line">      ReduceTop();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!revisit_.empty()) &#123;<span class="comment">//revisit_不为空</span></span><br><span class="line">      <span class="comment">// If the stack becomes empty, revisit any nodes in the revisit queue.</span></span><br><span class="line">      Node* <span class="keyword">const</span> node = revisit_.front();</span><br><span class="line">      revisit_.pop();</span><br><span class="line">      <span class="keyword">if</span> (state_.Get(node) == State::kRevisit) &#123;</span><br><span class="line">        <span class="comment">// state can change while in queue.</span></span><br><span class="line">        Push(node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Run all finalizers.</span></span><br><span class="line">      <span class="keyword">for</span> (Reducer* <span class="keyword">const</span> reducer : reducers_) reducer-&gt;Finalize();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check if we have new nodes to revisit.</span></span><br><span class="line">      <span class="keyword">if</span> (revisit_.empty()) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="comment">//for (;;)</span></span><br><span class="line">  DCHECK(revisit_.empty());</span><br><span class="line">  DCHECK(stack_.empty());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优先搜索时维护两个栈：revisit_和stack_。revisit_存放再次访问的节点。</p>
<p>ReduceTop()是深度优先搜索的函数，将stack栈搜索完成之后清空，然后往revisit栈中搜索。</p>
<p>ReduceTop：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> GraphReducer::ReduceTop() &#123;</span><br><span class="line">  NodeState&amp; entry = stack_.top();</span><br><span class="line">  Node* node = entry.node;<span class="comment">//获取stack顶部的node</span></span><br><span class="line">  DCHECK_EQ(State::kOnStack, state_.Get(node));</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (node-&gt;IsDead()) <span class="keyword">return</span> Pop();  <span class="comment">// Node was killed while on stack.</span></span><br><span class="line"></span><br><span class="line">  Node::Inputs node_inputs = node-&gt;inputs();<span class="comment">//以该node的input_location和input_count初始化Node::Inputs</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recurse on an input if necessary.</span></span><br><span class="line">  <span class="keyword">int</span> start = entry.input_index &lt; node_inputs.count() ? entry.input_index : <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; node_inputs.count(); ++i) &#123; <span class="comment">//遍历该节点的input节点</span></span><br><span class="line">    Node* input = node_inputs[i];</span><br><span class="line">    <span class="keyword">if</span> (input != node &amp;&amp; Recurse(input)) &#123; <span class="comment">//如果该input节点没有访问过，入栈,然后返回</span></span><br><span class="line">      entry.input_index = i + <span class="number">1</span>; <span class="comment">// 压入栈中后就不会再遍历</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; start; ++i) &#123;</span><br><span class="line">    Node* input = node_inputs[i];</span><br><span class="line">    <span class="keyword">if</span> (input != node &amp;&amp; Recurse(input)) &#123;</span><br><span class="line">      entry.input_index = i + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remember the max node id before reduction.</span></span><br><span class="line">  NodeId <span class="keyword">const</span> max_id = <span class="keyword">static_cast</span>&lt;NodeId&gt;(graph()-&gt;NodeCount() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  Reduction reduction = Reduce(node);<span class="comment">//遍历所有的reducer节点reduce</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// If there was no reduction, pop &#123;node&#125; and continue.</span></span><br><span class="line">  <span class="comment">// 没有对该节点reduce，则pop</span></span><br><span class="line">  <span class="keyword">if</span> (!reduction.Changed()) <span class="keyword">return</span> Pop();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if the reduction is an in-place update of the &#123;node&#125;.</span></span><br><span class="line">  Node* <span class="keyword">const</span> replacement = reduction.replacement();</span><br><span class="line">  <span class="keyword">if</span> (replacement == node) &#123; <span class="comment">//replacement == node 代表该node被更新</span></span><br><span class="line">    <span class="comment">// In-place update of &#123;node&#125;, may need to recurse on an input.</span></span><br><span class="line">    Node::Inputs node_inputs = node-&gt;inputs();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node_inputs.count(); ++i) &#123;</span><br><span class="line">      Node* input = node_inputs[i];</span><br><span class="line">      <span class="keyword">if</span> (input != node &amp;&amp; Recurse(input)) &#123;</span><br><span class="line">        entry.input_index = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// After reducing the node, pop it off the stack.</span></span><br><span class="line">  Pop();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if we have a new replacement.</span></span><br><span class="line">  <span class="keyword">if</span> (replacement != node) &#123;</span><br><span class="line">    Replace(node, replacement, max_id);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Revisit all uses of the node.</span></span><br><span class="line">    <span class="comment">// 重新访问该节点的use节点，入栈</span></span><br><span class="line">    <span class="keyword">for</span> (Node* <span class="keyword">const</span> user : node-&gt;uses()) &#123;</span><br><span class="line">      <span class="comment">// Don't revisit this node if it refers to itself.</span></span><br><span class="line">      <span class="keyword">if</span> (user != node) Revisit(user);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="InliningPhase：-1"><a href="#InliningPhase：-1" class="headerlink" title="InliningPhase："></a>InliningPhase：</h3><p>仔细分析一下该阶段reduce所做的一些操作。</p>
<p>前面分析过了InliningPhase的大结构体的内容，现在看看ReduceGraph。</p>
<p><code>graph_reducer.ReduceGraph();</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> GraphReducer::ReduceGraph() &#123; ReduceNode(graph()-&gt;end()); &#125;</span><br></pre></td></tr></table></figure>
<p>继续看<code>ReduceNode</code>，参数为图表的<code>end</code>节点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">push标记：kOnStack</span><br><span class="line"> pop标记：kVisited</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GraphReducer::ReduceNode(Node* node) &#123;</span><br><span class="line">  DCHECK(stack_.empty());</span><br><span class="line">  DCHECK(revisit_.empty());</span><br><span class="line">  Push(node);     <span class="comment">//压入stack栈中</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!stack_.empty()) &#123;</span><br><span class="line">      <span class="comment">//如果stack栈中不为空，则进入ReduceTop函数中</span></span><br><span class="line">      <span class="comment">// Process the node on the top of the stack, potentially pushing more or</span></span><br><span class="line">      <span class="comment">// popping the node off the stack.</span></span><br><span class="line">      ReduceTop();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!revisit_.empty()) &#123;</span><br><span class="line">      <span class="comment">//如果revisit栈中不为空，则pop掉栈顶节点检查是否为kRevisit标记，是则标记为kOnStack然后压入stack栈中</span></span><br><span class="line">      <span class="comment">// If the stack becomes empty, revisit any nodes in the revisit queue.</span></span><br><span class="line">      Node* <span class="keyword">const</span> node = revisit_.front();</span><br><span class="line">      revisit_.pop();</span><br><span class="line">      <span class="keyword">if</span> (state_.Get(node) == State::kRevisit) &#123;</span><br><span class="line">        <span class="comment">// state can change while in queue.</span></span><br><span class="line">        Push(node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果stack、revisit栈都空，则执行所有reduce的析构函数，并检查revisit栈是否为空，是则结束循环</span></span><br><span class="line">      <span class="comment">// Run all finalizers.</span></span><br><span class="line">      <span class="keyword">for</span> (Reducer* <span class="keyword">const</span> reducer : reducers_) reducer-&gt;Finalize();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check if we have new nodes to revisit.</span></span><br><span class="line">      <span class="keyword">if</span> (revisit_.empty()) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  DCHECK(revisit_.empty());</span><br><span class="line">  DCHECK(stack_.empty());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看<code>ReduceTop</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> GraphReducer::ReduceTop() &#123;</span><br><span class="line">  NodeState&amp; entry = stack_.top();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// struct NodeState &#123;</span></span><br><span class="line">  <span class="comment">//   Node* node;</span></span><br><span class="line">  <span class="comment">//   int input_index;  //input节点索引下标</span></span><br><span class="line">  <span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line">  Node* node = entry.node;</span><br><span class="line">  DCHECK_EQ(State::kOnStack, state_.Get(node));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果无input节点</span></span><br><span class="line">  <span class="keyword">if</span> (node-&gt;IsDead()) <span class="keyword">return</span> Pop();  <span class="comment">// Node was killed while on stack.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//所有该node上的input节点</span></span><br><span class="line">  Node::Inputs node_inputs = node-&gt;inputs();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recurse on an input if necessary.</span></span><br><span class="line">  <span class="comment">//下面两个循环其实可以结合在一起，用的就是把每个input节点都遍历一遍，先遍历input_index后面部分，再遍历前面</span></span><br><span class="line">  <span class="comment">//（分开来的话感觉是作用于input_index赋值的？）</span></span><br><span class="line">  <span class="keyword">int</span> start = entry.input_index &lt; node_inputs.count() ? entry.input_index : <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; node_inputs.count(); ++i) &#123;</span><br><span class="line">    Node* input = node_inputs[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果该input节点不为该node节点，且&gt;kRevisit标记，return false</span></span><br><span class="line">    <span class="keyword">if</span> (input != node &amp;&amp; Recurse(input)) &#123;</span><br><span class="line">    <span class="comment">//input_index加一</span></span><br><span class="line">      entry.input_index = i + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; start; ++i) &#123;</span><br><span class="line">    Node* input = node_inputs[i];</span><br><span class="line">    <span class="keyword">if</span> (input != node &amp;&amp; Recurse(input)) &#123;</span><br><span class="line">      entry.input_index = i + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remember the max node id before reduction.</span></span><br><span class="line">  NodeId <span class="keyword">const</span> max_id = <span class="keyword">static_cast</span>&lt;NodeId&gt;(graph()-&gt;NodeCount() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// All inputs should be visited or on stack. Apply reductions to node.</span></span><br><span class="line">  Reduction reduction = Reduce(node);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If there was no reduction, pop &#123;node&#125; and continue.</span></span><br><span class="line">  <span class="comment">//如果该node在reduce中没有改变，则标记kVisited后pop stack栈</span></span><br><span class="line">  <span class="keyword">if</span> (!reduction.Changed()) <span class="keyword">return</span> Pop();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if the reduction is an in-place update of the &#123;node&#125;.</span></span><br><span class="line">  Node* <span class="keyword">const</span> replacement = reduction.replacement();</span><br><span class="line">  <span class="comment">//如果发生了节点状态更新，则需要重新遍历每个inputs节点查看是否有kRevisited标记并push到stack栈上</span></span><br><span class="line">  <span class="keyword">if</span> (replacement == node) &#123;</span><br><span class="line">    <span class="comment">// In-place update of &#123;node&#125;, may need to recurse on an input.</span></span><br><span class="line">    Node::Inputs node_inputs = node-&gt;inputs();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node_inputs.count(); ++i) &#123;</span><br><span class="line">      Node* input = node_inputs[i];</span><br><span class="line">      <span class="keyword">if</span> (input != node &amp;&amp; Recurse(input)) &#123;</span><br><span class="line">        entry.input_index = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// After reducing the node, pop it off the stack.</span></span><br><span class="line">  <span class="comment">//标记kVisited并pop stack栈</span></span><br><span class="line">  Pop();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if we have a new replacement.</span></span><br><span class="line">  <span class="comment">//如果该node直接被替换了，则进入Replace</span></span><br><span class="line">  <span class="keyword">if</span> (replacement != node) &#123;</span><br><span class="line">    Replace(node, replacement, max_id);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//否则该node的use节点如果不指向自己且都为kVisited标记，则标记为kRevisit并push到revisit栈中</span></span><br><span class="line">    <span class="comment">// Revisit all uses of the node.</span></span><br><span class="line">    <span class="keyword">for</span> (Node* <span class="keyword">const</span> user : node-&gt;uses()) &#123;</span><br><span class="line">      <span class="comment">// Don't revisit this node if it refers to itself.</span></span><br><span class="line">      <span class="keyword">if</span> (user != node) Revisit(user);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后看<code>Reduce</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Reduce阶段在该节点上按序执行之前添加的各个reduce（dead_code_elimination、checkpoint_elimination）</span><br><span class="line"></span><br><span class="line">Reduction GraphReducer::Reduce(Node* <span class="keyword">const</span> node) &#123;</span><br><span class="line">  <span class="keyword">auto</span> skip = reducers_.end();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = reducers_.begin(); i != reducers_.end();) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i != skip) &#123;</span><br><span class="line">      tick_counter_-&gt;DoTick();</span><br><span class="line">      Reduction reduction = (*i)-&gt;Reduce(node);</span><br><span class="line">      <span class="keyword">if</span> (!reduction.Changed()) &#123;         <span class="comment">//如果该node在该reduce下没有任何change，则进行下一个reduce</span></span><br><span class="line">        <span class="comment">// No change from this reducer.</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (reduction.replacement() == node) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果node发生了状态更新（非替换），则重新遍历除该reduce之外的所有reduce</span></span><br><span class="line">        <span class="comment">//同时skip变成该reduce</span></span><br><span class="line">        <span class="comment">// &#123;replacement&#125; == &#123;node&#125; represents an in-place reduction. Rerun</span></span><br><span class="line">        <span class="comment">// all the other reducers for this node, as now there may be more</span></span><br><span class="line">        <span class="comment">// opportunities for reduction.</span></span><br><span class="line">        <span class="keyword">if</span> (FLAG_trace_turbo_reduction) &#123;</span><br><span class="line">          StdoutStream&#123;&#125; &lt;&lt; <span class="string">"- In-place update of "</span> &lt;&lt; *node &lt;&lt; <span class="string">" by reducer "</span></span><br><span class="line">                         &lt;&lt; (*i)-&gt;reducer_name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        skip = i;</span><br><span class="line">        i = reducers_.begin();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果node被替换了，则直接返回该reduce</span></span><br><span class="line">        <span class="comment">// &#123;node&#125; was replaced by another node.</span></span><br><span class="line">        <span class="keyword">if</span> (FLAG_trace_turbo_reduction) &#123;</span><br><span class="line">          StdoutStream&#123;&#125; &lt;&lt; <span class="string">"- Replacement of "</span> &lt;&lt; *node &lt;&lt; <span class="string">" with "</span></span><br><span class="line">                         &lt;&lt; *(reduction.replacement()) &lt;&lt; <span class="string">" by reducer "</span></span><br><span class="line">                         &lt;&lt; (*i)-&gt;reducer_name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reduction;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果skip为最后一个reduce则node没有发生过改变</span></span><br><span class="line">  <span class="keyword">if</span> (skip == reducers_.end()) &#123;</span><br><span class="line">    <span class="comment">// No change from any reducer.</span></span><br><span class="line">    <span class="keyword">return</span> Reducer::NoChange();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果不是则至少发生了一次状态更新（即一个reduce发生作用）</span></span><br><span class="line">  <span class="comment">// At least one reducer did some in-place reduction.</span></span><br><span class="line">  <span class="keyword">return</span> Reducer::Changed(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合PPT来看看，整个reduce维护了两个栈，一个stack一个revisit。采用的是深度优先遍历，从end节点开始。遍历n6的input节点，随后n6进入reduce。</p>
<p><img src="/v8-JIT部分源码分析/11D7EBAA-064E-4A4C-87C2-E33695440086.png" alt="11D7EBAA-064E-4A4C-87C2-E33695440086"></p>
<p>如果node的inputs节点在栈中，即存在递归调用。n6的input节点n3已经在栈中，为kOnStack标记，则：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> GraphReducer::Recurse(Node* node) &#123;</span><br><span class="line">  <span class="keyword">if</span> (state_.Get(node) &gt; State::kRevisit) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  Push(node);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回false，不压入stack栈中。</p>
<p><img src="/v8-JIT部分源码分析/60DC1A9C-7607-4CCE-847C-C9BD1EEEBD6F.png" alt="60DC1A9C-7607-4CCE-847C-C9BD1EEEBD6F"></p>
<p>n6被reduce。</p>
<p><img src="/v8-JIT部分源码分析/B3DEC9EE-31C1-47BE-BE8D-E59A774F0F6A.png" alt="B3DEC9EE-31C1-47BE-BE8D-E59A774F0F6A"></p>
<p>当一个node成功reduce之后，会遍历该node的use节点（即把该node作为input节点的node）。此时n3的use节点为n6。标记为kRevisit并push到revisit栈中。而后又会被压入stack栈中。</p>
<p><img src="/v8-JIT部分源码分析/DEC70B02-F924-4BD3-8D09-191C1B1C9F32.png" alt="DEC70B02-F924-4BD3-8D09-191C1B1C9F32"></p>
<p>n6重新需要reduce。</p>
<p><img src="/v8-JIT部分源码分析/73CE78E6-8CC5-4B78-8646-F51B372148B4.png" alt="73CE78E6-8CC5-4B78-8646-F51B372148B4"></p>
<h3 id="EarlyGraphTrimmingPhase："><a href="#EarlyGraphTrimmingPhase：" class="headerlink" title="EarlyGraphTrimmingPhase："></a>EarlyGraphTrimmingPhase：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EarlyGraphTrimmingPhase</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">phase_name</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"V8.TFEarlyTrimming"</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">(PipelineData* data, Zone* temp_zone)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调整graph中的不可达节点，即删除dead node的实例</span></span><br><span class="line">    GraphTrimmer trimmer(temp_zone, data-&gt;graph());</span><br><span class="line">    <span class="comment">//创建节点向量实例</span></span><br><span class="line">    <span class="function">NodeVector <span class="title">roots</span><span class="params">(temp_zone)</span></span>;</span><br><span class="line">    data-&gt;jsgraph()-&gt;GetCachedNodes(&amp;roots);</span><br><span class="line">    trimmer.TrimGraph(roots.begin(), roots.end());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TrimGraph</span><span class="params">(ForwardIterator begin, ForwardIterator end)</span> </span>&#123;</span><br><span class="line"><span class="comment">//遍历所有节点，若节点不是死节点，则标记为live</span></span><br><span class="line">  <span class="keyword">while</span> (begin != end) &#123;</span><br><span class="line">    Node* <span class="keyword">const</span> node = *begin++;</span><br><span class="line">    <span class="keyword">if</span> (!node-&gt;IsDead()) MarkAsLive(node);</span><br><span class="line">  &#125;</span><br><span class="line">  TrimGraph();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">V8_INLINE <span class="keyword">void</span> <span class="title">MarkAsLive</span><span class="params">(Node* <span class="keyword">const</span> node)</span> </span>&#123;</span><br><span class="line">  DCHECK(!node-&gt;IsDead());</span><br><span class="line">  <span class="keyword">if</span> (!IsLive(node)) &#123;</span><br><span class="line">    is_live_.Set(node, <span class="literal">true</span>);</span><br><span class="line">    live_.push_back(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TrimGraph：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> GraphTrimmer::TrimGraph() &#123;</span><br><span class="line">  <span class="comment">// Mark end node as live.</span></span><br><span class="line">  <span class="comment">//标记end节点Live</span></span><br><span class="line">  MarkAsLive(graph()-&gt;end());</span><br><span class="line">  <span class="comment">//遍历所有Live标记的节点，把其所有input节点也标记为Live</span></span><br><span class="line">  <span class="comment">// Compute transitive closure of live nodes.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; live_.size(); ++i) &#123;</span><br><span class="line">    Node* <span class="keyword">const</span> live = live_[i];</span><br><span class="line">    <span class="keyword">for</span> (Node* <span class="keyword">const</span> input : live-&gt;inputs()) MarkAsLive(input);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Remove dead-&gt;live edges.</span></span><br><span class="line">  <span class="comment">//遍历Live标记的节点</span></span><br><span class="line">  <span class="keyword">for</span> (Node* <span class="keyword">const</span> live : live_) &#123;</span><br><span class="line">    DCHECK(IsLive(live));</span><br><span class="line">    <span class="comment">//遍历这些Live节点中的use节点，如果不为Live，则更新为dead节点</span></span><br><span class="line">    <span class="keyword">for</span> (Edge edge : live-&gt;use_edges()) &#123;</span><br><span class="line">      Node* <span class="keyword">const</span> user = edge.from();</span><br><span class="line">      <span class="keyword">if</span> (!IsLive(user)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (FLAG_trace_turbo_trimming) &#123;</span><br><span class="line">          StdoutStream&#123;&#125; &lt;&lt; <span class="string">"DeadLink: "</span> &lt;&lt; *user &lt;&lt; <span class="string">"("</span> &lt;&lt; edge.index()</span><br><span class="line">                         &lt;&lt; <span class="string">") -&gt; "</span> &lt;&lt; *live &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        edge.UpdateTo(<span class="literal">nullptr</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CreateGraph：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> PipelineImpl::CreateGraph() &#123;</span><br><span class="line">  PipelineData* data = <span class="keyword">this</span>-&gt;data_;</span><br><span class="line"></span><br><span class="line">  data-&gt;BeginPhaseKind(<span class="string">"V8.TFGraphCreation"</span>);</span><br><span class="line"></span><br><span class="line">  Run&lt;GraphBuilderPhase&gt;();</span><br><span class="line">  RunPrintAndVerify(GraphBuilderPhase::phase_name(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Perform function context specialization and inlining (if enabled).</span></span><br><span class="line">  Run&lt;InliningPhase&gt;();</span><br><span class="line">  RunPrintAndVerify(InliningPhase::phase_name(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove dead-&gt;live edges from the graph.</span></span><br><span class="line">  Run&lt;EarlyGraphTrimmingPhase&gt;();</span><br><span class="line">  RunPrintAndVerify(EarlyGraphTrimmingPhase::phase_name(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//确定typer阶段的flag标志</span></span><br><span class="line">  <span class="comment">// Determine the Typer operation flags.</span></span><br><span class="line">  &#123;</span><br><span class="line">    SharedFunctionInfoRef shared_info(data-&gt;broker(), info()-&gt;shared_info());</span><br><span class="line">    <span class="comment">//如果是sloppy模式则添加kThisIsReceiver标识（表示this参数是一个Object）</span></span><br><span class="line">    <span class="keyword">if</span> (is_sloppy(shared_info.language_mode()) &amp;&amp;</span><br><span class="line">        shared_info.IsUserJavaScript()) &#123;</span><br><span class="line">      <span class="comment">// Sloppy mode functions always have an Object for this.</span></span><br><span class="line">      data-&gt;AddTyperFlag(Typer::kThisIsReceiver);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//（表示参数new.target是一个Object）</span></span><br><span class="line">    <span class="keyword">if</span> (IsClassConstructor(shared_info.kind())) &#123;</span><br><span class="line">      <span class="comment">// Class constructors cannot be [[Call]]ed.</span></span><br><span class="line">      data-&gt;AddTyperFlag(Typer::kNewTargetIsReceiver);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//类型敏感的简化和优化（一般不会执行）</span></span><br><span class="line">  <span class="comment">// Run the type-sensitive lowerings and optimizations on the graph.</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (!FLAG_concurrent_inlining) &#123;</span><br><span class="line">      <span class="comment">//初始化一些标准对象</span></span><br><span class="line">      Run&lt;HeapBrokerInitializationPhase&gt;();</span><br><span class="line">      <span class="comment">//调用JSHeapCopyReducer</span></span><br><span class="line">      Run&lt;CopyMetadataForConcurrentCompilePhase&gt;();</span><br><span class="line">      <span class="comment">//标记已序列化过（kSerialized）</span></span><br><span class="line">      data-&gt;broker()-&gt;StopSerializing();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//阶段结束</span></span><br><span class="line">  data-&gt;EndPhaseKind();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HeapBrokerInitializationPhase：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapBrokerInitializationPhase</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">phase_name</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"V8.TFHeapBrokerInitialization"</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">(PipelineData* data, Zone* temp_zone)</span> </span>&#123;</span><br><span class="line">    data-&gt;broker()-&gt;InitializeAndStartSerializing(data-&gt;native_context());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>OptimizeGraph：（优化块）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PipelineCompilationJob::Status PipelineCompilationJob::ExecuteJobImpl() &#123;</span><br><span class="line">  <span class="keyword">if</span> (FLAG_concurrent_inlining) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!pipeline_.CreateGraph()) &#123;</span><br><span class="line">      <span class="keyword">return</span> AbortOptimization(BailoutReason::kGraphBuildingFailed);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> success;</span><br><span class="line">  <span class="keyword">if</span> (FLAG_turboprop) &#123;</span><br><span class="line">    <span class="comment">//启用中间层编译器</span></span><br><span class="line">    success = pipeline_.OptimizeGraphForMidTier(linkage_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    success = pipeline_.OptimizeGraph(linkage_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!success) <span class="keyword">return</span> FAILED;</span><br><span class="line"></span><br><span class="line">  pipeline_.AssembleCode(linkage_);</span><br><span class="line">  <span class="keyword">return</span> SUCCEEDED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TyperPhase：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TyperPhase</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">phase_name</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"V8.TFTyper"</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">(PipelineData* data, Zone* temp_zone, Typer* typer)</span> </span>&#123;</span><br><span class="line">    <span class="function">NodeVector <span class="title">roots</span><span class="params">(temp_zone)</span></span>;</span><br><span class="line">    data-&gt;jsgraph()-&gt;GetCachedNodes(&amp;roots);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure we always type True and False. Needed for escape analysis.</span></span><br><span class="line">    <span class="comment">//节点向量加入True False常数（为逃逸分析阶段做准备）</span></span><br><span class="line">    roots.push_back(data-&gt;jsgraph()-&gt;TrueConstant());</span><br><span class="line">    roots.push_back(data-&gt;jsgraph()-&gt;FalseConstant());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建循环变量优化实例</span></span><br><span class="line">    LoopVariableOptimizer induction_vars(data-&gt;jsgraph()-&gt;graph(),</span><br><span class="line">                                         data-&gt;common(), temp_zone);</span><br><span class="line">    <span class="keyword">if</span> (FLAG_turbo_loop_variable) induction_vars.Run();</span><br><span class="line">    typer-&gt;Run(roots, &amp;induction_vars);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>LoopVariableOptimizer::Run:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> LoopVariableOptimizer::Run() &#123;</span><br><span class="line">  ZoneQueue&lt;Node*&gt; <span class="built_in">queue</span>(zone());</span><br><span class="line">  <span class="comment">//start节点压入队列</span></span><br><span class="line">  <span class="built_in">queue</span>.push(graph()-&gt;start());</span><br><span class="line">  设置mark_min_和mark_max_（mark_max_,mark_max_+<span class="number">2</span>）</span><br><span class="line">  NodeMarker&lt;<span class="keyword">bool</span>&gt; queued(graph(), <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">queue</span>.empty()) &#123;</span><br><span class="line">    Node* node = <span class="built_in">queue</span>.front();</span><br><span class="line">    <span class="built_in">queue</span>.pop();</span><br><span class="line">    <span class="comment">//设置node节点的mark_属性（mark_=mark_min_+false）</span></span><br><span class="line">    queued.Set(node, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    DCHECK(!reduced_.Get(node));</span><br><span class="line">    <span class="comment">//自start节点起遍如果遍历到了GetControlInput，则搜索该node的use节点</span></span><br><span class="line">    <span class="keyword">bool</span> all_inputs_visited = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> inputs_end = (node-&gt;opcode() == IrOpcode::kLoop)</span><br><span class="line">                         ? kFirstBackedge</span><br><span class="line">                         : node-&gt;op()-&gt;ControlInputCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inputs_end; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!reduced_.Get(NodeProperties::GetControlInput(node, i))) &#123;</span><br><span class="line">        all_inputs_visited = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下一轮搜索</span></span><br><span class="line">    <span class="keyword">if</span> (!all_inputs_visited) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    VisitNode(node);</span><br><span class="line">    reduced_.Set(node, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queue control outputs.</span></span><br><span class="line">    <span class="keyword">for</span> (Edge edge : node-&gt;use_edges()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (NodeProperties::IsControlEdge(edge) &amp;&amp;</span><br><span class="line">          edge.from()-&gt;op()-&gt;ControlOutputCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node* use = edge.from();</span><br><span class="line">        <span class="keyword">if</span> (use-&gt;opcode() == IrOpcode::kLoop &amp;&amp;</span><br><span class="line">            edge.index() != kAssumedLoopEntryIndex) &#123;</span><br><span class="line">          VisitBackedge(node, use);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!queued.Get(use)) &#123;</span><br><span class="line">          <span class="built_in">queue</span>.push(use);</span><br><span class="line">          queued.Set(use, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TyperPhase："><a href="#TyperPhase：" class="headerlink" title="TyperPhase："></a>TyperPhase：</h3><p>接着看TyperPhase，在Typer::Run阶段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Typer::Run(<span class="keyword">const</span> NodeVector&amp; roots,</span><br><span class="line">                LoopVariableOptimizer* induction_vars) &#123;</span><br><span class="line">  <span class="keyword">if</span> (induction_vars != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    induction_vars-&gt;ChangeToInductionVariablePhis();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//创建visitor的reduce实例，为后面的ReduceGraph作准备</span></span><br><span class="line">  <span class="function">Visitor <span class="title">visitor</span><span class="params">(<span class="keyword">this</span>, induction_vars)</span></span>;</span><br><span class="line">  GraphReducer graph_reducer(zone(), graph(), tick_counter_);</span><br><span class="line">  graph_reducer.AddReducer(&amp;visitor);</span><br><span class="line">  <span class="comment">//遍历节点向量，执行reduce node</span></span><br><span class="line">  <span class="keyword">for</span> (Node* <span class="keyword">const</span> root : roots) graph_reducer.ReduceNode(root);</span><br><span class="line">  <span class="comment">//从end节点开始深度优先reduce，采用的reduce方法为visitor</span></span><br><span class="line">  graph_reducer.ReduceGraph();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (induction_vars != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    induction_vars-&gt;ChangeToPhisAndInsertGuards();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    接着是其中的visitor的reduce内容，主要就是所有节点对比opcode然后返回type类型并执行一些基本的reduce：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Typer</span>:</span>:Visitor : <span class="keyword">public</span> Reducer &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Visitor</span><span class="params">(Typer* typer, LoopVariableOptimizer* induction_vars)</span></span></span><br><span class="line">      : typer_(typer),</span><br><span class="line">        induction_vars_(induction_vars),</span><br><span class="line">        weakened_nodes_(typer-&gt;zone()),</span><br><span class="line">        remembered_types_(typer-&gt;zone()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">reducer_name</span><span class="params">()</span> <span class="keyword">const</span> override </span>&#123; <span class="keyword">return</span> <span class="string">"Typer"</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Reduction <span class="title">Reduce</span><span class="params">(Node* node)</span> override </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;op()-&gt;ValueOutputCount() == <span class="number">0</span>) <span class="keyword">return</span> NoChange();</span><br><span class="line">    <span class="comment">//以下这些宏都是opcode，根据case对比各个宏里面的opcode</span></span><br><span class="line">    <span class="comment">//其中例如SIMPLIFIED_COMPARE_BINOP_LIST中的定义如下：</span></span><br><span class="line">    <span class="comment">//  #define SIMPLIFIED_COMPARE_BINOP_LIST(V) \</span></span><br><span class="line">    <span class="comment">//    V(NumberEqual)                         \</span></span><br><span class="line">    <span class="comment">//    V(NumberLessThan)                      \</span></span><br><span class="line">    <span class="comment">//    V(NumberLessThanOrEqual)               \</span></span><br><span class="line">    <span class="comment">//    V(SpeculativeNumberEqual)              \</span></span><br><span class="line">    <span class="comment">//    V(SpeculativeNumberLessThan)           \</span></span><br><span class="line">    <span class="comment">//    V(SpeculativeNumberLessThanOrEqual)    \</span></span><br><span class="line">    <span class="comment">//    V(ReferenceEqual)                      \</span></span><br><span class="line">    <span class="comment">//    V(SameValue)                           \</span></span><br><span class="line">    <span class="comment">//    V(SameValueNumbersOnly)                \</span></span><br><span class="line">    <span class="comment">//    V(NumberSameValue)                     \</span></span><br><span class="line">    <span class="comment">//    V(StringEqual)                         \</span></span><br><span class="line">    <span class="comment">//    V(StringLessThan)                      \</span></span><br><span class="line">    <span class="comment">//    V(StringLessThanOrEqual)</span></span><br><span class="line"></span><br><span class="line">    typer.cc里再看看NumberEqual函数：</span><br><span class="line">    Type Typer::Visitor::TypeNumberEqual(Node* node) &#123;</span><br><span class="line">  		<span class="keyword">return</span> TypeBinaryOp(node, NumberEqualTyper);</span><br><span class="line">	&#125;</span><br><span class="line">	查看调用之后就会发现是JS_SIMPLE_BINOP_LIST中调用的。</span><br><span class="line">    --------------------------</span><br><span class="line">    <span class="keyword">switch</span> (node-&gt;opcode()) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_CASE(x) \</span></span><br><span class="line">  <span class="comment">//该case中对应的都是加上Typer后缀的opcode，例如JSHasInPrototypeChain：</span></span><br><span class="line">  <span class="comment">//Type Typer::Visitor::JSHasInPrototypeChainTyper(Type lhs, Type rhs, Typer* t) &#123;</span></span><br><span class="line">  <span class="comment">//	return Type::Boolean();</span></span><br><span class="line">  <span class="comment">//&#125;等等</span></span><br><span class="line">  <span class="keyword">case</span> IrOpcode::k#<span class="meta">#x:  \</span></span><br><span class="line">    <span class="keyword">return</span> UpdateType(node, TypeBinaryOp(node, x##Typer));</span><br><span class="line">      JS_SIMPLE_BINOP_LIST(DECLARE_CASE)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> DECLARE_CASE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_CASE(x) \</span></span><br><span class="line">  <span class="comment">//该case中对应的是加上Type前缀的opcode，例如EffectPhi：</span></span><br><span class="line">  <span class="comment">//Type Typer::Visitor::TypeEffectPhi(Node* node) &#123; UNREACHABLE(); &#125;</span></span><br><span class="line">  <span class="comment">//等等</span></span><br><span class="line">  <span class="keyword">case</span> IrOpcode::k#<span class="meta">#x:  \</span></span><br><span class="line">    <span class="keyword">return</span> UpdateType(node, Type##x(node));</span><br><span class="line">      DECLARE_CASE(Start)</span><br><span class="line">      DECLARE_CASE(IfException)</span><br><span class="line">      <span class="comment">// VALUE_OP_LIST without JS_SIMPLE_BINOP_LIST:</span></span><br><span class="line">      COMMON_OP_LIST(DECLARE_CASE)</span><br><span class="line">      SIMPLIFIED_COMPARE_BINOP_LIST(DECLARE_CASE)</span><br><span class="line">      SIMPLIFIED_OTHER_OP_LIST(DECLARE_CASE)</span><br><span class="line">      JS_SIMPLE_UNOP_LIST(DECLARE_CASE)</span><br><span class="line">      JS_OBJECT_OP_LIST(DECLARE_CASE)</span><br><span class="line">      JS_CONTEXT_OP_LIST(DECLARE_CASE)</span><br><span class="line">      JS_OTHER_OP_LIST(DECLARE_CASE)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> DECLARE_CASE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_CASE(x) \</span></span><br><span class="line">  <span class="comment">//该case对应的是含有两个操作数的opcode，例如SIMPLIFIED_NUMBER_BINOP_LIST中的：</span></span><br><span class="line">  <span class="comment">//#define SIMPLIFIED_NUMBER_BINOP_LIST(V) \</span></span><br><span class="line">  <span class="comment">//  V(NumberAdd)                          \</span></span><br><span class="line">  <span class="comment">//  V(NumberSubtract)                     \</span></span><br><span class="line">  <span class="comment">//  V(NumberMultiply)                     \</span></span><br><span class="line">  <span class="comment">//  V(NumberDivide)                       \</span></span><br><span class="line">  <span class="comment">//  V(NumberModulus)                      \</span></span><br><span class="line">  <span class="comment">//  V(NumberBitwiseOr)                    \</span></span><br><span class="line">  <span class="comment">//  V(NumberBitwiseXor)                   \</span></span><br><span class="line">  <span class="comment">//  V(NumberBitwiseAnd)                   \</span></span><br><span class="line">  <span class="comment">//  V(NumberShiftLeft)                    \</span></span><br><span class="line">  <span class="comment">//  V(NumberShiftRight)                   \</span></span><br><span class="line">  <span class="comment">//  V(NumberShiftRightLogical)            \</span></span><br><span class="line">  <span class="comment">//  V(NumberAtan2)                        \</span></span><br><span class="line">  <span class="comment">//  V(NumberImul)                         \</span></span><br><span class="line">  <span class="comment">//  V(NumberMax)                          \</span></span><br><span class="line">  <span class="comment">//  V(NumberMin)                          \</span></span><br><span class="line">  <span class="comment">//  V(NumberPow)</span></span><br><span class="line">  <span class="comment">//以上的opcode都是二元操作数</span></span><br><span class="line">  <span class="keyword">case</span> IrOpcode::k#<span class="meta">#x:  \</span></span><br><span class="line">    <span class="keyword">return</span> UpdateType(node, TypeBinaryOp(node, x));</span><br><span class="line">      SIMPLIFIED_NUMBER_BINOP_LIST(DECLARE_CASE)</span><br><span class="line">      SIMPLIFIED_BIGINT_BINOP_LIST(DECLARE_CASE)</span><br><span class="line">      SIMPLIFIED_SPECULATIVE_NUMBER_BINOP_LIST(DECLARE_CASE)</span><br><span class="line">      SIMPLIFIED_SPECULATIVE_BIGINT_BINOP_LIST(DECLARE_CASE)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> DECLARE_CASE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_CASE(x) \</span></span><br><span class="line">  <span class="comment">//该case对应的是含有一个操作数的opcode，例如SIMPLIFIED_NUMBER_UNOP_LIST：</span></span><br><span class="line">  <span class="comment">//#define SIMPLIFIED_NUMBER_UNOP_LIST(V) \</span></span><br><span class="line">  <span class="comment">//  V(NumberAbs)                         \</span></span><br><span class="line">  <span class="comment">//  V(NumberAcos)                        \</span></span><br><span class="line">  <span class="comment">//  V(NumberAcosh)                       \</span></span><br><span class="line">  <span class="comment">//  V(NumberAsin)                        \</span></span><br><span class="line">  <span class="comment">//  V(NumberAsinh)                       \</span></span><br><span class="line">  <span class="comment">//  V(NumberAtan)                        \</span></span><br><span class="line">  <span class="comment">//  V(NumberAtanh)                       \</span></span><br><span class="line">  <span class="comment">//  V(NumberCbrt)                        \</span></span><br><span class="line">  <span class="comment">//  V(NumberCeil)                        \</span></span><br><span class="line">  <span class="comment">//  V(NumberClz32)                       \</span></span><br><span class="line">  <span class="comment">//  V(NumberCos)                         \</span></span><br><span class="line">  <span class="comment">//  V(NumberCosh)                        \</span></span><br><span class="line">  <span class="comment">//  V(NumberExp)                         \</span></span><br><span class="line">  <span class="comment">//  V(NumberExpm1)                       \</span></span><br><span class="line">  <span class="comment">//  V(NumberFloor)                       \</span></span><br><span class="line">  <span class="comment">//  V(NumberFround)                      \</span></span><br><span class="line">  <span class="comment">//  V(NumberLog)                         \</span></span><br><span class="line">  <span class="comment">//  V(NumberLog1p)                       \</span></span><br><span class="line">  <span class="comment">//  .........</span></span><br><span class="line">  <span class="comment">//以上opcode都是单元操作数</span></span><br><span class="line">  <span class="comment">//不过此处的opcode一般都被JSCall所引用</span></span><br><span class="line">  <span class="keyword">case</span> IrOpcode::k#<span class="meta">#x:  \</span></span><br><span class="line">    <span class="keyword">return</span> UpdateType(node, TypeUnaryOp(node, x));</span><br><span class="line">      SIMPLIFIED_NUMBER_UNOP_LIST(DECLARE_CASE)</span><br><span class="line">      SIMPLIFIED_BIGINT_UNOP_LIST(DECLARE_CASE)</span><br><span class="line">      SIMPLIFIED_SPECULATIVE_NUMBER_UNOP_LIST(DECLARE_CASE)</span><br><span class="line">      SIMPLIFIED_SPECULATIVE_BIGINT_UNOP_LIST(DECLARE_CASE)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> DECLARE_CASE</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//该case对应的是没有type类型的opcode，loop、switch、IfTrue这些都是不包含type的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_CASE(x) case IrOpcode::k##x:</span></span><br><span class="line">      DECLARE_CASE(Loop)</span><br><span class="line">      DECLARE_CASE(Branch)</span><br><span class="line">      DECLARE_CASE(IfTrue)</span><br><span class="line">      DECLARE_CASE(IfFalse)</span><br><span class="line">      DECLARE_CASE(IfSuccess)</span><br><span class="line">      DECLARE_CASE(Switch)</span><br><span class="line">      DECLARE_CASE(IfValue)</span><br><span class="line">      DECLARE_CASE(IfDefault)</span><br><span class="line">      DECLARE_CASE(Merge)</span><br><span class="line">      DECLARE_CASE(Deoptimize)</span><br><span class="line">      DECLARE_CASE(DeoptimizeIf)</span><br><span class="line">      DECLARE_CASE(DeoptimizeUnless)</span><br><span class="line">      DECLARE_CASE(TrapIf)</span><br><span class="line">      DECLARE_CASE(TrapUnless)</span><br><span class="line">      DECLARE_CASE(Return)</span><br><span class="line">      DECLARE_CASE(TailCall)</span><br><span class="line">      DECLARE_CASE(Terminate)</span><br><span class="line">      DECLARE_CASE(OsrNormalEntry)</span><br><span class="line">      DECLARE_CASE(OsrLoopEntry)</span><br><span class="line">      DECLARE_CASE(Throw)</span><br><span class="line">      DECLARE_CASE(End)</span><br><span class="line">      SIMPLIFIED_CHANGE_OP_LIST(DECLARE_CASE)</span><br><span class="line">      SIMPLIFIED_CHECKED_OP_LIST(DECLARE_CASE)</span><br><span class="line">      MACHINE_SIMD_OP_LIST(DECLARE_CASE)</span><br><span class="line">      MACHINE_OP_LIST(DECLARE_CASE)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> DECLARE_CASE</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NoChange();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>TyperPhase就差不多结束了，之前没审计的时候以为该阶段就只是给node节点加上type类型，现在知道了还是有少部分reduce的。不过基本涵盖了所有的opcode，具体的一些返回type类型和reduce函数就不细看了…实在是太多。</p>
<p>后面是TypedLoweringPhase。</p>
<h3 id="TypedLoweringPhase："><a href="#TypedLoweringPhase：" class="headerlink" title="TypedLoweringPhase："></a>TypedLoweringPhase：</h3><p>先看结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypedLoweringPhase</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">phase_name</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"V8.TFTypedLowering"</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">(PipelineData* data, Zone* temp_zone)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建IR Reduce实例</span></span><br><span class="line">    GraphReducer graph_reducer(temp_zone, data-&gt;graph(),</span><br><span class="line">                               &amp;data-&gt;info()-&gt;tick_counter(),</span><br><span class="line">                               data-&gt;jsgraph()-&gt;Dead());</span><br><span class="line">    DeadCodeElimination dead_code_elimination(&amp;graph_reducer, data-&gt;graph(),</span><br><span class="line">                                              data-&gt;common(), temp_zone);</span><br><span class="line">    JSCreateLowering create_lowering(&amp;graph_reducer, data-&gt;dependencies(),</span><br><span class="line">                                     data-&gt;jsgraph(), data-&gt;broker(),</span><br><span class="line">                                     temp_zone);</span><br><span class="line">    JSTypedLowering typed_lowering(&amp;graph_reducer, data-&gt;jsgraph(),</span><br><span class="line">                                   data-&gt;broker(), temp_zone);</span><br><span class="line">    <span class="function">ConstantFoldingReducer <span class="title">constant_folding_reducer</span><span class="params">(</span></span></span><br><span class="line">        &amp;graph_reducer, data-&gt;jsgraph(), data-&gt;broker());</span><br><span class="line">    TypedOptimization typed_optimization(&amp;graph_reducer, data-&gt;dependencies(),</span><br><span class="line">                                         data-&gt;jsgraph(), data-&gt;broker());</span><br><span class="line">    SimplifiedOperatorReducer simple_reducer(&amp;graph_reducer, data-&gt;jsgraph(),</span><br><span class="line">                                             data-&gt;broker());</span><br><span class="line">    <span class="function">CheckpointElimination <span class="title">checkpoint_elimination</span><span class="params">(&amp;graph_reducer)</span></span>;</span><br><span class="line">    CommonOperatorReducer common_reducer(&amp;graph_reducer, data-&gt;graph(),</span><br><span class="line">                                         data-&gt;broker(), data-&gt;common(),</span><br><span class="line">                                         data-&gt;machine(), temp_zone);</span><br><span class="line">    AddReducer(data, &amp;graph_reducer, &amp;dead_code_elimination);</span><br><span class="line">    AddReducer(data, &amp;graph_reducer, &amp;create_lowering);</span><br><span class="line">    AddReducer(data, &amp;graph_reducer, &amp;constant_folding_reducer);</span><br><span class="line">    AddReducer(data, &amp;graph_reducer, &amp;typed_lowering);</span><br><span class="line">    AddReducer(data, &amp;graph_reducer, &amp;typed_optimization);</span><br><span class="line">    AddReducer(data, &amp;graph_reducer, &amp;simple_reducer);</span><br><span class="line">    AddReducer(data, &amp;graph_reducer, &amp;checkpoint_elimination);</span><br><span class="line">    AddReducer(data, &amp;graph_reducer, &amp;common_reducer);</span><br><span class="line">    <span class="comment">//该函数之前已经分析过了，深度优先</span></span><br><span class="line">    graph_reducer.ReduceGraph();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于之前审过Builder阶段，还是很类似的，所以一目了然，主要看这些的reduce就可以了。</p>
<h4 id="DeadCodeElimination"><a href="#DeadCodeElimination" class="headerlink" title="DeadCodeElimination"></a>DeadCodeElimination</h4><p>（作用于end、loop、merge等节点）（主要作用是消除dead节点）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Reduction DeadCodeElimination::Reduce(Node* node) &#123;</span><br><span class="line">  DisallowHeapAccess no_heap_access;</span><br><span class="line">  <span class="keyword">switch</span> (node-&gt;opcode()) &#123;</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kEnd:</span><br><span class="line">      <span class="keyword">return</span> ReduceEnd(node);</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kLoop:</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kMerge:</span><br><span class="line">      <span class="keyword">return</span> ReduceLoopOrMerge(node);</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kLoopExit:</span><br><span class="line">      <span class="keyword">return</span> ReduceLoopExit(node);</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kUnreachable:</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kIfException:</span><br><span class="line">      <span class="keyword">return</span> ReduceUnreachableOrIfException(node);</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kPhi:</span><br><span class="line">      <span class="keyword">return</span> ReducePhi(node);</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kEffectPhi:</span><br><span class="line">      <span class="keyword">return</span> ReduceEffectPhi(node);</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kDeoptimize:</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kReturn:</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kTerminate:</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kTailCall:</span><br><span class="line">      <span class="keyword">return</span> ReduceDeoptimizeOrReturnOrTerminateOrTailCall(node);</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kThrow:</span><br><span class="line">      <span class="keyword">return</span> PropagateDeadControl(node);</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kBranch:</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kSwitch:</span><br><span class="line">      <span class="keyword">return</span> ReduceBranchOrSwitch(node);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> ReduceNode(node);</span><br><span class="line">  &#125;</span><br><span class="line">  UNREACHABLE();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应opcode执行reduce，不过后面审各个的reduce的时候，审到第三个就发现是大同小异的，执行流程其实基本都差不多，就是遍历所有node输去检查有没有dead节点再消除的过程。所以这里就审了前面几个部分。</p>
<p>ReduceEnd：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Reduction DeadCodeElimination::ReduceEnd(Node* node) &#123;</span><br><span class="line">  DCHECK_EQ(IrOpcode::kEnd, node-&gt;opcode());</span><br><span class="line">  <span class="comment">//得到所有inputs节点</span></span><br><span class="line">  Node::Inputs inputs = node-&gt;inputs();</span><br><span class="line">  DCHECK_LE(<span class="number">1</span>, inputs.count());</span><br><span class="line">  <span class="keyword">int</span> live_input_count = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//循环遍历inputs节点，记录活节点（非dead节点，live_input_count）</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inputs.count(); ++i) &#123;</span><br><span class="line">    Node* <span class="keyword">const</span> input = inputs[i];</span><br><span class="line">    <span class="comment">// Skip dead inputs.</span></span><br><span class="line">    <span class="keyword">if</span> (input-&gt;opcode() == IrOpcode::kDead) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// Compact live inputs.</span></span><br><span class="line">    <span class="comment">//紧凑非dead节点，往前移位（index前移）</span></span><br><span class="line">    <span class="keyword">if</span> (i != live_input_count) node-&gt;ReplaceInput(live_input_count, input);</span><br><span class="line">    ++live_input_count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果全是dead节点，则用dead节点代替end的inputs节点</span></span><br><span class="line">  <span class="keyword">if</span> (live_input_count == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Replace(dead());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (live_input_count &lt; inputs.count()) &#123;</span><br><span class="line">  <span class="comment">//如果只有部分dead节点，则重新end的input_count，返回Changed</span></span><br><span class="line">    node-&gt;TrimInputCount(live_input_count);</span><br><span class="line">    NodeProperties::ChangeOp(node, common()-&gt;End(live_input_count));</span><br><span class="line">    <span class="keyword">return</span> Changed(node);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//无dead节点，返回NoChange</span></span><br><span class="line">  DCHECK_EQ(inputs.count(), live_input_count);</span><br><span class="line">  <span class="keyword">return</span> NoChange();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReduceLoopOrMerge：（作用于loop和merge）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">Reduction DeadCodeElimination::ReduceLoopOrMerge(Node* node) &#123;</span><br><span class="line">  DCHECK(IrOpcode::IsMergeOpcode(node-&gt;opcode()));</span><br><span class="line">  Node::Inputs inputs = node-&gt;inputs();</span><br><span class="line">  DCHECK_LE(<span class="number">1</span>, inputs.count());</span><br><span class="line">  <span class="comment">// Count the number of live inputs to &#123;node&#125; and compact them on the fly, also</span></span><br><span class="line">  <span class="comment">// compacting the inputs of the associated &#123;Phi&#125; and &#123;EffectPhi&#125; uses at the</span></span><br><span class="line">  <span class="comment">// same time.  We consider &#123;Loop&#125;s dead even if only the first control input</span></span><br><span class="line">  <span class="comment">// is dead.</span></span><br><span class="line">  <span class="keyword">int</span> live_input_count = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//是否为loop节点，且第一个input节点是否为dead节点</span></span><br><span class="line">  <span class="comment">//后续跟上面函数一样，紧凑非dead节点</span></span><br><span class="line">  <span class="keyword">if</span> (node-&gt;opcode() != IrOpcode::kLoop ||</span><br><span class="line">      node-&gt;InputAt(<span class="number">0</span>)-&gt;opcode() != IrOpcode::kDead) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inputs.count(); ++i) &#123;</span><br><span class="line">      Node* <span class="keyword">const</span> input = inputs[i];</span><br><span class="line">      <span class="comment">// Skip dead inputs.</span></span><br><span class="line">      <span class="keyword">if</span> (input-&gt;opcode() == IrOpcode::kDead) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">// Compact live inputs.</span></span><br><span class="line">      <span class="keyword">if</span> (live_input_count != i) &#123;</span><br><span class="line">        node-&gt;ReplaceInput(live_input_count, input);</span><br><span class="line">        <span class="comment">//还遍历use节点为Phi、EffectPhi的节点，如果是则把use节点的input节点也紧凑一遍</span></span><br><span class="line">        <span class="keyword">for</span> (Node* <span class="keyword">const</span> use : node-&gt;uses()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (NodeProperties::IsPhi(use)) &#123;</span><br><span class="line">            DCHECK_EQ(inputs.count() + <span class="number">1</span>, use-&gt;InputCount());</span><br><span class="line">            use-&gt;ReplaceInput(live_input_count, use-&gt;InputAt(i));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ++live_input_count;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (live_input_count == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Replace(dead());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (live_input_count == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//如果只有一个input节点为非dead节点</span></span><br><span class="line">    NodeVector loop_exits(zone_);</span><br><span class="line">    <span class="comment">// Due to compaction above, the live input is at offset 0.</span></span><br><span class="line">    <span class="comment">//遍历use节点并把Phi的use节点替换为index为0的input节点</span></span><br><span class="line">    <span class="keyword">for</span> (Node* <span class="keyword">const</span> use : node-&gt;uses()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (NodeProperties::IsPhi(use)) &#123;</span><br><span class="line">        Replace(use, use-&gt;InputAt(<span class="number">0</span>));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (use-&gt;opcode() == IrOpcode::kLoopExit &amp;&amp;</span><br><span class="line">                 use-&gt;InputAt(<span class="number">1</span>) == node) &#123;</span><br><span class="line">        <span class="comment">//如果不为Phi而是loopexit并且index为1的input节点就是node</span></span><br><span class="line">        <span class="comment">//则将该use节点压入loopexits空间</span></span><br><span class="line">        <span class="comment">// Remember the loop exits so that we can mark their loop input dead.</span></span><br><span class="line">        <span class="comment">// This has to be done after the use list iteration so that we do</span></span><br><span class="line">        <span class="comment">// not mutate the use list while it is being iterated.</span></span><br><span class="line">        loop_exits.push_back(use);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (use-&gt;opcode() == IrOpcode::kTerminate) &#123;</span><br><span class="line">        <span class="comment">//如果为Terminate，则dead节点代替use节点</span></span><br><span class="line">        DCHECK_EQ(IrOpcode::kLoop, node-&gt;opcode());</span><br><span class="line">        Replace(use, dead());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历loopexits空间，loopexits中的节点（use）将index为1的input节点替换为dead，重复visit每个节点</span></span><br><span class="line">    <span class="keyword">for</span> (Node* loop_exit : loop_exits) &#123;</span><br><span class="line">      loop_exit-&gt;ReplaceInput(<span class="number">1</span>, dead());</span><br><span class="line">      Revisit(loop_exit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将node用index为0的input节点代替</span></span><br><span class="line">    <span class="keyword">return</span> Replace(node-&gt;InputAt(<span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  DCHECK_LE(<span class="number">2</span>, live_input_count);</span><br><span class="line">  DCHECK_LE(live_input_count, inputs.count());</span><br><span class="line">  <span class="comment">// Trim input count for the &#123;Merge&#125; or &#123;Loop&#125; node.</span></span><br><span class="line">  <span class="comment">//如果input中肯定有dead节点</span></span><br><span class="line">  <span class="keyword">if</span> (live_input_count &lt; inputs.count()) &#123;</span><br><span class="line">    <span class="comment">// Trim input counts for all phi uses and revisit them.</span></span><br><span class="line">    <span class="comment">//遍历该node的use节点，如果为Phi，则将node节点紧凑</span></span><br><span class="line">    <span class="keyword">for</span> (Node* <span class="keyword">const</span> use : node-&gt;uses()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (NodeProperties::IsPhi(use)) &#123;</span><br><span class="line">        use-&gt;ReplaceInput(live_input_count, node);</span><br><span class="line">        TrimMergeOrPhi(use, live_input_count);</span><br><span class="line">        Revisit(use);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修整node节点的live_input个数</span></span><br><span class="line">    TrimMergeOrPhi(node, live_input_count);</span><br><span class="line">    <span class="keyword">return</span> Changed(node);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> NoChange();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReduceLoopExit：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Reduction DeadCodeElimination::ReduceLoopExit(Node* node) &#123;</span><br><span class="line">  Node* control = NodeProperties::GetControlInput(node, <span class="number">0</span>);</span><br><span class="line">  Node* loop = NodeProperties::GetControlInput(node, <span class="number">1</span>);</span><br><span class="line">  <span class="comment">//如果control和loop节点有一个是dead，则遍历node的use节点，如果为LoopExitValue、LoopExitEffect，则用use节点//的input（index为0）节点代替use，最终用control节点代替node</span></span><br><span class="line">  <span class="keyword">if</span> (control-&gt;opcode() == IrOpcode::kDead ||</span><br><span class="line">      loop-&gt;opcode() == IrOpcode::kDead) &#123;</span><br><span class="line">    <span class="keyword">return</span> RemoveLoopExit(node);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> NoChange();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReduceUnreachableOrIfException：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Reduction DeadCodeElimination::ReduceUnreachableOrIfException(Node* node) &#123;</span><br><span class="line">  DCHECK(node-&gt;opcode() == IrOpcode::kUnreachable ||</span><br><span class="line">         node-&gt;opcode() == IrOpcode::kIfException);</span><br><span class="line">  Reduction reduction = PropagateDeadControl(node);</span><br><span class="line">  <span class="comment">//如果node的control节点为dead则返回replace（control）</span></span><br><span class="line">  <span class="keyword">if</span> (reduction.Changed()) <span class="keyword">return</span> reduction;</span><br><span class="line">  Node* effect = NodeProperties::GetEffectInput(node, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">//如果node的effect节点为dead或unreachable则返回replace（effect）</span></span><br><span class="line">  <span class="keyword">if</span> (effect-&gt;opcode() == IrOpcode::kDead) &#123;</span><br><span class="line">    <span class="keyword">return</span> Replace(effect);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (effect-&gt;opcode() == IrOpcode::kUnreachable) &#123;</span><br><span class="line">    <span class="keyword">return</span> Replace(effect);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> NoChange();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReducePhi：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Reduction DeadCodeElimination::ReducePhi(Node* node) &#123;</span><br><span class="line">  DCHECK_EQ(IrOpcode::kPhi, node-&gt;opcode());</span><br><span class="line">  <span class="comment">//跟上面函数一样为dead返回replace</span></span><br><span class="line">  Reduction reduction = PropagateDeadControl(node);</span><br><span class="line">  <span class="keyword">if</span> (reduction.Changed()) <span class="keyword">return</span> reduction;</span><br><span class="line">  <span class="comment">//机器码表示（操作码），获取该node的Phi表示操作码</span></span><br><span class="line">  <span class="comment">//enum class MachineRepresentation : uint8_t &#123;</span></span><br><span class="line">  <span class="comment">//  kNone,</span></span><br><span class="line">  <span class="comment">//  kBit,</span></span><br><span class="line">  <span class="comment">//  kWord8,</span></span><br><span class="line">  <span class="comment">//  kWord16,</span></span><br><span class="line">  <span class="comment">//  kWord32,</span></span><br><span class="line">  <span class="comment">//  kWord64,</span></span><br><span class="line">  <span class="comment">//  kTaggedSigned,</span></span><br><span class="line">  <span class="comment">//  kTaggedPointer,</span></span><br><span class="line">  <span class="comment">//  kTagged,</span></span><br><span class="line">  <span class="comment">//  kCompressedPointer,</span></span><br><span class="line">  <span class="comment">//  kCompressed,</span></span><br><span class="line">  <span class="comment">//  // FP representations must be last, and in order of increasing size.</span></span><br><span class="line">  <span class="comment">//  kFloat32,</span></span><br><span class="line">  <span class="comment">//  kFloat64,</span></span><br><span class="line">  <span class="comment">//  kSimd128,</span></span><br><span class="line">  <span class="comment">//  kFirstFPRepresentation = kFloat32,</span></span><br><span class="line">  <span class="comment">//  kLastRepresentation = kSimd128</span></span><br><span class="line">  <span class="comment">//&#125;;</span></span><br><span class="line">  MachineRepresentation rep = PhiRepresentationOf(node-&gt;op());</span><br><span class="line">  <span class="comment">//如果为None类型或者字节没有type类型，则返回deadvalue</span></span><br><span class="line">  <span class="keyword">if</span> (rep == MachineRepresentation::kNone ||</span><br><span class="line">      NodeProperties::GetTypeOrAny(node).IsNone()) &#123;</span><br><span class="line">    <span class="keyword">return</span> Replace(DeadValue(node, rep));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> input_count = node-&gt;op()-&gt;ValueInputCount();</span><br><span class="line">  <span class="comment">//循环遍历node的input节点</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input_count; ++i) &#123;</span><br><span class="line">    Node* input = NodeProperties::GetValueInput(node, i);</span><br><span class="line">    <span class="comment">//如果input的opcode为deadvalue且deadvalue表示返回的机器码和Phi表示返回的机器码不同</span></span><br><span class="line">    <span class="comment">//则用deadvalue替换node节点上的index为i的input节点</span></span><br><span class="line">    <span class="keyword">if</span> (input-&gt;opcode() == IrOpcode::kDeadValue &amp;&amp;</span><br><span class="line">        DeadValueRepresentationOf(input-&gt;op()) != rep) &#123;</span><br><span class="line">      NodeProperties::ReplaceValueInput(node, DeadValue(input, rep), i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> NoChange();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面的匆匆瞥几眼就过了。。</p>
<p>再看后面的大reduce：</p>
<h4 id="JSCreateLowering"><a href="#JSCreateLowering" class="headerlink" title="JSCreateLowering:"></a>JSCreateLowering:</h4><p>对应的case有（kJSCreate、kJSCreateArguments、kJSCreateArray、kJSCreateArrayIterator、kJSCreateAsyncFunctionObject、kJSCreateBoundFunction、kJSCreateClosure、kJSCreateCollectionIterator、kJSCreateIterResultObject、kJSCreateStringIterator、kJSCreateKeyValueArray…太多了，不过看名字就能知道是作用在各种create opcode里面的）</p>
<p>重点关注这几个（kJSCreate、kJSCreateArguments、kJSCreateArray、kJSCreateBoundFunction、kJSCreateObject）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">Reduction JSCreateLowering::Reduce(Node* node) &#123;</span><br><span class="line">  DisallowHeapAccess disallow_heap_access;</span><br><span class="line">  <span class="keyword">switch</span> (node-&gt;opcode()) &#123;</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kJSCreate:</span><br><span class="line">      <span class="keyword">return</span> ReduceJSCreate(node);</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kJSCreateArguments:</span><br><span class="line">      <span class="keyword">return</span> ReduceJSCreateArguments(node);</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kJSCreateArray:</span><br><span class="line">      <span class="keyword">return</span> ReduceJSCreateArray(node);</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kJSCreateArrayIterator:</span><br><span class="line">      <span class="keyword">return</span> ReduceJSCreateArrayIterator(node);</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kJSCreateAsyncFunctionObject:</span><br><span class="line">      <span class="keyword">return</span> ReduceJSCreateAsyncFunctionObject(node);</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kJSCreateBoundFunction:</span><br><span class="line">      <span class="keyword">return</span> ReduceJSCreateBoundFunction(node);</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kJSCreateClosure:</span><br><span class="line">      <span class="keyword">return</span> ReduceJSCreateClosure(node);</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kJSCreateCollectionIterator:</span><br><span class="line">      <span class="keyword">return</span> ReduceJSCreateCollectionIterator(node);</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kJSCreateIterResultObject:</span><br><span class="line">      <span class="keyword">return</span> ReduceJSCreateIterResultObject(node);</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kJSCreateStringIterator:</span><br><span class="line">      <span class="keyword">return</span> ReduceJSCreateStringIterator(node);</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kJSCreateKeyValueArray:</span><br><span class="line">      <span class="keyword">return</span> ReduceJSCreateKeyValueArray(node);</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kJSCreatePromise:</span><br><span class="line">      <span class="keyword">return</span> ReduceJSCreatePromise(node);</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kJSCreateLiteralArray:</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kJSCreateLiteralObject:</span><br><span class="line">      <span class="keyword">return</span> ReduceJSCreateLiteralArrayOrObject(node);</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kJSCreateLiteralRegExp:</span><br><span class="line">      <span class="keyword">return</span> ReduceJSCreateLiteralRegExp(node);</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kJSGetTemplateObject:</span><br><span class="line">      <span class="keyword">return</span> ReduceJSGetTemplateObject(node);</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kJSCreateEmptyLiteralArray:</span><br><span class="line">      <span class="keyword">return</span> ReduceJSCreateEmptyLiteralArray(node);</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kJSCreateEmptyLiteralObject:</span><br><span class="line">      <span class="keyword">return</span> ReduceJSCreateEmptyLiteralObject(node);</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kJSCreateFunctionContext:</span><br><span class="line">      <span class="keyword">return</span> ReduceJSCreateFunctionContext(node);</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kJSCreateWithContext:</span><br><span class="line">      <span class="keyword">return</span> ReduceJSCreateWithContext(node);</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kJSCreateCatchContext:</span><br><span class="line">      <span class="keyword">return</span> ReduceJSCreateCatchContext(node);</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kJSCreateBlockContext:</span><br><span class="line">      <span class="keyword">return</span> ReduceJSCreateBlockContext(node);</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kJSCreateGeneratorObject:</span><br><span class="line">      <span class="keyword">return</span> ReduceJSCreateGeneratorObject(node);</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kJSCreateObject:</span><br><span class="line">      <span class="keyword">return</span> ReduceJSCreateObject(node);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> NoChange();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>放到后面再写详细的吧…</p>
<p>完。</p>

    
  </div>

  
      <div class="git"></div>
  

</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持v1nke</div>
        <ul>
        
          <li class="item">
            <span>微信扫一扫</span>
            <img src="/images/qr-wechat.jpeg" alt="">
          </li>
        
          <li class="item">
            <span>支付宝扫一扫</span>
            <img src="/images/qr-wechat.jpeg" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2019/09/17/v8-trick/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2021/01/22/QEMU-USB-CVE-2020-14364漏洞分析/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
