<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Linux Kernel-CVE-2021-22555漏洞分析 | V1NKe的心情垃圾桶</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Kernel," />
  

  <meta name="description" content="Linux Kernel漏洞分析">
<meta name="keywords" content="Linux Kernel">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux Kernel-CVE-2021-22555漏洞分析">
<meta property="og:url" content="http://yoursite.com/2021/09/15/CVE-2021-22555漏洞分析/index.html">
<meta property="og:site_name" content="V1NKe的心情垃圾桶">
<meta property="og:description" content="Linux Kernel漏洞分析">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/CVE-2021-22555漏洞分析/compat_target交叉引用.png">
<meta property="og:image" content="http://yoursite.com/CVE-2021-22555漏洞分析/compat_do_replace.png">
<meta property="og:image" content="http://yoursite.com/CVE-2021-22555漏洞分析/xt_entry_foreach.png">
<meta property="og:image" content="http://yoursite.com/CVE-2021-22555漏洞分析/entry_size_and_hooks.png">
<meta property="og:image" content="http://yoursite.com/CVE-2021-22555漏洞分析/变化前后.png">
<meta property="og:image" content="http://yoursite.com/CVE-2021-22555漏洞分析/堆块伪造图.png">
<meta property="og:updated_time" content="2022-01-09T15:10:30.093Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux Kernel-CVE-2021-22555漏洞分析">
<meta name="twitter:description" content="Linux Kernel漏洞分析">
<meta name="twitter:image" content="http://yoursite.com/CVE-2021-22555漏洞分析/compat_target交叉引用.png">

  

  
    <link rel="icon" href="/haimian.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-TL-DR"><span class="toc-text">0x01 TL;DR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-Debug-Environment"><span class="toc-text">0x02 Debug Environment</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-Root-Case"><span class="toc-text">0x03 Root Case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x04-Exploit"><span class="toc-text">0x04 Exploit</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-CVE-2021-22555漏洞分析" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Linux Kernel-CVE-2021-22555漏洞分析</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2021.09.15</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>V1NKe</span>
        </span>
      

      


      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <h2 id="0x01-TL-DR"><a href="#0x01-TL-DR" class="headerlink" title="0x01 TL;DR"></a>0x01 TL;DR</h2><p>该漏洞是近期被大众熟知的经典溢出漏洞，影响范围还是比较广的。其实该漏洞早在2020年8月就被<a href="https://groups.google.com/g/syzkaller-bugs/c/mjawHSWqr-c/m/82p-sdrfBQAJ" target="_blank" rel="noopener">syzbot</a>发现了，但是并没有人去讨论。该漏洞只有几个字节的溢出，而且固定溢出字节是<code>\x00</code>，那么对于要写利用来说，难度是成倍的提升了。不管是漏洞成因和漏洞利用来说，该漏洞是很值得一看的。</p>
<h2 id="0x02-Debug-Environment"><a href="#0x02-Debug-Environment" class="headerlink" title="0x02 Debug Environment"></a>0x02 Debug Environment</h2><p>这里环境搭建我采取的是自己编译了一版<code>Ubuntu</code>的内核，并用了<code>syzkaller</code>中<code>debootstrap</code>制作系统文件镜像的脚本，最后利用<code>QEMU</code>模拟硬件启动内核。</p>
<p>QEMU：6.1.0</p>
<p>Kernel：5.8.1</p>
<p>Filesystem: <a href="https://raw.githubusercontent.com/google/syzkaller/master/tools/create-image.sh" target="_blank" rel="noopener">debootstrap</a></p>
<h2 id="0x03-Root-Case"><a href="#0x03-Root-Case" class="headerlink" title="0x03 Root Case"></a>0x03 Root Case</h2><p>漏洞代码在<code>net/netfilter/x_tables.c:xt_compat_target_from_user</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xt_compat_target_from_user</span><span class="params">(struct xt_entry_target *t, <span class="keyword">void</span> **dstptr,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">unsigned</span> <span class="keyword">int</span> *size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">xt_target</span> *<span class="title">target</span> = <span class="title">t</span>-&gt;<span class="title">u</span>.<span class="title">kernel</span>.<span class="title">target</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">compat_xt_entry_target</span> *<span class="title">ct</span> = (<span class="title">struct</span> <span class="title">compat_xt_entry_target</span> *)<span class="title">t</span>;</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	t = *dstptr;</span><br><span class="line">	<span class="built_in">memcpy</span>(t, ct, <span class="keyword">sizeof</span>(*ct));</span><br><span class="line"></span><br><span class="line">	pad = XT_ALIGN(target-&gt;targetsize) - target-&gt;targetsize;</span><br><span class="line">	<span class="keyword">if</span> (pad &gt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">memset</span>(t-&gt;data + target-&gt;targetsize, <span class="number">0</span>, pad); <span class="comment">// overflow!!!</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是光从这一块代码是看不出什么的，也并不能看出这里的<code>memset</code>会导致溢出，因此我们需要从代码根源出发。</p>
<p>往前找该函数的交叉引用，再结合<code>socket</code>内核源码的一些审计，可以得到这样一条链（为了防止变成源码分析的文章就不过多叙述这一块了）：</p>
<p><img src="/CVE-2021-22555漏洞分析/compat_target交叉引用.png" alt="compat_target交叉引用"></p>
<p>理清楚代码执行流程之后，就该思考如何构造<code>POC</code>才能到达目标漏洞点了，其中，理解代码的含义也很重要。</p>
<p>这部分我就专挑编写<code>POC</code>需要注意的一些点来说，首先看<code>compat_do_ipt_set_ctl</code>这块函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compat_nf_sockopt</span><span class="params">(struct sock *sk, <span class="keyword">u_int8_t</span> pf, <span class="keyword">int</span> val,</span></span></span><br><span class="line"><span class="function"><span class="params">			     <span class="keyword">char</span> __user *opt, <span class="keyword">int</span> *len, <span class="keyword">int</span> get)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nf_sockopt_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	ops = nf_sockopt_find(sk, pf, val, get); <span class="comment">// 从全局链表nf_sockopts中获取相应的ops回调函数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (get) &#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (ops-&gt;compat_set)</span><br><span class="line">			ret = ops-&gt;compat_set(sk, val, opt, *len);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	module_put(ops-&gt;owner);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中的全局链表<code>nf_sockopts</code>在<code>net/ipv4/netfilter/ip_tables.c</code>文件中会被引用到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_sockopt_ops</span> <span class="title">ipt_sockopts</span> = &#123;</span></span><br><span class="line">	.pf		= PF_INET,</span><br><span class="line">#ifdef CONFIG_COMPAT</span><br><span class="line">	.compat_set	= compat_do_ipt_set_ctl,</span><br><span class="line">#endif</span><br><span class="line">	.owner		= THIS_MODULE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">xt_match</span> <span class="title">ipt_builtin_mt</span>[] __<span class="title">read_mostly</span> = &#123;</span></span><br><span class="line">	&#123;</span><br><span class="line">		.name       = <span class="string">"icmp"</span>,</span><br><span class="line">		.matchsize  = <span class="keyword">sizeof</span>(struct ipt_icmp),</span><br><span class="line">		.proto      = IPPROTO_ICMP,</span><br><span class="line">		.family     = NFPROTO_IPV4,</span><br><span class="line">		.me	    = THIS_MODULE,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">xt_target</span> <span class="title">ipt_builtin_tg</span>[] __<span class="title">read_mostly</span> = &#123;</span></span><br><span class="line">	&#123;</span><br><span class="line">		.name             = XT_STANDARD_TARGET, <span class="comment">// ""</span></span><br><span class="line">		.targetsize       = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">		.family           = NFPROTO_IPV4,</span><br><span class="line">		.compatsize       = <span class="keyword">sizeof</span>(<span class="keyword">compat_int_t</span>),</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.name             = XT_ERROR_TARGET, <span class="comment">// "ERROR"</span></span><br><span class="line">		.target           = ipt_error,</span><br><span class="line">		.targetsize       = XT_FUNCTION_MAXNAMELEN,</span><br><span class="line">		.family           = NFPROTO_IPV4,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">ip_tables_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将ip_tables_net_ops网络协议子系统添加到全局链表pernet_list的网络命名空间中去，并且执行初始化。</span></span><br><span class="line">	ret = register_pernet_subsys(&amp;ip_tables_net_ops);</span><br><span class="line">	<span class="comment">// 将ipt_builtin_tg中的内容插入全局结构体指针xt(struct xt_af)中的target属性（也是个链表）</span></span><br><span class="line">	ret = xt_register_targets(ipt_builtin_tg, ARRAY_SIZE(ipt_builtin_tg));</span><br><span class="line">	<span class="comment">// 同上</span></span><br><span class="line">	ret = xt_register_matches(ipt_builtin_mt, ARRAY_SIZE(ipt_builtin_mt));</span><br><span class="line">	<span class="comment">// 详细内容在后面</span></span><br><span class="line">	ret = nf_register_sockopt(&amp;ipt_sockopts);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">xt_af</span> *<span class="title">xt</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xt_register_target</span><span class="params">(struct xt_target *target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">u_int8_t</span> af = target-&gt;family;</span><br><span class="line">	list_add(&amp;target-&gt;<span class="built_in">list</span>, &amp;xt[af].target); <span class="comment">// 插入链表</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nf_register_sockopt</span><span class="params">(struct nf_sockopt_ops *reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nf_sockopt_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">	list_add(&amp;reg-&gt;<span class="built_in">list</span>, &amp;nf_sockopts); <span class="comment">// ipt_sockopts被插入全局链表nf_sockopts</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(ip_tables_init); <span class="comment">// 以一个内核模块的形式存在，因此调试时需要lsmod查看一下是否加载了该模块</span></span><br></pre></td></tr></table></figure>
<p>审计完上面部分的代码再回到前面提到的函数<code>compat_nf_sockopt</code>中去，可以得出<code>(1)</code>处后续的执行函数为<code>compat_do_ipt_set_ctl</code>。这里提一嘴，由于该文件<code>ip_tables.c</code>是以内核模块形式存在的，因此我们在调试的时候在内核中需要查看一下该模块是否加载，否则会遇到编写<code>POC</code>时出错无法执行的情况。</p>
<p>继续往后看<code>compat_do_ipt_set_ctl</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">compat_do_ipt_set_ctl(struct sock *sk,	<span class="keyword">int</span> cmd, <span class="keyword">void</span> __user *user,</span><br><span class="line">		      <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ns_capable(sock_net(sk)-&gt;user_ns, CAP_NET_ADMIN)) <span class="comment">// (1) sock_net(sk) = current-&gt;nsproxy-&gt;net_ns</span></span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="keyword">case</span> IPT_SO_SET_REPLACE:</span><br><span class="line">		ret = compat_do_replace(sock_net(sk), user, len); <span class="comment">// (2)</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先来看<code>(2)</code>处，因为这个函数是通往漏洞函数的必经之路，因此<code>cmd</code>必须设为<code>IPT_SO_SET_REPLACE</code>，也就是说，编写<code>POC</code>调用<code>int setsockopt(int sockfd, int level, int optname,const void *optval, socklen_t optlen);</code>函数时，<code>optname</code>参数必须设置为<code>IPT_SO_SET_REPLACE</code>。</p>
<p>再看<code>(1)</code>处，此处是比较关键的一个地方。这部分的作用是检测该网络命名空间是否拥有<code>CAP_NET_ADMIN</code>权限，也就是是否拥有<code>ROOT</code>权限。很显然，该漏洞要作为一个提权漏洞是绝对不会拥有<code>ROOT</code>权限的，那么该怎么办？<code>Bypass</code>的办法就是新开辟一个<code>user</code>空间，使得拥有<code>ROOT</code>权限，再在这个基础之上新开辟一个<code>net</code>网络命名空间。在<code>POC</code>中的体现就是（<code>CLONE_NEWUSER</code>是不需要<code>ROOT</code>权限的）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unshare(CLONE_NEWUSER);</span><br><span class="line">unshare(CLONE_NEWNET);</span><br></pre></td></tr></table></figure>
<p>所以这个漏洞也是可以拿来容器逃逸的。</p>
<p>再往后看<code>compat_do_replace</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">compat_ipt_replace</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span>			name[XT_TABLE_MAXNAMELEN];</span><br><span class="line">	u32			valid_hooks;</span><br><span class="line">	u32			num_entries;</span><br><span class="line">	u32			size;</span><br><span class="line">	u32			hook_entry[NF_INET_NUMHOOKS];</span><br><span class="line">	u32			underflow[NF_INET_NUMHOOKS];</span><br><span class="line">	u32			num_counters;</span><br><span class="line">	<span class="keyword">compat_uptr_t</span>		counters;	<span class="comment">/* struct xt_counters * */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">compat_ipt_entry</span>	<span class="title">entries</span>[0];</span></span><br><span class="line">&#125;; <span class="comment">// 0x70 size</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xt_table_info</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> size;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> number;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> initial_entries;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> hook_entry[NF_INET_NUMHOOKS];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> underflow[NF_INET_NUMHOOKS];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> stacksize;</span><br><span class="line">	<span class="keyword">void</span> ***jumpstack;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> entries[<span class="number">0</span>] __aligned(<span class="number">8</span>);</span><br><span class="line">&#125;; <span class="comment">// 0x40 size</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">compat_do_replace(struct net *net, <span class="keyword">void</span> __user *user, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">compat_ipt_replace</span> <span class="title">tmp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xt_table_info</span> *<span class="title">newinfo</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *loc_cpu_entry;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipt_entry</span> *<span class="title">iter</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(&amp;tmp, user, <span class="keyword">sizeof</span>(tmp)) != <span class="number">0</span>) <span class="comment">// copy用户空间的数据到内核态</span></span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">	newinfo = xt_alloc_table_info(tmp.size);</span><br><span class="line"></span><br><span class="line">	loc_cpu_entry = newinfo-&gt;entries;</span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(loc_cpu_entry, user + <span class="keyword">sizeof</span>(tmp),</span><br><span class="line">			   tmp.size) != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = translate_compat_table(net, &amp;newinfo, &amp;loc_cpu_entry, &amp;tmp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct xt_table_info *<span class="title">xt_alloc_table_info</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xt_table_info</span> *<span class="title">info</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="keyword">size_t</span> sz = <span class="keyword">sizeof</span>(*info) + size;</span><br><span class="line"></span><br><span class="line">	info = kvmalloc(sz, GFP_KERNEL_ACCOUNT);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(info, <span class="number">0</span>, <span class="keyword">sizeof</span>(*info));</span><br><span class="line">	info-&gt;size = size;</span><br><span class="line">	<span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就需要用到<code>setsockopt</code>函数里的<code>optval</code>和<code>optlen</code>参数了。首先会填充<code>compat_ipt_replace</code>结构体，其次申请一个<code>xt_table_info</code>结构体堆块（动态<code>size</code>），堆块大小还受传入的<code>compat_ipt_replace.size</code>影响。然后又将用户态剩余的数据填充<code>xt_table_info</code>后半块动态<code>size</code>的区域。用图的形式如下所示：</p>
<p><img src="/CVE-2021-22555漏洞分析/compat_do_replace.png" alt="compat_do_replace"></p>
<p>继续往后看<code>translate_compat_table</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">compat_ipt_entry</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipt_ip</span> <span class="title">ip</span>;</span></span><br><span class="line">	<span class="keyword">compat_uint_t</span> nfcache;</span><br><span class="line">	__u16 target_offset;</span><br><span class="line">	__u16 next_offset;</span><br><span class="line">	<span class="keyword">compat_uint_t</span> comefrom;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">compat_xt_counters</span> <span class="title">counters</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> elems[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">translate_compat_table(struct net *net,</span><br><span class="line">		       struct xt_table_info **pinfo,</span><br><span class="line">		       <span class="keyword">void</span> **pentry0,</span><br><span class="line">		       <span class="keyword">const</span> struct compat_ipt_replace *compatr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xt_table_info</span> *<span class="title">newinfo</span>, *<span class="title">info</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *pos, *entry0, *entry1;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">compat_ipt_entry</span> *<span class="title">iter0</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipt_replace</span> <span class="title">repl</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> size;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	info = *pinfo;</span><br><span class="line">	entry0 = *pentry0; <span class="comment">// entry0指向上面提到的”compat_ipt_replace.size“那一块区域</span></span><br><span class="line">	size = compatr-&gt;size; <span class="comment">// 即”compat_ipt_replace.size“</span></span><br><span class="line">	info-&gt;number = compatr-&gt;num_entries;</span><br><span class="line"></span><br><span class="line">	xt_entry_foreach(iter0, entry0, compatr-&gt;size) &#123;</span><br><span class="line">		ret = check_compat_entry_size_and_hooks(iter0, info, &amp;size,</span><br><span class="line">							entry0,</span><br><span class="line">							entry0 + compatr-&gt;size); <span class="comment">// (3)</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	ret = -ENOMEM;</span><br><span class="line">	newinfo = xt_alloc_table_info(size); <span class="comment">// (4)</span></span><br><span class="line"></span><br><span class="line">	entry1 = newinfo-&gt;entries;</span><br><span class="line">	pos = entry1;</span><br><span class="line">	size = compatr-&gt;size;</span><br><span class="line">	xt_entry_foreach(iter0, entry0, compatr-&gt;size)</span><br><span class="line">		compat_copy_entry_from_user(iter0, &amp;pos, &amp;size,</span><br><span class="line">					    newinfo, entry1); <span class="comment">// (5)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>(3)</code>中<code>xt_entry_foreach</code>的含义是将<code>entry0</code>区域以<code>compat_ipt_entry</code>结构体形式遍历，即（仅代表单独语句的情景下）：</p>
<p><img src="/CVE-2021-22555漏洞分析/xt_entry_foreach.png" alt="xt_entry_foreach"></p>
<p>而<code>check_compat_entry_size_and_hooks</code>函数中的信息量就比较大了，需要读者仔细耐心的阅读相关代码。我这里就在阅读完该函数代码的基础下简单用图来说明一下：</p>
<p><img src="/CVE-2021-22555漏洞分析/entry_size_and_hooks.png" alt="entry_size_and_hooks"></p>
<p>该函数的作用就是先校验用户传入的数据结构是否完整和安全（用户传入的数据结构格式如上图），其次将数据结构中的<code>xt_entry_target</code>以及<code>xt_entry_match</code>两个结构体，在全局变量<code>xt</code>（在文章最开始有提到）中的<code>target</code>和<code>match</code>两个链表中的结构体找出相对应的，最终获取相应的<code>xt_target</code>和<code>xt_match</code>变量。获取该变量后会计算<code>offset</code>，该<code>offset</code>就是该函数最重要的一部分，也是后续漏洞成因重要的一部分。举个栗子，假设最终获取了以下这个<code>xt_match</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">xt_match</span> = &#123;</span></span><br><span class="line">		.name       = <span class="string">"icmp"</span>,</span><br><span class="line">		.matchsize  = <span class="keyword">sizeof</span>(struct ipt_icmp),</span><br><span class="line">		.proto      = IPPROTO_ICMP,</span><br><span class="line">		.family     = NFPROTO_IPV4,</span><br><span class="line">		.me	    = THIS_MODULE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipt_icmp</span> &#123;</span></span><br><span class="line">	__u8 type;				<span class="comment">/* type to match */</span></span><br><span class="line">	__u8 code[<span class="number">2</span>];				<span class="comment">/* range of code */</span></span><br><span class="line">	__u8 invflags;				<span class="comment">/* Inverse flags */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在<code>check_compat_entry_size_and_hooks</code>函数中有这么一个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xt_compat_match_offset</span><span class="params">(<span class="keyword">const</span> struct xt_match *match)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">u_int16_t</span> csize = match-&gt;compatsize ? : match-&gt;matchsize;</span><br><span class="line">	<span class="keyword">return</span> XT_ALIGN(match-&gt;matchsize) - COMPAT_XT_ALIGN(csize); <span class="comment">// 8-4 = 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终会返回<code>4</code>字节，也就是差<code>4</code>字节对齐，<code>xt_target</code>也一样。</p>
<p>再继续看如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">check_compat_entry_size_and_hooks(struct compat_ipt_entry *e,</span><br><span class="line">				  struct xt_table_info *newinfo,</span><br><span class="line">				  <span class="keyword">unsigned</span> <span class="keyword">int</span> *size,</span><br><span class="line">				  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *base,</span><br><span class="line">				  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *limit)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xt_target</span> *<span class="title">target</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret, off;</span><br><span class="line"></span><br><span class="line">	off = <span class="keyword">sizeof</span>(struct ipt_entry) - <span class="keyword">sizeof</span>(struct compat_ipt_entry);</span><br><span class="line"></span><br><span class="line">	off += xt_compat_target_offset(target); <span class="comment">// 计算对齐的offset</span></span><br><span class="line">	*size += off; <span class="comment">// (6)</span></span><br><span class="line">  </span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码<code>(6)</code>处可以看到最终这个<code>offset</code>值是会增加在<code>compat_ipt_replace.size</code>上的。</p>
<p>再回到前面看代码<code>(4)</code>，增加过后的<code>size</code>会被传入<code>xt_alloc_table_info</code>申请一块新的内存空间。也就是说，在经过<code>check</code>和计算<code>offset</code>之后，会重新申请一块内存空间，用来存放增加了<code>offset</code>之后的数据结构内容。</p>
<p>往后看代码<code>(5)</code>的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">compat_copy_entry_from_user(struct compat_ipt_entry *e, <span class="keyword">void</span> **dstptr,</span><br><span class="line">			    <span class="keyword">unsigned</span> <span class="keyword">int</span> *size,</span><br><span class="line">			    struct xt_table_info *newinfo, <span class="keyword">unsigned</span> <span class="keyword">char</span> *base)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xt_entry_target</span> *<span class="title">t</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipt_entry</span> *<span class="title">de</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> origsize;</span><br><span class="line">	<span class="keyword">int</span> h;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xt_entry_match</span> *<span class="title">ematch</span>;</span></span><br><span class="line"></span><br><span class="line">	origsize = *size;</span><br><span class="line">	de = *dstptr;</span><br><span class="line">	<span class="built_in">memcpy</span>(de, e, <span class="keyword">sizeof</span>(struct ipt_entry)); <span class="comment">// copy旧内容到新空间</span></span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;de-&gt;counters, &amp;e-&gt;counters, <span class="keyword">sizeof</span>(e-&gt;counters));</span><br><span class="line"></span><br><span class="line">	*dstptr += <span class="keyword">sizeof</span>(struct ipt_entry);</span><br><span class="line">  </span><br><span class="line">	xt_ematch_foreach(ematch, e)</span><br><span class="line">		xt_compat_match_from_user(ematch, dstptr, size); <span class="comment">// 循环处理match部分</span></span><br><span class="line"></span><br><span class="line">	de-&gt;target_offset = e-&gt;target_offset - (origsize - *size); <span class="comment">// (7)</span></span><br><span class="line">	t = compat_ipt_get_target(e);</span><br><span class="line">	xt_compat_target_from_user(t, dstptr, size); <span class="comment">// 处理target部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xt_compat_target_from_user</span><span class="params">(struct xt_entry_target *t, <span class="keyword">void</span> **dstptr,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">unsigned</span> <span class="keyword">int</span> *size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">xt_target</span> *<span class="title">target</span> = <span class="title">t</span>-&gt;<span class="title">u</span>.<span class="title">kernel</span>.<span class="title">target</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">compat_xt_entry_target</span> *<span class="title">ct</span> = (<span class="title">struct</span> <span class="title">compat_xt_entry_target</span> *)<span class="title">t</span>;</span></span><br><span class="line">	<span class="keyword">int</span> pad, off = xt_compat_target_offset(target);</span><br><span class="line">	<span class="keyword">u_int16_t</span> tsize = ct-&gt;u.user.target_size;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="keyword">sizeof</span>(t-&gt;u.user.name)];</span><br><span class="line"></span><br><span class="line">	t = *dstptr;</span><br><span class="line">	<span class="built_in">memcpy</span>(t, ct, <span class="keyword">sizeof</span>(*ct));</span><br><span class="line">	<span class="keyword">if</span> (target-&gt;compat_from_user)</span><br><span class="line">		target-&gt;compat_from_user(t-&gt;data, ct-&gt;data);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">memcpy</span>(t-&gt;data, ct-&gt;data, tsize - <span class="keyword">sizeof</span>(*ct));</span><br><span class="line">	pad = XT_ALIGN(target-&gt;targetsize) - target-&gt;targetsize; <span class="comment">// (8)</span></span><br><span class="line">	<span class="keyword">if</span> (pad &gt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">memset</span>(t-&gt;data + target-&gt;targetsize, <span class="number">0</span>, pad); <span class="comment">// (9) overflow!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设前面所得的<code>xt_match</code>和<code>xt_target</code>分别为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">xt_match</span> = &#123;</span></span><br><span class="line">		.name       = <span class="string">"icmp"</span>,</span><br><span class="line">		.matchsize  = <span class="keyword">sizeof</span>(struct ipt_icmp), <span class="comment">// 4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">xt_target</span> = &#123;</span></span><br><span class="line">		.name       = <span class="string">"NFQUEUE"</span>,</span><br><span class="line">		.targetsize  = <span class="number">6</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>(7)</code>处<code>*size</code>的值会因为<code>xt_match</code>计算出的<code>offset</code>增加<code>4</code>字节，因此最终<code>de-&gt;target_offset</code>的结果会变为<code>4</code> 。相当于在原先堆块的基础上补上了缺少的这一小部分字节。此时的<code>xt_target-&gt;targetsize</code>为<code>6</code>，那么前期<code>(6)</code>处计算出的<code>off</code>总数就是<code>4</code>（包括<code>xt_match</code>和<code>xt_target</code>，<code>xt_target</code>的为<code>0</code>，也就是说后续需要补上<code>4</code>个字节的空间，前面<code>(7)</code>处的<code>xt_match</code>已经补上<code>4</code>字节了）。<code>(8)</code>处错误的计算（计算结果为<code>8-6=2</code> ），导致<code>(9)</code>就变为了<code>memset(t-&gt;data+6, 0, 2);</code>，<code>t-&gt;data</code>之外的空间并没有拓展（因为前面计算<code>xt_target</code>的<code>offset</code>时候为<code>0</code>，不需要补字节），因此就导致<strong>溢出</strong>了八字节，但是溢出能够写的个数只有两字节。以下示意图为增加<code>offset</code>剩余对齐部分的前后过程。</p>
<p><img src="/CVE-2021-22555漏洞分析/变化前后.png" alt="变化前后"></p>
<p>这时候再回过头看文章开头（或<code>(9)</code>处）的漏洞代码，就能够明白为什么会溢出了，当然实际上<code>xt_target</code>的值也不止为<code>6</code>（<code>xt_match</code>同理），相应的溢出字节数也会不一样，需要根据实际情况来对应。</p>
<p>这里需要注意的是内核中的内存申请和用户态的<code>malloc</code>是不一样的。本例中这块<code>xt_table_info</code>相关的内存空间是由<code>kvmalloc</code>申请的，最终调用的应该是<code>kmalloc</code>，我查了一下申请的<code>size</code>的<a href="http://www.cs.otago.ac.nz/cosc440/labs/lab05.pdf" target="_blank" rel="noopener">规律</a>：</p>
<blockquote>
<p>kmalloc() will return a memory chunk with size of power of 2 that matches or exceeds len and will return NULL upon failure. The maximum size allocatable by kmalloc() is 1024 pages, or 4MB on x86. Generally for requests larger than 64kB, one should use __get_free_page() functions to ensure inter-platform compatibility.</p>
</blockquote>
<p>也就是说申请的<code>size</code>大小按照<code>2</code>的幂次来计算。</p>
<p>那么为了方便后续的漏洞利用，这里我就将<code>xt_table_info</code>这块结构体构造成<code>0x1000</code>大小，使得溢出的字节刚好能够覆盖到下一个申请的结构体上去。</p>
<p>最终构造的堆块情况如下图所示：</p>
<p><img src="/CVE-2021-22555漏洞分析/堆块伪造图.png" alt="堆块伪造图"></p>
<p>以上就完成了<code>PoC</code>部分的构造了。</p>
<h2 id="0x04-Exploit"><a href="#0x04-Exploit" class="headerlink" title="0x04 Exploit"></a>0x04 Exploit</h2>
    
  </div>

  
      <div class="git"></div>
  

</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持v1nke</div>
        <ul>
        
          <li class="item">
            <span>微信扫一扫</span>
            <img src="/images/qr-wechat.jpeg" alt="">
          </li>
        
          <li class="item">
            <span>支付宝扫一扫</span>
            <img src="/images/qr-wechat.jpeg" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2021/07/22/QEMU源码分析 - 协程/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2021/09/15/socket部分源码分析/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
