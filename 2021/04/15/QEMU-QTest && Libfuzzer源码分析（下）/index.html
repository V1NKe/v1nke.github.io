<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>QEMU源码分析 - QTest（下） | V1NKe的心情垃圾桶</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="QEMU," />
  

  <meta name="description" content="QEMU源码分析">
<meta name="keywords" content="QEMU">
<meta property="og:type" content="article">
<meta property="og:title" content="QEMU源码分析 - QTest（下）">
<meta property="og:url" content="http://yoursite.com/2021/04/15/QEMU-QTest && Libfuzzer源码分析（下）/index.html">
<meta property="og:site_name" content="V1NKe的心情垃圾桶">
<meta property="og:description" content="QEMU源码分析">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/QTest源码分析/字节对齐.jpg">
<meta property="og:updated_time" content="2022-01-09T15:02:33.428Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="QEMU源码分析 - QTest（下）">
<meta name="twitter:description" content="QEMU源码分析">
<meta name="twitter:image" content="http://yoursite.com/QTest源码分析/字节对齐.jpg">

  

  
    <link rel="icon" href="/haimian.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#QEMU-QTest-amp-amp-Libfuzzer源码分析（下）"><span class="toc-text">QEMU-QTest &amp;&amp; Libfuzzer源码分析（下）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x01-TL-DR"><span class="toc-text">0x01 TL;DR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x02-generic-fuzz"><span class="toc-text">0x02 generic-fuzz</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x03-Summary"><span class="toc-text">0x03 Summary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x04-Reference"><span class="toc-text">0x04 Reference</span></a></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-QEMU-QTest &amp;&amp; Libfuzzer源码分析（下）" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">QEMU源码分析 - QTest（下）</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2021.04.15</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>V1NKe</span>
        </span>
      

      


      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <h2 id="QEMU-QTest-amp-amp-Libfuzzer源码分析（下）"><a href="#QEMU-QTest-amp-amp-Libfuzzer源码分析（下）" class="headerlink" title="QEMU-QTest &amp;&amp; Libfuzzer源码分析（下）"></a>QEMU-QTest &amp;&amp; Libfuzzer源码分析（下）</h2><h3 id="0x01-TL-DR"><a href="#0x01-TL-DR" class="headerlink" title="0x01 TL;DR"></a>0x01 TL;DR</h3><p>续接上文，开始分析<code>libfuzzer</code>部分的代码。下文的前置知识基本在上文中已经覆盖。</p>
<h3 id="0x02-generic-fuzz"><a href="#0x02-generic-fuzz" class="headerlink" title="0x02 generic-fuzz"></a>0x02 generic-fuzz</h3><p>文件在<code>tests/qtest/fuzz/generic_fuzz.c</code>中，入口函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register_generic_fuzz_targets</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fuzz_add_target(&amp;(FuzzTarget)&#123;</span><br><span class="line">				<span class="comment">//......</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    GString *name;</span><br><span class="line">    <span class="keyword">const</span> generic_fuzz_config *config;</span><br><span class="line">		<span class="comment">//循环添加了好几种已经设置的device，文件在generic_fuzz_configs.h中，包含启动所需的一些command参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">         i &lt; <span class="keyword">sizeof</span>(predefined_configs) / <span class="keyword">sizeof</span>(generic_fuzz_config);</span><br><span class="line">         i++) &#123;</span><br><span class="line">        config = predefined_configs + i;</span><br><span class="line">        name = g_string_new(<span class="string">"generic-fuzz"</span>);</span><br><span class="line">        g_string_append_printf(name, <span class="string">"-%s"</span>, config-&gt;name);</span><br><span class="line">        fuzz_add_target(&amp;(FuzzTarget)&#123;</span><br><span class="line">						<span class="comment">//......</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fuzz_target_init(register_generic_fuzz_targets);</span><br></pre></td></tr></table></figure>
<p>作者没有设置的<code>device</code>就要自己去设置启动<code>command</code>，获取<code>command</code>的主要函数在<code>generic_fuzz_cmdline</code>中。</p>
<p>接来下看<code>fuzz</code>的前期准备<code>generic_pre_fuzz</code>函数（只截取部分重要代码）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generic_pre_fuzz</span><span class="params">(QTestState *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!getenv(<span class="string">"QEMU_FUZZ_OBJECTS"</span>)) &#123;</span><br><span class="line">        usage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    qts_global = s; <span class="comment">//设定全局QTestState</span></span><br><span class="line"></span><br><span class="line">    dma_regions = g_array_new(<span class="literal">false</span>, <span class="literal">false</span>, <span class="keyword">sizeof</span>(address_range));</span><br><span class="line">    dma_patterns = g_array_new(<span class="literal">false</span>, <span class="literal">false</span>, <span class="keyword">sizeof</span>(pattern));</span><br><span class="line"></span><br><span class="line">    fuzzable_memoryregions = g_hash_table_new(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    fuzzable_pci_devices   = g_ptr_array_new();</span><br><span class="line"></span><br><span class="line">    result = g_strsplit(getenv(<span class="string">"QEMU_FUZZ_OBJECTS"</span>), <span class="string">" "</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; result[i] != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Matching objects by name %s\n"</span>, result[i]);</span><br><span class="line">        object_child_foreach_recursive(qdev_get_machine(),   <span class="comment">// ！！！</span></span><br><span class="line">                                    locate_fuzz_objects,</span><br><span class="line">                                    result[i]);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看标感叹号那块代码，经调试，<code>qdev-get-machine()</code>这块得到的<code>machine</code>对象为<code>pc-q35-6.0-machine</code>，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x *dev</span><br><span class="line">$<span class="number">1</span> = &#123;</span><br><span class="line">  class = <span class="number">0x614000005240</span>,</span><br><span class="line">  <span class="built_in">free</span> = <span class="number">0x7ffff6ccfba0</span>,</span><br><span class="line">  properties = <span class="number">0x61d000098f00</span>,</span><br><span class="line">  ref = <span class="number">0x2</span>,</span><br><span class="line">  parent = <span class="number">0x604000016cd0</span></span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; x/<span class="number">1</span>s dev.class.type.name</span><br><span class="line"><span class="number">0x603000009b20</span>: <span class="string">"pc-q35-6.0-machine"</span></span><br></pre></td></tr></table></figure>
<p>继续看<code>object_child_foreach_recursive</code>这个函数，这个函数比较绕，调用层次也比较多，如果要细说估计都可以成一篇文章了，我就大概理一下思路：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_object_child_foreach</span><span class="params">(Object *obj,</span></span></span><br><span class="line">                                   int (*fn)(Object *child, void *opaque),</span><br><span class="line">                                   <span class="keyword">void</span> *opaque, <span class="keyword">bool</span> recurse)</span><br><span class="line">&#123;</span><br><span class="line">    GHashTableIter iter;</span><br><span class="line">    ObjectProperty *prop;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    g_hash_table_iter_init(&amp;iter, obj-&gt;properties); <span class="comment">//properties为一个GHashTable，初始化递归表</span></span><br><span class="line">    <span class="keyword">while</span> (g_hash_table_iter_next(&amp;iter, <span class="literal">NULL</span>, (gpointer *)&amp;prop)) &#123;<span class="comment">//逐个遍历递归表</span></span><br><span class="line">        <span class="keyword">if</span> (object_property_is_child(prop)) &#123;<span class="comment">//判断遍历到的ObjectProperty-&gt;type是否为child</span></span><br><span class="line">            Object *child = prop-&gt;opaque;    <span class="comment">//取出child object</span></span><br><span class="line"></span><br><span class="line">            ret = fn(child, opaque);         <span class="comment">//执行回调函数</span></span><br><span class="line">            <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;                  <span class="comment">//回调函数返回值不为0才退出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (recurse) &#123;         <span class="comment">//递归执行该函数，也就是递归遍历child</span></span><br><span class="line">                ret = do_object_child_foreach(child, fn, opaque, <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么<code>Object</code>还有<code>child Object</code>？两者是什么关系？搞明白这个才能清楚这个函数的具体含义。</p>
<p>我举个例子，就拿前面我们得到的对象<code>pc-q35-6.0-machine</code>来举例，这个对象类似于一个根节点，定义在<code>pc-q35.c</code>代码文件中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_Q35_MACHINE(v6_0, <span class="string">"pc-q35-6.0"</span>, <span class="literal">NULL</span>,</span><br><span class="line">                   pc_q35_6_0_machine_options);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_Q35_MACHINE(suffix, name, compatfn, optionfn) \</span></span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">void</span> pc_init_#<span class="meta">#suffix(MachineState *machine) \</span></span><br><span class="line">    &#123; \</span><br><span class="line">        pc_q35_init(machine); \</span><br><span class="line">    &#125; \</span><br><span class="line">    DEFINE_PC_MACHINE(suffix, name, pc_init_##suffix, optionfn)</span><br><span class="line"></span><br><span class="line"><span class="comment">// #define TYPE_MACHINE_SUFFIX "-machine"</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_PC_MACHINE(suffix, namestr, initfn, optsfn) \</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> TypeInfo pc_machine_type_#<span class="meta">#suffix = &#123; \</span></span><br><span class="line">        .name       = namestr TYPE_MACHINE_SUFFIX, \</span><br><span class="line">        .parent     = TYPE_PC_MACHINE, \</span><br><span class="line">        .class_init = pc_machine_##suffix##_class_init, \</span><br><span class="line">    &#125;; \</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> pc_machine_init_#<span class="meta">#suffix(void) \</span></span><br><span class="line">    &#123; \</span><br><span class="line">        type_register(&amp;pc_machine_type_##suffix); \</span><br><span class="line">    &#125; \</span><br><span class="line">    type_init(pc_machine_init_##suffix)                   <span class="comment">//跟其他设备的初始化一样</span></span><br></pre></td></tr></table></figure>
<p>再看看<code>pc_q35_init</code>这个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pc_q35_init</span><span class="params">(MachineState *machine)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q35_host = Q35_HOST_DEVICE(qdev_new(TYPE_Q35_HOST_DEVICE)); <span class="comment">//q35-pcihost</span></span><br><span class="line"></span><br><span class="line">    object_property_add_child(qdev_get_machine(), <span class="string">"q35"</span>, OBJECT(q35_host)); <span class="comment">// ！！！(1)</span></span><br><span class="line">  </span><br><span class="line">  	<span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标记<code>1</code>处的函数从名称可以看出是给<code>object</code>的<code>property</code>添加<code>child</code>，那么根据函数定义的参数名可以断定是给<code>qdev_get_machine()</code>所得到的<code>object</code>，也就是<code>pc-q35-6.0-machine</code>新增一个<code>property</code>，命名为<code>q35</code>，子对象为<code>q35-pcihost</code>。也就是在两个对象间新建一个链接关系，类似于链表，并对这个链表命名。简单来说创建的链条如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ObjectProperty *op;</span><br><span class="line"></span><br><span class="line">op-&gt;name = <span class="string">"q35"</span>;</span><br><span class="line">op-&gt;type = <span class="string">"child&lt;q35-pcihost&gt;"</span>;</span><br><span class="line">op-&gt;opaque = OBJECT(q35_host);</span><br></pre></td></tr></table></figure>
<p>当然了，这个“根”对象的<code>child</code>肯定不止这一个。通过对<code>qdev_get_machine()</code>的交叉引用可以发现<code>mc146818rtc.c</code>也是它的<code>child</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtc_realizefn</span><span class="params">(DeviceState *dev, Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="comment">//......</span></span><br><span class="line">  	ISADevice *isadev = ISA_DEVICE(dev);</span><br><span class="line">    RTCState *s = MC146818_RTC(dev);</span><br><span class="line">    object_property_add_tm(OBJECT(s), <span class="string">"date"</span>, rtc_get_date); <span class="comment">//(1)</span></span><br><span class="line">		<span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ISADevice *<span class="title">mc146818_rtc_init</span><span class="params">(ISABus *bus, <span class="keyword">int</span> base_year, qemu_irq intercept_irq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ISADevice *isadev;</span><br><span class="line">		<span class="comment">//......</span></span><br><span class="line">    isadev = isa_new(TYPE_MC146818_RTC);</span><br><span class="line"></span><br><span class="line">    object_property_add_alias(qdev_get_machine(), <span class="string">"rtc-time"</span>, OBJECT(isadev),</span><br><span class="line">                              <span class="string">"date"</span>); <span class="comment">//(2)</span></span><br><span class="line">    <span class="keyword">return</span> isadev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>object_property_add_tm</code>函数创建的<code>property</code>的<code>type</code>类型为<code>struct tm</code>，<code>object_property_add_alias</code>函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ObjectProperty *</span><br><span class="line">object_property_add_alias(Object *obj, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line">                          Object *target_obj, <span class="keyword">const</span> <span class="keyword">char</span> *target_name)</span><br><span class="line">&#123;</span><br><span class="line">    ObjectProperty *op;</span><br><span class="line">    ObjectProperty *target_prop;</span><br><span class="line">  	<span class="comment">//......</span></span><br><span class="line">  	target_prop = object_property_find_err(target_obj, target_name,</span><br><span class="line">                                           &amp;error_abort);</span><br><span class="line">		prop_type = g_strdup(target_prop-&gt;type);</span><br><span class="line">    op = object_property_add(obj, name, prop_type,</span><br><span class="line">                             property_get_alias,</span><br><span class="line">                             property_set_alias,</span><br><span class="line">                             property_release_alias,</span><br><span class="line">                             prop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>object_property_add_alias</code>所设置的<code>type</code>为<code>target_obj</code>中<code>target_name</code>的<code>type</code>，也就是<code>ISADevice</code>对象中名为<code>data</code>的<code>type</code>，为<code>struct tm</code>。结合起来看，总的来说创建的链条如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ObjectProperty *op;</span><br><span class="line"></span><br><span class="line">op-&gt;name = <span class="string">"rtc-time"</span>;</span><br><span class="line">op-&gt;type = <span class="string">"struct tm"</span>;</span><br><span class="line">op-&gt;opaque = OBJECT(isadev);</span><br></pre></td></tr></table></figure>
<p>下面就简单说一下链条，链条的<code>type</code>类型有多种，有<code>child&lt;*&gt;</code>、<code>link&lt;*&gt;</code>、<code>string</code>、<code>bool</code>、<code>struct tm</code>、<code>uint8</code>、<code>uint16</code>、<code>uint32</code>、<code>uint64</code>等等，分别对应着父子对象之间的关系类型。定义不同<code>type</code>的链条有不同的函数，如<code>object_property_add_tm()</code>对应<code>struct tm</code>的<code>type</code>、<code>object_property_add_bool()</code>对应<code>bool</code>的<code>type</code>，等等。但最终都会调用同一个函数<code>object_property_try_add()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ObjectProperty *</span><br><span class="line">object_property_try_add(Object *obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *type,</span><br><span class="line">                        ObjectPropertyAccessor *get,</span><br><span class="line">                        ObjectPropertyAccessor *<span class="built_in">set</span>,</span><br><span class="line">                        ObjectPropertyRelease *release,</span><br><span class="line">                        <span class="keyword">void</span> *opaque, Error **errp)</span><br><span class="line">&#123;</span><br><span class="line">    ObjectProperty *prop;</span><br><span class="line">    <span class="keyword">size_t</span> name_len = <span class="built_in">strlen</span>(name);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    prop = g_malloc0(<span class="keyword">sizeof</span>(*prop));</span><br><span class="line"></span><br><span class="line">    prop-&gt;name = g_strdup(name); <span class="comment">//设置链条name</span></span><br><span class="line">    prop-&gt;type = g_strdup(type); <span class="comment">//设置链条type</span></span><br><span class="line"></span><br><span class="line">    prop-&gt;get = get;</span><br><span class="line">    prop-&gt;<span class="built_in">set</span> = <span class="built_in">set</span>;</span><br><span class="line">    prop-&gt;release = release;</span><br><span class="line">    prop-&gt;opaque = opaque;</span><br><span class="line"></span><br><span class="line">    g_hash_table_insert(obj-&gt;properties, prop-&gt;name, prop); <span class="comment">//插入父对象的properties哈希表中</span></span><br><span class="line">    <span class="keyword">return</span> prop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这下<code>object</code>和<code>child object</code>就搞明白了，继续看<code>do_object_child_foreach()</code>函数，应该就很明朗了。</p>
<p><strong>这个函数的作用就是，遍历根对象（pc-q35-6.0-machine）的子对象，筛选出type类型是child&lt;*&gt;的子对象，执行回调函数，并且递归遍历子对象继续执行相同的操作，一直循环反复，直到将所有子对象、子对象的子对象…都遍历完后就退出。</strong></p>
<p>根据调试情况可以验证我们的分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">pwndbg&gt; x/<span class="number">1</span>s prop.name</span><br><span class="line"><span class="number">0x6020000440b0</span>: <span class="string">"rtc-time"</span></span><br><span class="line">pwndbg&gt; x/<span class="number">1</span>s prop.type</span><br><span class="line"><span class="number">0x6020000440d0</span>: <span class="string">"struct tm"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">pwndbg&gt; x/<span class="number">1</span>s prop.name</span><br><span class="line"><span class="number">0x60200002f8d0</span>: <span class="string">"q35"</span></span><br><span class="line">pwndbg&gt; x/<span class="number">1</span>s prop.type</span><br><span class="line"><span class="number">0x60300005f4a0</span>: <span class="string">"child&lt;q35-pcihost&gt;"</span></span><br></pre></td></tr></table></figure>
<p>回到<code>generic_fuzz.c</code>主函数中来，分析一下前面提到的回调函数<code>locate_fuzz_objects()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">locate_fuzz_objects</span><span class="params">(Object *child, <span class="keyword">void</span> *opaque)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *pattern = opaque;           <span class="comment">//传入的QEMU_FUZZ_OBJECTS的值</span></span><br><span class="line">    <span class="keyword">if</span> (g_pattern_match_simple(pattern, object_get_typename(child))) &#123; <span class="comment">//匹配该obj name是否为传入字符串</span></span><br><span class="line">        <span class="comment">//寻找并保存子对象的memory内存空间</span></span><br><span class="line">        object_child_foreach_recursive(child, locate_fuzz_memory_regions, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对比是否属于pci设备，是则保存该对象</span></span><br><span class="line">        <span class="keyword">if</span> (object_dynamic_cast(OBJECT(child), TYPE_PCI_DEVICE)) &#123;</span><br><span class="line">						<span class="comment">//为了避免重复保存，先删除再添加</span></span><br><span class="line">            g_ptr_array_remove_fast(fuzzable_pci_devices, PCI_DEVICE(child));</span><br><span class="line">            g_ptr_array_add(fuzzable_pci_devices, PCI_DEVICE(child));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object_dynamic_cast(OBJECT(child), TYPE_MEMORY_REGION)) &#123; <span class="comment">//匹配是否为memory object继承关系</span></span><br><span class="line">        <span class="keyword">if</span> (g_pattern_match_simple(pattern, <span class="comment">//匹配memory obj与父节点间的type name是否为传入字符串</span></span><br><span class="line">            object_get_canonical_path_component(child))) &#123;</span><br><span class="line">            MemoryRegion *mr;</span><br><span class="line">            mr = MEMORY_REGION(child); <span class="comment">//获取该对象的memory空间</span></span><br><span class="line">            <span class="keyword">if</span> ((memory_region_is_ram(mr) ||     <span class="comment">//判断是否为内存空间</span></span><br><span class="line">                 memory_region_is_ram_device(mr) ||</span><br><span class="line">                 memory_region_is_rom(mr)) == <span class="literal">false</span>) &#123;</span><br><span class="line">                g_hash_table_insert(fuzzable_memoryregions, mr, (gpointer)<span class="literal">true</span>); <span class="comment">//保存memory</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">locate_fuzz_memory_regions</span><span class="params">(Object *child, <span class="keyword">void</span> *opaque)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    MemoryRegion *mr;</span><br><span class="line">    <span class="keyword">if</span> (object_dynamic_cast(child, TYPE_MEMORY_REGION)) &#123; <span class="comment">//判断是否有父子链接关系</span></span><br><span class="line">        mr = MEMORY_REGION(child); <span class="comment">//如果有则获取该对象的memory空间</span></span><br><span class="line">        <span class="keyword">if</span> ((memory_region_is_ram(mr) || <span class="comment">//判断memory空间是否为内存空间等等</span></span><br><span class="line">            memory_region_is_ram_device(mr) ||</span><br><span class="line">            memory_region_is_rom(mr)) == <span class="literal">false</span>) &#123;</span><br><span class="line">            name = object_get_canonical_path_component(child);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * We don't want duplicate pointers to the same MemoryRegion, so</span></span><br><span class="line"><span class="comment">             * try to remove copies of the pointer, before adding it.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            g_hash_table_insert(fuzzable_memoryregions, mr, (gpointer)<span class="literal">true</span>); <span class="comment">//将memory插入哈希表保存</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先简要介绍一下两个函数，第一个是<code>object_dynamic_cast()</code>，该函数是用来判断两者<code>object</code>是否有父子关系（继承关系）的。<strong>由于这里用来判断是否和<code>TYPE_MEMORY_REGION</code>有继承关系，我查了一下<code>QEMU</code>目前没有继承自<code>TYPE_MEMORY_REGION</code>的情况，因此，这里这个函数的作用就是只判断传入的<code>object</code>是否为<code>TYPE_MEMORY_REGION</code>对象。</strong></p>
<p>第二个是<code>object_get_canonical_path_component()</code>，该函数是获取传入的<code>object</code>与父对象间的链接关系的名字，也就是链条<code>ObjectProperty-&gt;name</code>。</p>
<p>在<code>locate_fuzz_objects</code>函数中，当匹配到我们要<code>fuzz</code>的对象字符串时，又开始递归筛选<code>child</code>子对象，并执行<code>locate_fuzz_memory_regions</code>回调函数。该回调函数的作用是判断传入的<code>child</code>对象是否是<code>TYPE_MEMORY_REGION</code>对象，是就将<code>memory</code>空间保存。后续又判断该对象是否属于<code>PCI</code>继承的设备，属于则保存指针。</p>
<p>再往下看，如果匹配的不是我们要<code>fuzz</code>的对象字符串，而是<code>TYPE_MEMORY_REGION</code>对象，并且该对象与父对象的链条名称和我们输入的字符串相同的话，则保存<code>memory</code>空间。</p>
<p>回到最开始的地方来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object_child_foreach_recursive(qdev_get_machine(),</span><br><span class="line">                               locate_fuzz_objects,</span><br><span class="line">                               result[i]);</span><br></pre></td></tr></table></figure>
<p>短短一行就展开了这么多的知识点，简单来概括一下前面所讲述的内容。</p>
<p><strong>根据传入的QEMU_FUZZ_OBJECTS的值，假设传入了“virtio*”，那么该函数就是从“根”对象machine开始，不断的循环遍历子对象（继承对象），筛选出名称与“virtio*”相匹配的对象，或者是在一对继承关系中继承链条的名称与“virtio*”相匹配的子对象（且该子对象必须为TYPE_MEMORY_REGION），取出这些对象的MEMORY_REGION区域并保存，也相应的保存满足上述条件而且又属于PCI设备的对象。</strong></p>
<p>结合上手调试，理解的会更快一些。拿<code>virtio-vga</code>设备举例，我想要<code>fuzz</code>该设备，传入的<code>QEMU_FUZZ_OBJECT</code>的值为<code>virtio*</code>，那么当<code>QEMU</code>启动后，会匹配所有<code>virtio*</code>相关的对象或者<code>memory region</code>，其中，<code>vga-pci.c</code>文件中有这么一条：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">memory_region_init_io(&amp;subs[<span class="number">0</span>], owner, &amp;pci_vga_ioport_ops, s,</span><br><span class="line">                      <span class="string">"vga ioports remapped"</span>, PCI_VGA_IOPORT_SIZE);</span><br></pre></td></tr></table></figure>
<p>也就是会与<code>memory_region</code>构建一条名为<code>vga ioports remapped</code>的关系链条。当然还有许多其他条相关的链，经调试得出的结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">* vga ioports remapped[<span class="number">0</span>] (size <span class="number">20</span>)</span><br><span class="line">* qemu extended regs[<span class="number">0</span>] (size <span class="number">8</span>)</span><br><span class="line">* virtio-pci-device[<span class="number">0</span>] (size <span class="number">1000</span>)</span><br><span class="line">* vga[<span class="number">4</span>] (size <span class="number">1</span>)</span><br><span class="line">* msix-pba[<span class="number">0</span>] (size <span class="number">8</span>)</span><br><span class="line">* vga[<span class="number">2</span>] (size <span class="number">10</span>)</span><br><span class="line">* bochs dispi interface[<span class="number">0</span>] (size <span class="number">16</span>)</span><br><span class="line">* virtio-pci-notify[<span class="number">0</span>] (size <span class="number">1000</span>)</span><br><span class="line">* vga[<span class="number">0</span>] (size <span class="number">2</span>)</span><br><span class="line">* bus master[<span class="number">0</span>] (size <span class="number">0</span>)</span><br><span class="line">* msix-table[<span class="number">0</span>] (size <span class="number">30</span>)</span><br><span class="line">* vga-lowmem[<span class="number">0</span>] (size <span class="number">20000</span>)</span><br><span class="line">* virtio-pci-common[<span class="number">0</span>] (size <span class="number">800</span>)</span><br><span class="line">* virtio-pci-notify-pio[<span class="number">0</span>] (size <span class="number">4</span>)</span><br><span class="line">* vbe[<span class="number">0</span>] (size <span class="number">4</span>)</span><br><span class="line">* bus master container[<span class="number">0</span>] (size <span class="number">0</span>)</span><br><span class="line">* virtio-vga-msix[<span class="number">0</span>] (size <span class="number">1000</span>)</span><br><span class="line">* vga[<span class="number">3</span>] (size <span class="number">2</span>)</span><br><span class="line">* virtio-pci-isr[<span class="number">0</span>] (size <span class="number">800</span>)</span><br><span class="line">* virtio-pci[<span class="number">0</span>] (size <span class="number">4000</span>)</span><br><span class="line">* vga[<span class="number">1</span>] (size <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>总共会保存这些<code>memory region</code>。其中就包括了前面我们所说的<code>vga ioports remapped</code>。</p>
<p>继续往下看<code>generic_pre_fuzz()</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generic_pre_fuzz</span><span class="params">(QTestState *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="comment">//......</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This process will try to fuzz the following MemoryRegions:\n"</span>);</span><br><span class="line"></span><br><span class="line">    g_hash_table_iter_init(&amp;iter, fuzzable_memoryregions);</span><br><span class="line">    <span class="keyword">while</span> (g_hash_table_iter_next(&amp;iter, (gpointer)&amp;mr, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  * %s (size %lx)\n"</span>,</span><br><span class="line">               object_get_canonical_path_component(&amp;(mr-&gt;parent_obj)),</span><br><span class="line">               (<span class="keyword">uint64_t</span>)mr-&gt;size);</span><br><span class="line">    &#125; <span class="comment">//循环打印所保存的region，输出就是上面提到的结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!g_hash_table_size(fuzzable_memoryregions)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"No fuzzable memory regions found...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pcibus = qpci_new_pc(s, <span class="literal">NULL</span>); <span class="comment">//初始化总线数据</span></span><br><span class="line">    g_ptr_array_foreach(fuzzable_pci_devices, pci_enum, pcibus); <span class="comment">//以libqos（QTest）的形式初始化各个保存的pci设备</span></span><br><span class="line">    qpci_free_pc(pcibus);</span><br><span class="line"></span><br><span class="line">    counter_shm_init(); <span class="comment">//初始化fork下的共享内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一块就是收尾工作，将<code>PCI</code>总线和保存的<code>PCI</code>设备初始化，总的来说就是做一些<code>fuzz</code>前的初始化准备工作。重点讲一下回调函数<code>pci_enum()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pci_enum</span><span class="params">(gpointer pcidev, gpointer bus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PCIDevice *dev = pcidev;</span><br><span class="line">    QPCIDevice *qdev;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    qdev = qpci_device_find(bus, dev-&gt;devfn); <span class="comment">//根据device number、function number创建QTest</span></span><br><span class="line">  																						<span class="comment">//模式的pci device</span></span><br><span class="line">    g_assert(qdev != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dev-&gt;io_regions[i].size) &#123;</span><br><span class="line">            qpci_iomap(qdev, i, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    qpci_device_enable(qdev);</span><br><span class="line">    g_free(qdev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dev-&gt;io_regions[]</code>这个比较重要，是<code>PCI Configuration space</code>中的六个<code>bar</code>空间，但是看定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCI_NUM_REGIONS 7</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PCIDevice</span> &#123;</span></span><br><span class="line">		<span class="comment">//......</span></span><br><span class="line">    PCIIORegion io_regions[PCI_NUM_REGIONS];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PCIIORegion</span> &#123;</span></span><br><span class="line">    <span class="keyword">pcibus_t</span> addr; <span class="comment">/* current PCI mapping address. -1 means not mapped */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCI_BAR_UNMAPPED (~(pcibus_t)0)</span></span><br><span class="line">    <span class="keyword">pcibus_t</span> size;</span><br><span class="line">    <span class="keyword">uint8_t</span> type;</span><br><span class="line">    MemoryRegion *memory;</span><br><span class="line">    MemoryRegion *address_space;</span><br><span class="line">&#125; PCIIORegion;</span><br></pre></td></tr></table></figure>
<p>实际上<code>region</code>有<code>7</code>个，为什么上面只遍历了<code>6</code>个？因为最后一个<code>region</code>实际上是<code>ROM</code>空间，前六个是<code>RAM</code>空间，在这里我们用不到<code>ROM</code>，因此只遍历六个。具体来看下面的代码，这个代码用于给<code>device</code>添加<code>option rom</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pci_add_option_rom</span><span class="params">(PCIDevice *pdev, <span class="keyword">bool</span> is_default_rom,</span></span></span><br><span class="line"><span class="function"><span class="params">                               Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="comment">//......</span></span><br><span class="line">  	pci_register_bar(pdev, PCI_ROM_SLOT, <span class="number">0</span>, &amp;pdev-&gt;rom); <span class="comment">//PCIDevice中有个名为rom的region</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pci_register_bar</span><span class="params">(PCIDevice *pci_dev, <span class="keyword">int</span> region_num,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">uint8_t</span> type, MemoryRegion *memory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="comment">//......</span></span><br><span class="line">  	    <span class="keyword">if</span> (region_num == PCI_ROM_SLOT) &#123; <span class="comment">//PCI_ROM_SLOT = 6</span></span><br><span class="line">        <span class="comment">/* ROM enable bit is writable */</span></span><br><span class="line">        wmask |= PCI_ROM_ADDRESS_ENABLE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本可以看出来是用于<code>ROM</code>的。同样的，这几个<code>region</code>的初始化来源也是<code>pci_register_bar()</code>函数，不过该函数只是注册了一下，并没有分配到实际的地址，地址指的是换成上述结构体来说的话就是<code>PCIIORegion-&gt;addr</code>。更新地址的函数在<code>pci_update_mapping()</code>。其中<code>io_regions</code>的内容都是从<code>MemoryRegion</code>结构体中迁移过来的。具体怎么注册<code>bar</code>空间的后续会提到一部分。这一块推荐看<a href="https://blog.csdn.net/weixin_43780260/article/details/104410063" target="_blank" rel="noopener">这篇文章</a>。</p>
<p>继续看<code>qpci_iomap()</code>函数，这个函数信息量比较大，我拓展开来看了好久才明白这个函数是做什么的。<strong>简单概括一下就是以<code>QTest</code>的形式重新分配<code>PCI</code>设备的<code>bar</code>地址。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPCIBar <span class="title">qpci_iomap</span><span class="params">(QPCIDevice *dev, <span class="keyword">int</span> barno, <span class="keyword">uint64_t</span> *sizeptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QPCIBus *bus = dev-&gt;bus;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> bar_reg_map[] = &#123;</span><br><span class="line">        PCI_BASE_ADDRESS_0, PCI_BASE_ADDRESS_1, PCI_BASE_ADDRESS_2,</span><br><span class="line">        PCI_BASE_ADDRESS_3, PCI_BASE_ADDRESS_4, PCI_BASE_ADDRESS_5,</span><br><span class="line">    &#125;;</span><br><span class="line">    QPCIBar bar;</span><br><span class="line">    <span class="keyword">int</span> bar_reg;</span><br><span class="line">    <span class="keyword">uint32_t</span> addr, size;</span><br><span class="line">    <span class="keyword">uint32_t</span> io_type;</span><br><span class="line">    <span class="keyword">uint64_t</span> loc;</span><br><span class="line"></span><br><span class="line">    g_assert(barno &gt;= <span class="number">0</span> &amp;&amp; barno &lt;= <span class="number">5</span>);</span><br><span class="line">    bar_reg = bar_reg_map[barno];</span><br><span class="line"></span><br><span class="line">    qpci_config_writel(dev, bar_reg, <span class="number">0xFFFFFFFF</span>); <span class="comment">//写bar空间的地址(1)</span></span><br><span class="line">    addr = qpci_config_readl(dev, bar_reg); <span class="comment">//读bar空间的地址(1)</span></span><br><span class="line"></span><br><span class="line">    io_type = addr &amp; PCI_BASE_ADDRESS_SPACE; <span class="comment">//判断bar空间是memory map还是io map</span></span><br><span class="line">    <span class="keyword">if</span> (io_type == PCI_BASE_ADDRESS_SPACE_IO) &#123;</span><br><span class="line">        addr &amp;= PCI_BASE_ADDRESS_IO_MASK;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addr &amp;= PCI_BASE_ADDRESS_MEM_MASK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g_assert(addr); <span class="comment">/* Must have *some* size bits */</span></span><br><span class="line"></span><br><span class="line">    size = <span class="number">1U</span> &lt;&lt; ctz32(addr); <span class="comment">//获取bar空间的size(2)</span></span><br><span class="line">    <span class="keyword">if</span> (sizeptr) &#123;</span><br><span class="line">        *sizeptr = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有两个比较疑惑的点，在标记<code>1</code>处，先写<code>bar</code>地址为<code>0xFFFFFFFF</code>，后读<code>bar</code>地址，不过当我调试的时候，得到的<code>addr</code>并不是<code>0xFFFFFFFF</code>。第二点在标记<code>2</code>处，<code>ctz32()</code>是取末尾零的个数，为什么这样就能得到<code>bar</code>空间的<code>size</code>？</p>
<p>这两个点可以结合起来一起看。前面我们提到注册<code>io_regions</code>的函数为<code>pci_register_bar()</code>。这里我们仍然以<code>virtio-vga</code>设备为栗子。在<code>virtio-vga.c</code>初始化设备中存在注册函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">virtio_vga_base_realize</span><span class="params">(VirtIOPCIProxy *vpci_dev, Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="comment">//......</span></span><br><span class="line">  	pci_register_bar(&amp;vpci_dev-&gt;pci_dev, <span class="number">0</span>,</span><br><span class="line">                     PCI_BASE_ADDRESS_MEM_PREFETCH, &amp;vga-&gt;vram); <span class="comment">//注册0号位的bar空间（总共六个）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pci_register_bar</span><span class="params">(PCIDevice *pci_dev, <span class="keyword">int</span> region_num,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">uint8_t</span> type, MemoryRegion *memory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PCIIORegion *r;</span><br><span class="line">    <span class="keyword">uint32_t</span> addr; <span class="comment">/* offset in pci config space */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> wmask;</span><br><span class="line">    <span class="keyword">pcibus_t</span> size = memory_region_size(memory);</span><br><span class="line">    <span class="keyword">uint8_t</span> hdr_type;</span><br><span class="line"></span><br><span class="line">    assert(region_num &gt;= <span class="number">0</span>);</span><br><span class="line">    assert(region_num &lt; PCI_NUM_REGIONS);</span><br><span class="line">    assert(is_power_of_2(size));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* A PCI bridge device (with Type 1 header) may only have at most 2 BARs */</span></span><br><span class="line">    hdr_type =     <span class="comment">//取配置空间的Header Type部分</span></span><br><span class="line">        pci_dev-&gt;config[PCI_HEADER_TYPE] &amp; ~PCI_HEADER_TYPE_MULTI_FUNCTION;</span><br><span class="line">    assert(hdr_type != PCI_HEADER_TYPE_BRIDGE || region_num &lt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    r = &amp;pci_dev-&gt;io_regions[region_num]; <span class="comment">//取相应注册的bar空间，这里是0号</span></span><br><span class="line">    r-&gt;addr = PCI_BAR_UNMAPPED; <span class="comment">//分配地址，这里是未映射地址0xFFFFFFFFFFFFFFFF</span></span><br><span class="line">    r-&gt;size = size; <span class="comment">//分配size，取自memory reigon</span></span><br><span class="line">    r-&gt;type = type; <span class="comment">//分配type</span></span><br><span class="line">    r-&gt;memory = memory; <span class="comment">//分配memory</span></span><br><span class="line">    r-&gt;address_space = type &amp; PCI_BASE_ADDRESS_SPACE_IO</span><br><span class="line">                        ? pci_get_bus(pci_dev)-&gt;address_space_io</span><br><span class="line">                        : pci_get_bus(pci_dev)-&gt;address_space_mem;</span><br><span class="line"></span><br><span class="line">    wmask = ~(size - <span class="number">1</span>); <span class="comment">//(3)</span></span><br><span class="line">    <span class="keyword">if</span> (region_num == PCI_ROM_SLOT) &#123;</span><br><span class="line">        <span class="comment">/* ROM enable bit is writable */</span></span><br><span class="line">        wmask |= PCI_ROM_ADDRESS_ENABLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr = pci_bar(pci_dev, region_num); <span class="comment">//取相应的bar空间的地址</span></span><br><span class="line">    pci_set_long(pci_dev-&gt;config + addr, type); <span class="comment">//写bar的type类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(r-&gt;type &amp; PCI_BASE_ADDRESS_SPACE_IO) &amp;&amp;</span><br><span class="line">        r-&gt;type &amp; PCI_BASE_ADDRESS_MEM_TYPE_64) &#123;</span><br><span class="line">        pci_set_quad(pci_dev-&gt;wmask + addr, wmask);</span><br><span class="line">        pci_set_quad(pci_dev-&gt;cmask + addr, ~<span class="number">0U</span>LL);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pci_set_long(pci_dev-&gt;wmask + addr, wmask &amp; <span class="number">0xffffffff</span>); <span class="comment">//写wmask的值</span></span><br><span class="line">        pci_set_long(pci_dev-&gt;cmask + addr, <span class="number">0xffffffff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调试过程当中，上述<code>vga</code>设备注册的<code>MemoryRegion-&gt;size</code>为<code>0x800000</code>，再看标记<code>3</code>处，<code>wmask</code>的结果为<code>0xff800000</code>，<code>PCIDevice-&gt;wmask</code>的定义是用于实现<code>R/W</code>字节，应该是用于标记<code>size</code>的作用。最终配置空间的内存情况是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">10</span>xg <span class="number">0x62100002bd00</span></span><br><span class="line"><span class="number">0x62100002bd00</span>: <span class="number">0x0010000010501af4</span>      <span class="number">0x0000000003000001</span></span><br><span class="line"><span class="number">0x62100002bd10</span>: <span class="number">0x0000000000000008</span>      <span class="number">0x000000000000000c</span></span><br><span class="line"><span class="number">0x62100002bd20</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x11001af400000000</span></span><br><span class="line"><span class="number">0x62100002bd30</span>: <span class="number">0x0000009800000000</span>      <span class="number">0x0000010000000000</span></span><br><span class="line"><span class="number">0x62100002bd40</span>: <span class="number">0x0000000201100009</span>      <span class="number">0x0000080000001000</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//0x62100002bd10处的0x08值，就是所写入的bar type值。可见，bar处并没有配置地址。</span></span><br></pre></td></tr></table></figure>
<p>回到<code>qpci_iomap()</code>函数，当调用标记<code>1</code>处的函数<code>qpci_config_writel()</code>时，最终会调用<code>hw/pci/pci.c:pci_default_write_config()</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入参数：addr = 0x10 , val_in = 0xffffffff</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pci_default_write_config</span><span class="params">(PCIDevice *d, <span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> val_in, <span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> val = val_in;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; l; val &gt;&gt;= <span class="number">8</span>, ++i) &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> wmask = d-&gt;wmask[addr + i];      <span class="comment">//取wmask值</span></span><br><span class="line">        <span class="keyword">uint8_t</span> w1cmask = d-&gt;w1cmask[addr + i];</span><br><span class="line">        assert(!(wmask &amp; w1cmask));</span><br><span class="line">        d-&gt;config[addr + i] = (d-&gt;config[addr + i] &amp; ~wmask) | (val &amp; wmask); <span class="comment">//(4)</span></span><br><span class="line">        d-&gt;config[addr + i] &amp;= ~(val &amp; w1cmask); <span class="comment">/* W1C: Write 1 to Clear */</span></span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键读写的操作在标记<code>4</code>处。简单来说就是设置<code>bar</code>空间的地址。根据前面我们知道<code>wmask</code>的结果是<code>0xff800000</code>，那么最终设置的<code>bar</code>地址就是<code>0xff800000</code>，内存布局如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">10</span>xg <span class="number">0x62100002bd00</span></span><br><span class="line"><span class="number">0x62100002bd00</span>: <span class="number">0x0010000010501af4</span>      <span class="number">0x0000000003000001</span></span><br><span class="line"><span class="number">0x62100002bd10</span>: <span class="number">0x00000000ff800008</span>      <span class="number">0x000000000000000c</span></span><br><span class="line"><span class="number">0x62100002bd20</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x11001af400000000</span></span><br><span class="line"><span class="number">0x62100002bd30</span>: <span class="number">0x0000009800000000</span>      <span class="number">0x0000010000000000</span></span><br><span class="line"><span class="number">0x62100002bd40</span>: <span class="number">0x0000000201100009</span>      <span class="number">0x0000080000001000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置过后的0x62100002bd10地址处的值。</span></span><br></pre></td></tr></table></figure>
<p>这也就是为什么前面我们在<code>qpci_iomap()</code>函数标记<code>1</code>先写后读<code>bar</code>地址为什么会出现不是<code>0xffffffff</code>的情况。最终得到的地址是<code>0xff800008</code>。</p>
<p>第一个疑惑点解决了，再来看第二个疑惑点，为什么<code>1U &lt;&lt; ctz32(addr);</code>就能获得<code>size</code>。当去掉<code>addr</code>地址的<code>type</code>执行到标记<code>2</code>处的时候，<code>addr</code>的值是<code>0xff800000</code>，<code>ctz32(addr)</code>得到的就是<code>23</code>，<code>1&lt;&lt;23</code>就是<code>size</code>，即<code>0x800000</code>，和最开始注册时的<code>size</code>是一样的。</p>
<p>根据定义，<code>memory space bar</code>和<code>I/O space bar</code>的地址分别是<code>16byte</code>和<code>4byte</code>对齐的：</p>
<p><img src="/QTest源码分析/字节对齐.jpg" alt="字节对齐"></p>
<p>这就是为什么能按上述来获取<code>size</code>的原因，以及为什么能够利用<code>wmask</code>来做辅助。还不清楚可以自己动手算一下….</p>
<p><code>qpci_iomap()</code>前半部分算是分析完了，再来看剩余的部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPCIBar <span class="title">qpci_iomap</span><span class="params">(QPCIDevice *dev, <span class="keyword">int</span> barno, <span class="keyword">uint64_t</span> *sizeptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="comment">//......</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        loc = QEMU_ALIGN_UP(bus-&gt;mmio_alloc_ptr, size); <span class="comment">//取基数mmio alloc指针</span></span><br><span class="line">  </span><br><span class="line">        bus-&gt;mmio_alloc_ptr = loc + size; <span class="comment">//将基数到基数+size这部分空间留给该io_region</span></span><br><span class="line"></span><br><span class="line">        qpci_config_writel(dev, bar_reg, loc); <span class="comment">//重新设置bar地址</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bar.addr = loc;</span><br><span class="line">    <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就举例<code>mmio</code>的情况，<code>pio</code>其实一样。最开始的<code>bus-&gt;mmio_allco_ptr</code>为<code>0xE0000000</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qpci_init_pc</span><span class="params">(QPCIBusPC *qpci, QTestState *qts, QGuestAllocator *alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="comment">//......</span></span><br><span class="line">    qpci-&gt;bus.pio_alloc_ptr = <span class="number">0xc000</span>;       <span class="comment">//pio基址</span></span><br><span class="line">    qpci-&gt;bus.mmio_alloc_ptr = <span class="number">0xE0000000</span>;  <span class="comment">//mmio基址</span></span><br><span class="line">    qpci-&gt;bus.mmio_limit = <span class="number">0x100000000</span>ULL;  <span class="comment">//mmio限度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>后半部分其实就是从地址<code>0xE0000000</code>开始往后的空间依次分配给<code>PCI</code>的<code>bar</code>空间。</strong><code>qpci_iomap()</code>函数到这里分析就结束了。</p>
<p>再次回到<code>pci_enum()</code>函数中来，最后剩下的<code>qpci_device_enable()</code>函数就是写<code>PCI</code>设备的配置空间<code>COMMAND</code>内容处，使得<code>PCI</code>设备能够正式启用。</p>
<p>至此，正式<code>fuzz</code>前的准备工作函数<code>generic_fuzz()</code>都已经分析完毕，所有细节部分我们都已经了解过了。剩下的就只有正式<code>fuzz</code>函数以及变异策略函数了。</p>
<p>正式<code>fuzz</code>函数我就不细说，主要就是取<code>libfuzzer</code>的随机输入数据做拆分并设置几个<code>opcode</code>做选择。举个栗子，现在有这么一串随机输入数据：</p>
<blockquote>
<p>00 01 02 FF 03 04 05 06 FF 01 FF</p>
</blockquote>
<p>我设置了几个<code>opcode</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OP_IN,</span><br><span class="line">OP_OUT,</span><br><span class="line">OP_READ,</span><br><span class="line">OP_WRITE</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>以<code>0xFF</code>做分割符，分别取出来作为<code>data</code>和<code>data_len</code>，那么这一串数据就分别对应一下函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* <span class="number">00</span> <span class="number">01</span> <span class="number">02</span>    -&gt; op00 (<span class="number">0102</span>)   -&gt; in (<span class="number">0102</span>, <span class="number">2</span>)</span><br><span class="line">* <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> -&gt; op03 (<span class="number">040506</span>) -&gt; write (<span class="number">040506</span>, <span class="number">3</span>)</span><br><span class="line">* <span class="number">01</span>          -&gt; op01 (-,<span class="number">0</span>)    -&gt; out (-,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>这就是主<code>fuzz</code>函数的核心思想。</p>
<p>这里我们再看一下获取<code>mmio</code>和<code>pio</code>地址的关键函数<code>get_io_address()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">get_io_cb_info</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">int</span> found;</span><br><span class="line">    address_range result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">ram_addr_t</span> addr;</span><br><span class="line">    <span class="keyword">ram_addr_t</span> size; <span class="comment">/* The number of bytes until the end of the I/O region */</span></span><br><span class="line">&#125; address_range;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">get_io_address</span><span class="params">(address_range *result, AddressSpace *as,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">uint8_t</span> index,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">uint32_t</span> offset)</span> </span>&#123; <span class="comment">//传入的为全局的address_space_memory变量，</span></span><br><span class="line">  																						 <span class="comment">//代表虚拟地址空间</span></span><br><span class="line">    FlatView *view;</span><br><span class="line">    view = as-&gt;current_map; <span class="comment">//获取当前的FlatView</span></span><br><span class="line">    g_assert(view);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">get_io_cb_info</span> <span class="title">cb_info</span> = &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cb_info.index = index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        flatview_for_each_range(view, get_io_address_cb , &amp;cb_info);</span><br><span class="line">    &#125; <span class="keyword">while</span> (cb_info.index != index &amp;&amp; !cb_info.found);</span><br><span class="line"></span><br><span class="line">    *result = cb_info.result;</span><br><span class="line">    <span class="keyword">if</span> (result-&gt;size) &#123;</span><br><span class="line">        offset = offset % result-&gt;size;</span><br><span class="line">        result-&gt;addr += offset;</span><br><span class="line">        result-&gt;size -= offset;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cb_info.found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flatview_for_each_range</span><span class="params">(FlatView *fv, flatview_cb cb , <span class="keyword">void</span> *opaque)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FlatRange *fr;</span><br><span class="line"></span><br><span class="line">    assert(fv);</span><br><span class="line">    assert(cb);</span><br><span class="line"></span><br><span class="line">    FOR_EACH_FLAT_RANGE(fr, fv) &#123;  <span class="comment">//从根开始循环遍历FlatRange</span></span><br><span class="line">        <span class="keyword">if</span> (cb(fr-&gt;addr.start, fr-&gt;addr.size, fr-&gt;mr, opaque))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_io_address_cb</span><span class="params">(Int128 start, Int128 size,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> MemoryRegion *mr, <span class="keyword">void</span> *opaque)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">get_io_cb_info</span> *<span class="title">info</span> = <span class="title">opaque</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (g_hash_table_lookup(fuzzable_memoryregions, mr)) &#123; <span class="comment">//查询是否包含在前面所存储的region中</span></span><br><span class="line">        <span class="keyword">if</span> (info-&gt;index == <span class="number">0</span>) &#123;</span><br><span class="line">            info-&gt;result.addr = (<span class="keyword">ram_addr_t</span>)start;</span><br><span class="line">            info-&gt;result.size = (<span class="keyword">ram_addr_t</span>)size;</span><br><span class="line">            info-&gt;found = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        info-&gt;index--; <span class="comment">//遍历直到idx为0，也就是选择先前保存的所有region中第idx个region</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>阅读上面的代码需要理解<code>QEMU</code>的内存管理机制，不明白的推荐看这两篇，<a href="https://www.cnblogs.com/ccxikka/p/9477530.html" target="_blank" rel="noopener">QEMU对虚拟机的内存管理</a>、<a href="https://richardweiyang-2.gitbook.io/kernel-exploring/00-kvm/01-memory_virtualization/01_1-qemu_memory_model" target="_blank" rel="noopener">QEMU内存模型</a>。</p>
<p><strong>简单说就是随机选取前面保存起来的<code>MemoryRegion</code>中的一块，进行后续的读写操作。</strong></p>
<p>但是，这里有读者可能就有疑问了，如果要随机选的话，为什么不直接在存储起来的空间中直接挑呢？而是大费周章的去全局遍历，对比，然后再挑选？</p>
<p>因为我们最终目的是要得到<code>MemoryRegion</code>中的地址、以及<code>size</code>。虽然说看了<code>MemoryRegion</code>的结构体后能够发现其本身就有一个<code>addr</code>属性，但是，这个<code>addr</code>并不是真正意义上的内存地址，还是一个相对偏移，即类似于<code>offset</code>。在<code>QEMU</code>内存管理中，<code>FlatRange</code>中有指向所属<code>MemoryRegion</code>的指针，其中也保存着<code>addr</code>和<code>size</code>，这里的<code>addr</code>才是<code>MemoryRegion</code>真正的地址，具体结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AddrRange</span> &#123;</span></span><br><span class="line">    Int128 start; <span class="comment">//起始</span></span><br><span class="line">    Int128 size; <span class="comment">//大小</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Range of memory in the global map.  Addresses are absolute. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FlatRange</span> &#123;</span></span><br><span class="line">    MemoryRegion *mr; <span class="comment">//指向所属的MR</span></span><br><span class="line">    hwaddr offset_in_region; <span class="comment">//在MR中的offset</span></span><br><span class="line">    AddrRange addr; <span class="comment">//本FR代表的区间</span></span><br><span class="line">    <span class="keyword">uint8_t</span> dirty_log_mask;</span><br><span class="line">    <span class="keyword">bool</span> romd_mode;</span><br><span class="line">    <span class="keyword">bool</span> readonly;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这下就明白为什么要“大费周章”的去遍历所有<code>Region</code>得到<code>addr</code>了吧。具体的细节看完上面两篇文章后就能弄清楚整一个内存管理的原理了。</p>
<p>最后就是变异策略的函数了，这一块作者写的比较简单，自行阅读代码即可。不过我注意到作者还写了<code>fuzz_dma_read_cb()</code>函数，但是并没有应用过，觉得没有用吗？这一块读者感兴趣的话可以自己阅读以下，看看具体作用到底是什么。</p>
<p>源码分析到这里就完全结束了，感谢阅读。有错误欢迎斧正。</p>
<h3 id="0x03-Summary"><a href="#0x03-Summary" class="headerlink" title="0x03 Summary"></a>0x03 Summary</h3><p>读到这里，我想聪明的读者应该已经发现，其实<code>generic_fuzz</code>是一个比较<code>dumb</code>的<code>fuzzer</code>，优点就在能够通用<code>fuzz</code>。而且因为受限于<code>QTest</code>，只有部分设备做了<code>QTest</code>化的处理，所以能够测试的目标有限，我猜测这也是为什么作者只写了针对<code>virtio</code>的几个设备写了特定的<code>fuzz</code>，因为官方在<code>QTest</code>中只写了<code>virtio</code>的一部分。如果想要更高效率的<code>fuzz</code>的话，那还是得需要自己做优化的，我这里仅提供几个思路。</p>
<ul>
<li><p>在<code>generic_fuzz</code>中做结构化<code>fuzz</code>，也就是争对某个<code>device</code>做相应的结构体输入化，这样可以充分利用该<code>fuzz</code>的<code>fork</code>的优势。缺点是目标单一，不能多设备<code>fuzz</code>。这里也可以删除他本身的几个<code>opcode</code>函数，例如读写<code>config</code>的可以删除，对于我们来说基本没什么用，可以只保留读写<code>mmio/pio</code>区域的函数，这样可以提高<code>fuzz</code>效率。</p>
</li>
<li><p>自己编写<code>QTest</code>化的设备代码，并后续针对这个继续写相应的<code>fuzz</code>。也就是承接上面官方只写了一部分的情况。这是个体力活，不过我个人估计产出会比较明显。</p>
</li>
<li><p>在<code>generic_fuzz</code>上做优化（不是单一化），例如提高覆盖率等操作，我自认为它本身还有比较大的改进空间，具体怎么改，我还没有可行的思路，知道的读者麻烦交流一下<code>:)</code>。</p>
</li>
</ul>
<h3 id="0x04-Reference"><a href="#0x04-Reference" class="headerlink" title="0x04 Reference"></a>0x04 Reference</h3><ol>
<li><a href="https://www.cnblogs.com/ccxikka/p/9477530.html" target="_blank" rel="noopener">https://www.cnblogs.com/ccxikka/p/9477530.html</a></li>
<li><a href="https://richardweiyang-2.gitbook.io/kernel-exploring/00-kvm/01-memory_virtualization/01_1-qemu_memory_model" target="_blank" rel="noopener">https://richardweiyang-2.gitbook.io/kernel-exploring/00-kvm/01-memory_virtualization/01_1-qemu_memory_model</a></li>
<li><a href="https://qemu.readthedocs.io/en/latest/devel/qgraph.html#qgraph" target="_blank" rel="noopener">https://qemu.readthedocs.io/en/latest/devel/qgraph.html#qgraph</a></li>
<li><a href="https://blog.csdn.net/weixin_43780260/article/details/104410063" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43780260/article/details/104410063</a></li>
</ol>

    
  </div>

  
      <div class="git"></div>
  

</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持v1nke</div>
        <ul>
        
          <li class="item">
            <span>微信扫一扫</span>
            <img src="/images/qr-wechat.jpeg" alt="">
          </li>
        
          <li class="item">
            <span>支付宝扫一扫</span>
            <img src="/images/qr-wechat.jpeg" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2021/03/29/QEMU-QTest && Libfuzzer源码分析（上）/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2021/05/24/ErrorHanlding分析/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
