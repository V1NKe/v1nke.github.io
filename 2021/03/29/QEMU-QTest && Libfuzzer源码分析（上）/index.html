<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>QEMU源码分析 - QTest（上） | V1NKe的心情垃圾桶</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="QEMU," />
  

  <meta name="description" content="QEMU源码分析">
<meta name="keywords" content="QEMU">
<meta property="og:type" content="article">
<meta property="og:title" content="QEMU源码分析 - QTest（上）">
<meta property="og:url" content="http://yoursite.com/2021/03/29/QEMU-QTest && Libfuzzer源码分析（上）/index.html">
<meta property="og:site_name" content="V1NKe的心情垃圾桶">
<meta property="og:description" content="QEMU源码分析">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/QTest源码分析/节点树.png">
<meta property="og:image" content="http://yoursite.com/QTest源码分析/栈空间示意图.png">
<meta property="og:updated_time" content="2022-01-09T15:02:11.676Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="QEMU源码分析 - QTest（上）">
<meta name="twitter:description" content="QEMU源码分析">
<meta name="twitter:image" content="http://yoursite.com/QTest源码分析/节点树.png">

  

  
    <link rel="icon" href="/haimian.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#QEMU-QTest-amp-amp-Libfuzzer源码分析（上）"><span class="toc-text">QEMU-QTest &amp;&amp; Libfuzzer源码分析（上）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x01-TL-DR"><span class="toc-text">0x01 TL;DR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x02-SourceCode-Version"><span class="toc-text">0x02 SourceCode Version</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x03-Basic-Principle"><span class="toc-text">0x03 Basic Principle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x04-QTest-Code-Analyse"><span class="toc-text">0x04 QTest Code Analyse</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x05-QTest-Summary"><span class="toc-text">0x05 QTest Summary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x06-Libfuzzer-Test-Code-Analyze"><span class="toc-text">0x06 Libfuzzer Test Code Analyze</span></a></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-QEMU-QTest &amp;&amp; Libfuzzer源码分析（上）" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">QEMU源码分析 - QTest（上）</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2021.03.29</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>V1NKe</span>
        </span>
      

      


      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <h2 id="QEMU-QTest-amp-amp-Libfuzzer源码分析（上）"><a href="#QEMU-QTest-amp-amp-Libfuzzer源码分析（上）" class="headerlink" title="QEMU-QTest &amp;&amp; Libfuzzer源码分析（上）"></a>QEMU-QTest &amp;&amp; Libfuzzer源码分析（上）</h2><h3 id="0x01-TL-DR"><a href="#0x01-TL-DR" class="headerlink" title="0x01 TL;DR"></a>0x01 TL;DR</h3><p><code>QEMU</code>中的<code>Libfuzzer</code>是<code>Alexander Bulekov</code>在19年<code>Google SummerCode</code>期间开发的一套<code>QEMU</code>内置的<code>Fuzz</code>工具。<code>QEMU</code>最开始代码测试的时候开发了一套名为<code>QTest</code>的测试工具，主要用它来编写测试用例。<code>QEMU</code>中的设备很多，一个一个去写相应设备的测试用例是很耗时间的，因此就有了在<code>QTest</code>结合<code>Libfuzzer</code>的测试工具。不过当我整体审计完<code>QTest</code>代码后，发现其实还是蛮有局限性的，待改进的空间也很大。</p>
<p>由于全文篇幅比较长，因此分为上下两篇叙述。</p>
<h3 id="0x02-SourceCode-Version"><a href="#0x02-SourceCode-Version" class="headerlink" title="0x02 SourceCode Version"></a>0x02 SourceCode Version</h3><p><code>QEMU</code>：5.2.0</p>
<h3 id="0x03-Basic-Principle"><a href="#0x03-Basic-Principle" class="headerlink" title="0x03 Basic Principle"></a>0x03 Basic Principle</h3><p>先简单梳理一下<code>QTest</code>的设计原理。我尽量保持原汁原味，不改变原意。</p>
<p><code>QTest</code>大体将<code>QEMU</code>内容划分为四类：<code>Machine</code>、<code>Driver</code>、<code>Interface</code>、<code>Test</code>，每一类为一个<code>node</code>（节点）。节点之间的关系被称作<code>edge</code>，<code>edge</code>分为三类：<code>consume</code>、<code>produce</code>、<code>contain</code>。</p>
<p>关于<code>edge</code>官方解释是这样的（<code>x</code>和<code>y</code>为<code>node</code>）：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x consumes y : x可以使用y（和produces对应）</span><br><span class="line">x produces y : x给y提供接口</span><br><span class="line">x contains y : y是x组件的一部分（x包含y）</span><br></pre></td></tr></table></figure>
<p><code>QTest</code>基本框架步骤如下：</p>
<ul>
<li>所有<code>nodes</code>和<code>edges</code>都创建在各自的文件下 –&gt; <code>machine/driver/test</code>。</li>
<li>启动<code>QEMU</code>后查询一系列的可用<code>devices</code>和<code>machines</code>。</li>
<li>从可用的<code>machines</code>开始遍历并执行深度优先遍历，查询与<code>test</code>相应的情况。</li>
<li>一旦遍历到了<code>test</code>，路径会重新走一遍并且所有<code>drivers</code>会被相应分配，最终的<code>interface</code>也会传给<code>test</code>。</li>
<li>执行<code>test</code>。</li>
<li>未被使用的对象会被清理以及路径发现（遍历）也会继续。</li>
</ul>
<p>以下是一个编写新<code>driver</code>以及<code>interface</code>的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"qgraph.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">My_driver</span> &#123;</span></span><br><span class="line">    QOSGraphObject obj;</span><br><span class="line">    Node_produced prod;</span><br><span class="line">    Node_contained cont;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_destructor</span><span class="params">(QOSGraphObject *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   g_free(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_get_driver</span><span class="params">(<span class="keyword">void</span> *object, <span class="keyword">const</span> <span class="keyword">char</span> *interface)</span> </span>&#123;</span><br><span class="line">   My_driver *dev = object;</span><br><span class="line">   <span class="keyword">if</span> (!g_strcmp0(interface, <span class="string">"my_interface"</span>)) &#123;</span><br><span class="line">       <span class="keyword">return</span> &amp;dev-&gt;prod;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_get_device</span><span class="params">(<span class="keyword">void</span> *object, <span class="keyword">const</span> <span class="keyword">char</span> *device)</span> </span>&#123;</span><br><span class="line">   My_driver *dev = object;</span><br><span class="line">   <span class="keyword">if</span> (!g_strcmp0(device, <span class="string">"my_driver_contained"</span>)) &#123;</span><br><span class="line">       <span class="keyword">return</span> &amp;dev-&gt;cont;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">my_driver_constructor</span><span class="params">(<span class="keyword">void</span> *node_consumed,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   QOSGraphObject *alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   My_driver dev = g_new(My_driver, <span class="number">1</span>);</span><br><span class="line">   <span class="comment">// get the node pointed by the produce edge</span></span><br><span class="line">   dev-&gt;obj.get_driver = my_get_driver;</span><br><span class="line">   <span class="comment">// get the node pointed by the contains</span></span><br><span class="line">   dev-&gt;obj.get_device = my_get_device;</span><br><span class="line">   <span class="comment">// free the object</span></span><br><span class="line">   dev-&gt;obj.destructor = my_destructor;</span><br><span class="line">   do_something_with_node_consumed(node_consumed);</span><br><span class="line">   <span class="comment">// set all fields of contained device</span></span><br><span class="line">   init_contained_device(&amp;dev-&gt;cont);</span><br><span class="line">   <span class="keyword">return</span> &amp;dev-&gt;obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register_my_driver</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qos_node_create_driver(<span class="string">"my_driver"</span>, my_driver_constructor);</span><br><span class="line">    <span class="comment">// contained drivers don't need a constructor,</span></span><br><span class="line">    <span class="comment">// they will be init by the parent.</span></span><br><span class="line">    qos_node_create_driver(<span class="string">"my_driver_contained"</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// For the sake of this example, assume machine x86_64/pc contains</span></span><br><span class="line">   <span class="comment">// "other_node".</span></span><br><span class="line">   <span class="comment">// This relation, along with the machine and "other_node" creation,</span></span><br><span class="line">   <span class="comment">// should be defined in the x86_64_pc-machine.c file.</span></span><br><span class="line">   <span class="comment">// "my_driver" will then consume "other_node"</span></span><br><span class="line">   qos_node_contains(<span class="string">"my_driver"</span>, <span class="string">"my_driver_contained"</span>);</span><br><span class="line">   qos_node_produces(<span class="string">"my_driver"</span>, <span class="string">"my_interface"</span>);</span><br><span class="line">   qos_node_consumes(<span class="string">"my_driver"</span>, <span class="string">"other_node"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个例子里，所有可能的关系类型都创建了，具体关系如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x86_64/pc --contains--&gt; other_node --consumed_by--&gt; my_driver</span><br><span class="line">                                                          |</span><br><span class="line">                         my_driver_contained &lt;--contains--+</span><br><span class="line">                                                          |</span><br><span class="line">                                my_interface &lt;--produces--+</span><br></pre></td></tr></table></figure>
<p>以下是编写一个新的<code>test</code>的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"qgraph.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_test_function</span><span class="params">(<span class="keyword">void</span> *obj, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Node_produced *interface_to_test = obj;</span><br><span class="line">   <span class="comment">// test interface_to_test</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register_my_test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   qos_add_test(<span class="string">"my_interface"</span>, <span class="string">"my_test"</span>, my_test_function);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">libqos_init(register_my_test);</span><br></pre></td></tr></table></figure>
<p>新的<code>test</code>创建了，该<code>test</code>是<code>consume</code>了<code>my_interface</code>这个<code>node</code>，并且创建了一个有效的从<code>machine</code>到一个<code>test</code>的<code>path</code>。最终的图表会像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x86_64/pc --&gt;contains--&gt; other_node --consumed_by--&gt; my_driver</span><br><span class="line">                                                          |</span><br><span class="line">                         my_driver_contained &lt;--contains--+</span><br><span class="line">                                                          |</span><br><span class="line">       my_test &lt;--consumed_by-- my_interface &lt;--produces--+</span><br></pre></td></tr></table></figure>
<p>假设有一个二进制文件<code>QTEST_QEMU_BINARY=./qemu-system-x86_64</code>，那么一个有效的<code>test path</code>就会像这样：<code>/x86_64/pc/other_node/my_driver/my_interface/my_test</code>。</p>
<p><strong>Command Line ：</strong></p>
<p><code>QEMU</code>启动需要有一些<code>Option</code>参数，在<code>QTest</code>框架中的体现就是<code>Command Line</code>。<code>Command Line</code>是使用<code>node names</code>以及构建<code>edges</code>时通过用户传递的可选参数构建的。<code>Command Line</code>参数有三种类型：<code>in node</code>、<code>after node</code>、<code>before node</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">in node: 根据node name创建，例如，machines会有“-M &lt;machine&gt;”传给command line，同时devices也会有“-device &lt;device&gt;”，该框架会自动完成创建。</span><br><span class="line"></span><br><span class="line">after node: 以额外参数添加在node name中。当创建edges时该参数的添加是可选的，通过设置#QOSGraphEdgeOptions结构体中的@after_cmd_line和@extra_edge_opts属性即可。框架也会在@extra_edge_opts之前自动添加一个段落，因为这会在edge包含的options所指向的目标node之后添加属性，并且自动在@after_cmd_line之前添加一个空格，因为这是添加一个额外的device，并不是添加一个额外的属性。</span><br><span class="line"></span><br><span class="line">before node: 以额外参数添加在node name中。当创建edges时也是可选的，通过设置#QOSGraphEdgeOptions结构体中的@before_cmd_line即可。这个属性会在edge包含的options所指向的目标node之前添加属性。这对于不是节点可视的命令来说很有用，例如“-fdsev”、“-netdev”。</span><br></pre></td></tr></table></figure>
<p>尽管<code>Command Line</code>在<code>edges</code>中总会被使用，但不是所有的<code>nodes names</code>在没一个路径遍历（<code>path walk</code>）中会被用到。因为<code>contained</code>或者<code>produced</code>关系总会被<code>QEMU</code>添加，因此只有<code>consumes</code>会被用在建立<code>Command Line</code>中。</p>
<p>使用例子如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QOSGraphEdgeOptions opts = &#123;</span><br><span class="line">    .arg = <span class="literal">NULL</span>,</span><br><span class="line">    .size_arg = <span class="number">0</span>,</span><br><span class="line">    .after_cmd_line = <span class="string">"-device other"</span>,</span><br><span class="line">    .before_cmd_line = <span class="string">"-netdev something"</span>,</span><br><span class="line">    .extra_edge_opts = <span class="string">"addr=04.0"</span>,</span><br><span class="line">&#125;;</span><br><span class="line">QOSGraphNode * node = qos_node_create_driver(<span class="string">"my_node"</span>, constructor);</span><br><span class="line">qos_node_consumes_args(<span class="string">"my_node"</span>, <span class="string">"interface"</span>, &amp;opts);</span><br></pre></td></tr></table></figure>
<p>最终构造出来的<code>Command Line</code>如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-netdev something -device my_node,addr=<span class="number">04.0</span> -device other</span><br></pre></td></tr></table></figure>
<p><code>QOSGraphEdgeOptions</code>结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QOSGraphEdgeOptions</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *arg;</span><br><span class="line">    <span class="keyword">uint32_t</span> size_arg;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *extra_device_opts;<span class="comment">//会自动添加“，”</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *before_cmd_line;  <span class="comment">//例如“-fdsev synt”</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *after_cmd_line;   <span class="comment">//用于添加其他设备命令，自动添加“ ”空格</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *edge_name;        <span class="comment">//用于区分多个设备有同样的node name</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来就说几个比较重要的函数：</p>
<ul>
<li><strong>qos_node_contains</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qos_node_contains</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *container, <span class="keyword">const</span> <span class="keyword">char</span> *contained,</span></span></span><br><span class="line"><span class="function"><span class="params">                       QOSGraphEdgeOptions *opts, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>用来创建一个或多个<code>edges</code>，<code>type</code>类型为<code>QEDGE_CONTAINS</code>。如果<code>@opts</code>为空，那么只会创建一个没有<code>options</code>的单条<code>edge</code>，如果不空，每个<code>option</code>都会创建一条<code>edge</code>。这个函数对于在同个<code>machine node</code>下有着相同<code>node names</code>的多个设备来说很有用。例如，<code>arm/raspi2</code>包含了两个<code>generic-sdhci</code>设备，正确的命令会是这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">qos_node_create_machine(<span class="string">"arm/raspi2"</span>);</span><br><span class="line">qos_node_create_driver(<span class="string">"generic-sdhci"</span>, constructor);</span><br><span class="line"><span class="comment">//assume rest of the fields are set NULL</span></span><br><span class="line">QOSGraphEdgeOptions op1 = &#123; .edge_name = <span class="string">"emmc"</span> &#125;;</span><br><span class="line">QOSGraphEdgeOptions op2 = &#123; .edge_name = <span class="string">"sdcard"</span> &#125;;</span><br><span class="line">qos_node_contains(<span class="string">"arm/raspi2"</span>, <span class="string">"generic-sdhci"</span>, &amp;op1, &amp;op2, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>当然这也需要<code>@container</code>（包含者）的<code>get_device</code>函数对<code>emmc</code>和<code>sdcard</code>都有一个实现实例。</p>
<p><code>op1.arg</code>和<code>op1.size_arg</code>代表传递给<code>@contained</code>（被包含者）构造函数的参数用于正确的初始化。</p>
<ul>
<li><strong>qos_add_test</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qos_add_test</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *interface,</span></span></span><br><span class="line"><span class="function"><span class="params">                  QOSTestFunc test_func,</span></span></span><br><span class="line"><span class="function"><span class="params">                  QOSGraphTestOptions *opts)</span></span>;</span><br></pre></td></tr></table></figure>
<p>用于添加<code>test node</code>，该<code>test</code>会<code>consume</code>一个<code>interface node</code>，一旦图表的遍历算法找到了这个测试路径，<code>@test_func</code>就会被执行。对于<code>test node</code>来说，<code>opts-&gt;edge.arg</code>和<code>size_arg</code>代表传递给<code>@test_func</code>的参数。</p>
<p><strong>简单总结 ：</strong></p>
<p><code>QTest</code>框架主要围绕两类<code>node</code>和<code>edge</code>来展开，两类结构体以及两类的<code>type</code>类型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* edge types*/</span></span><br><span class="line"><span class="keyword">enum</span> QOSEdgeType &#123;</span><br><span class="line">    QEDGE_CONTAINS,</span><br><span class="line">    QEDGE_PRODUCES,</span><br><span class="line">    QEDGE_CONSUMED_BY</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* node types*/</span></span><br><span class="line"><span class="keyword">enum</span> QOSNodeType &#123;</span><br><span class="line">    QNODE_MACHINE,</span><br><span class="line">    QNODE_DRIVER,</span><br><span class="line">    QNODE_INTERFACE,</span><br><span class="line">    QNODE_TEST</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Graph Node */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QOSGraphNode</span> &#123;</span></span><br><span class="line">    QOSNodeType type;</span><br><span class="line">    <span class="keyword">bool</span> available;     <span class="comment">/* set by QEMU via QMP, used during graph walk */</span></span><br><span class="line">    <span class="keyword">bool</span> visited;       <span class="comment">/* used during graph walk */</span></span><br><span class="line">    <span class="keyword">char</span> *name;         <span class="comment">/* used to identify the node */</span></span><br><span class="line">    <span class="keyword">char</span> *command_line; <span class="comment">/* used to start QEMU at test execution */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            QOSCreateDriverFunc constructor;</span><br><span class="line">        &#125; driver;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            QOSCreateMachineFunc constructor;</span><br><span class="line">        &#125; machine;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            QOSTestFunc function;</span><br><span class="line">            <span class="keyword">void</span> *arg;</span><br><span class="line">            QOSBeforeTest before;</span><br><span class="line">            <span class="keyword">bool</span> subprocess;</span><br><span class="line">        &#125; test;</span><br><span class="line">    &#125; u;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * only used when traversing the path, never rely on that except in the</span></span><br><span class="line"><span class="comment">     * qos_traverse_graph callback function</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    QOSGraphEdge *path_edge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Graph Edge */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QOSGraphEdge</span> &#123;</span></span><br><span class="line">    QOSEdgeType type;</span><br><span class="line">    <span class="keyword">char</span> *dest;</span><br><span class="line">    <span class="keyword">void</span> *arg;                <span class="comment">/* just for QEDGE_CONTAINS</span></span><br><span class="line"><span class="comment">                               * and QEDGE_CONSUMED_BY */</span></span><br><span class="line">    <span class="keyword">char</span> *extra_device_opts;  <span class="comment">/* added to -device option, "," is</span></span><br><span class="line"><span class="comment">                               * automatically added</span></span><br><span class="line"><span class="comment">                               */</span></span><br><span class="line">    <span class="keyword">char</span> *before_cmd_line;    <span class="comment">/* added before node cmd_line */</span></span><br><span class="line">    <span class="keyword">char</span> *after_cmd_line;     <span class="comment">/* added after -device options */</span></span><br><span class="line">    <span class="keyword">char</span> *edge_name;          <span class="comment">/* used by QEDGE_CONTAINS */</span></span><br><span class="line">    QSLIST_ENTRY(QOSGraphEdge) edge_list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其他的例如<code>QOSGraphEdgeOptions</code>、<code>QOSGraphTestOptions</code>实际上是<code>node</code>和<code>edge</code>的一个拓展延伸（参数选项），最终还是要赋值到<code>node</code>和<code>edge</code>中去的。</p>
<p>值得一提的还有<code>QOSGraphObject</code>，该结构体是用于<code>test</code>、<code>driver</code>、<code>machine</code>的实例化作为他们的第一个字段（域）。定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QOSGraphObject</span> &#123;</span></span><br><span class="line">    <span class="comment">/* for produces edges, returns void * */</span></span><br><span class="line">    QOSGetDriver get_driver;</span><br><span class="line">    <span class="comment">/* for contains edges, returns a QOSGraphObject * */</span></span><br><span class="line">    QOSGetDevice get_device;</span><br><span class="line">    <span class="comment">/* start the hw, get ready for the test */</span></span><br><span class="line">    QOSStartFunct start_hw;</span><br><span class="line">    <span class="comment">/* destroy this QOSGraphObject */</span></span><br><span class="line">    QOSDestructorFunc destructor;</span><br><span class="line">    <span class="comment">/* free the memory associated to the QOSGraphObject and its contained</span></span><br><span class="line"><span class="comment">     * children */</span></span><br><span class="line">    GDestroyNotify <span class="built_in">free</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="0x04-QTest-Code-Analyse"><a href="#0x04-QTest-Code-Analyse" class="headerlink" title="0x04 QTest Code Analyse"></a>0x04 QTest Code Analyse</h3><p>后续部分建议边调试（审计）边食用。先主要分析<code>QTest</code>相关的代码，之后再来看<code>libfuzzer</code>部分，<code>QTest</code>部分主要逻辑在<code>qos-test.c</code>文件中。<code>main</code>函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_test_init(&amp;argc, &amp;argv, <span class="literal">NULL</span>);</span><br><span class="line">    qos_graph_init();                          <span class="comment">//建立graph图标，初始化node和edge的表，并创建一个</span></span><br><span class="line">                                               <span class="comment">//名为ROOT的”根“node节点，类型为driver</span></span><br><span class="line">    module_call_init(MODULE_INIT_QOM);</span><br><span class="line">    module_call_init(MODULE_INIT_LIBQOS);</span><br><span class="line">    qos_set_machines_devices_available();</span><br><span class="line"></span><br><span class="line">    qos_graph_foreach_test_path(walk_path);</span><br><span class="line">    g_test_run();</span><br><span class="line">    qtest_end();</span><br><span class="line">    qos_graph_destroy();</span><br><span class="line">    g_free(old_path);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>module_call_init</code>值得一说，<code>MODULE_INIT_QOM</code>是在<code>type_init(function)</code>中指定的类型，具体为<code>module_init(function, MODULE_INIT_QOM)</code>，看定义可以得知它是一个构造函数，在<code>QEMU</code>运行之前就执行了，具体操作为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void register_module_init(void (*fn)(void), module_init_type type)</span><br><span class="line">&#123;</span><br><span class="line">    ModuleEntry *e;</span><br><span class="line">    ModuleTypeList *l;</span><br><span class="line"></span><br><span class="line">    e = g_malloc0(<span class="keyword">sizeof</span>(*e));</span><br><span class="line">    e-&gt;init = fn;                            <span class="comment">//赋值type_init中的函数给ModuleEntry-&gt;init</span></span><br><span class="line">    e-&gt;type = type;                          <span class="comment">//赋值type</span></span><br><span class="line"></span><br><span class="line">    l = find_type(type);</span><br><span class="line"></span><br><span class="line">    QTAILQ_INSERT_TAIL(l, e, node);          <span class="comment">//插入TypeList链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>moudle_call_init</code>函数为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">module_call_init</span><span class="params">(module_init_type type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    QTAILQ_FOREACH(e, l, node) &#123;</span><br><span class="line">        e-&gt;init();                            <span class="comment">//执行init函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而<code>type_init</code>出现在<code>QEMU</code>设备代码中，用于设备的注册/初始化。所以<code>module_call_init(MODULE_INIT_QOM)</code>就是拿来初始化<code>QEMU</code>中的设备的。同样的，<code>module_call_init(MODULE_INIT_LIBQOS)</code>用于初始化<code>libqos</code>框架，把<code>QTest</code>中的<code>machine</code>、<code>driver</code>、<code>test</code>等都初始化了，具体可以查看调用了<code>libqos_init(function)</code>函数的代码文件。</p>
<p><code>qos_set_machines_devices_available()</code>作用是将<code>machines</code>和<code>devices</code>的<code>node-&gt;availabe</code>设为<code>true</code>，默认创建<code>node</code>的时候是<code>false</code>。相当于启用设备，为后续的<code>path walk</code>做准备。</p>
<p>接下来就是重点要分析的“路径遍历”了。首先看<code>qos_graph_foreach_test_path</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qos_graph_foreach_test_path</span><span class="params">(QOSTestCallback fn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QOSGraphNode *root = qos_graph_get_node(QOS_ROOT);        <span class="comment">//获取“根”ROOT节点</span></span><br><span class="line">    qos_traverse_graph(root, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">qos_traverse_graph</span><span class="params">(QOSGraphNode *root, QOSTestCallback callback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QOSGraphNode *v, *dest_node, *path;</span><br><span class="line">    QOSStackElement *s_el;</span><br><span class="line">    QOSGraphEdge *e, *next;</span><br><span class="line">    QOSGraphEdgeList *<span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">    qos_push(root, <span class="literal">NULL</span>, <span class="literal">NULL</span>);                          <span class="comment">//将“根”node压栈，无父节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (qos_node_tos &gt; <span class="number">0</span>) &#123;                           <span class="comment">//代表栈的深度，指向栈顶+1</span></span><br><span class="line">        s_el = qos_tos();                                <span class="comment">//取出栈顶元素</span></span><br><span class="line">        v = s_el-&gt;node;</span><br><span class="line">        <span class="keyword">if</span> (v-&gt;visited) &#123;                           <span class="comment">//若被遍历访问过了，则出栈并设置unvisited</span></span><br><span class="line">            qos_pop();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v-&gt;visited = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">list</span> = get_edgelist(v-&gt;name);               <span class="comment">//获取node对应的edge链表</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">list</span>) &#123;                                <span class="comment">//若无链表则出栈并设置unvisited</span></span><br><span class="line">            qos_pop();                              </span><br><span class="line">            <span class="keyword">if</span> (v-&gt;type == QNODE_TEST) &#123;            <span class="comment">//若为test节点，则回溯整条路径，并执行回调函数</span></span><br><span class="line">                v-&gt;visited = <span class="literal">false</span>;</span><br><span class="line">                path = qos_reverse_path(s_el);</span><br><span class="line">                callback(path, s_el-&gt;length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            QSLIST_FOREACH_SAFE(e, <span class="built_in">list</span>, edge_list, next) &#123;  <span class="comment">//逐个遍历edge链表</span></span><br><span class="line">                dest_node = search_node(e-&gt;dest);            <span class="comment">//查找目标edge节点</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!dest_node) &#123;</span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"node %s in %s -&gt; %s does not exist\n"</span>,</span><br><span class="line">                            e-&gt;dest, v-&gt;name, e-&gt;dest);</span><br><span class="line">                    <span class="built_in">abort</span>();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!dest_node-&gt;visited &amp;&amp; dest_node-&gt;available) &#123; <span class="comment">//若节点没被访问过，且可用，则</span></span><br><span class="line">                                                                   <span class="comment">//压栈（包括父节点元素、edge</span></span><br><span class="line">                                                                   <span class="comment">//等）</span></span><br><span class="line">                    qos_push(dest_node, s_el, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>qos_traverse_graph</code>是路径遍历的算法函数，采用“栈”的方式来操作。定义了一个名为<code>qos_node_stack</code>的栈元素数组，数组中的每个元素为一个叫<code>QOSStackElement</code>的结构体，包含了<code>node</code>、<code>parent</code>以及两者间的<code>edge</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QOSStackElement</span> &#123;</span></span><br><span class="line">    QOSGraphNode *node;</span><br><span class="line">    QOSStackElement *parent;</span><br><span class="line">    QOSGraphEdge *parent_edge;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> QOSStackElement qos_node_stack[QOS_PATH_MAX_ELEMENT_SIZE]; <span class="comment">//QOS_PATH_MAX_ELEMENT_SIZE = 50</span></span><br></pre></td></tr></table></figure>
<p>深度最长为50。</p>
<p>我作了一个节点树的图，来表明当前<code>QEMU</code>中节点之间的联系：</p>
<p><img src="/QTest源码分析/节点树.png" alt="节点树"></p>
<p>我只列出了部分<code>node</code>，主要做个效果，审计该函数的时候可以对照这个节点树来看，从上图可以找到一条完整的通路：</p>
<blockquote>
<p>ROOT –&gt; i386/pc –&gt; i440FX-pcihost –&gt; pci-bus-pc –&gt; pci-bus –&gt; virtio-scsi-pci –&gt; virtio-scsi –&gt; hotplug</p>
</blockquote>
<p>这就是一条从<code>machine</code>到<code>test</code>的完整通路。当然，这只是其中一条，还有许多条<code>test</code>路径。</p>
<p>同时，我也作了一个该函数利用栈来操作的栈空间示意图，如下：</p>
<p><img src="/QTest源码分析/栈空间示意图.png" alt="栈空间示意图"></p>
<p>一起结合着看，该函数的意图就显而易见了，就是深度优先遍历的算法。</p>
<p>算法看完了，再来看该函数处理路径的部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">list</span>) &#123;                                <span class="comment">//若无链表则出栈并设置unvisited</span></span><br><span class="line">    qos_pop();                              </span><br><span class="line">    <span class="keyword">if</span> (v-&gt;type == QNODE_TEST) &#123;            <span class="comment">//若为test节点，则回溯整条路径，并执行回调函数</span></span><br><span class="line">        v-&gt;visited = <span class="literal">false</span>;</span><br><span class="line">        path = qos_reverse_path(s_el);</span><br><span class="line">        callback(path, s_el-&gt;length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure>
<p>当遍历到一条完整的<code>machine</code>到<code>test</code>路径时，就开始做处理了。<code>qos_reverse_path(s_el)</code>函数简单说一下就是对<code>node</code>结构体的<code>path_edge</code>做操作，链接这条路径的各个父子节点，回溯出这条链路上的所有<code>node</code>和<code>edge</code>关系。<code>callback</code>函数就是传入的<code>walk_path</code>函数，参数为<code>path</code>和<code>s_el-&gt;length</code>，也就是遍历到的路径和路径的深度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">walk_path</span><span class="params">(QOSGraphNode *orig_path, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QOSGraphNode *path;</span><br><span class="line">    QOSGraphEdge *edge;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* etype set to QEDGE_CONSUMED_BY so that machine can add to the command line */</span></span><br><span class="line">    QOSEdgeType etype = QEDGE_CONSUMED_BY; <span class="comment">//默认设consumed_by为了让-M &lt;machine&gt;能添加到cmd上</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* twice QOS_PATH_MAX_ELEMENT_SIZE since each edge can have its arg */</span></span><br><span class="line">    <span class="keyword">char</span> **path_vec = g_new0(<span class="keyword">char</span> *, (QOS_PATH_MAX_ELEMENT_SIZE * <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">int</span> path_vec_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *after_cmd, *before_cmd, *after_device;</span><br><span class="line">    GString *after_device_str = g_string_new(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">char</span> *node_name = orig_path-&gt;name, *path_str;</span><br><span class="line"></span><br><span class="line">    GString *cmd_line = g_string_new(<span class="string">""</span>);</span><br><span class="line">    GString *cmd_line2 = g_string_new(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    path = qos_graph_get_node(node_name); <span class="comment">/* root */</span>         <span class="comment">//获取“ROOT”根节点</span></span><br><span class="line">    node_name = qos_graph_edge_get_dest(path-&gt;path_edge);    <span class="comment">//获取根节点的子节点name（machine节点）</span></span><br><span class="line"></span><br><span class="line">    path_vec[path_vec_size++] = node_name;</span><br><span class="line">    path_vec[path_vec_size++] = qos_get_machine_type(node_name); <span class="comment">//根据name获取machine类型（pc/rasp等）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        path = qos_graph_get_node(node_name); <span class="comment">//根据name获取节点</span></span><br><span class="line">        <span class="keyword">if</span> (!path-&gt;path_edge) &#123;               <span class="comment">//判断该节点是否还存在子节点，不存在则退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node_name = qos_graph_edge_get_dest(path-&gt;path_edge); <span class="comment">//获取该节点的子节点name</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* append node command line + previous edge command line */</span></span><br><span class="line">        <span class="keyword">if</span> (path-&gt;command_line &amp;&amp; etype == QEDGE_CONSUMED_BY) &#123;  <span class="comment">//如果节点有参数且为consumed</span></span><br><span class="line">                                                                 <span class="comment">//by类型则添加cmd命令</span></span><br><span class="line">            g_string_append(cmd_line, path-&gt;command_line);</span><br><span class="line">            g_string_append(cmd_line, after_device_str-&gt;str);</span><br><span class="line">            g_string_truncate(after_device_str, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      	<span class="comment">//赋值子节点的edge_name（基本和dest一样，为了区分同个父节点的两个节点）</span></span><br><span class="line">        path_vec[path_vec_size++] = qos_graph_edge_get_name(path-&gt;path_edge);</span><br><span class="line">        <span class="comment">/* detect if edge has command line args */</span></span><br><span class="line">      	<span class="comment">//获取before、after、after_device的command参数</span></span><br><span class="line">        after_cmd = qos_graph_edge_get_after_cmd_line(path-&gt;path_edge);</span><br><span class="line">        after_device = qos_graph_edge_get_extra_device_opts(path-&gt;path_edge);</span><br><span class="line">        before_cmd = qos_graph_edge_get_before_cmd_line(path-&gt;path_edge);</span><br><span class="line">      	<span class="comment">//获取与子节点间的edge关系</span></span><br><span class="line">        edge = qos_graph_get_edge(path-&gt;name, node_name);</span><br><span class="line">      	<span class="comment">//获取edge关系的type类型</span></span><br><span class="line">        etype = qos_graph_edge_get_type(edge);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (before_cmd) &#123;                           <span class="comment">//将前面取的command参数添加赋值</span></span><br><span class="line">            g_string_append(cmd_line, before_cmd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (after_cmd) &#123;</span><br><span class="line">            g_string_append(cmd_line2, after_cmd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (after_device) &#123;</span><br><span class="line">            g_string_append(after_device_str, after_device);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    path_vec[path_vec_size++] = <span class="literal">NULL</span>;</span><br><span class="line">    g_string_append(cmd_line, after_device_str-&gt;str);</span><br><span class="line">    g_string_free(after_device_str, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    g_string_append(cmd_line, cmd_line2-&gt;str);     <span class="comment">//最终结合完成before、after、after_device的</span></span><br><span class="line">  																								 <span class="comment">//总体command参数</span></span><br><span class="line">    g_string_free(cmd_line2, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* here position 0 has &lt;arch&gt;/&lt;machine&gt;, position 1 has &lt;machine&gt;.</span></span><br><span class="line"><span class="comment">     * The path must not have the &lt;arch&gt;, qtest_add_data_func adds it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    path_str = g_strjoinv(<span class="string">"/"</span>, path_vec + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* put arch/machine in position 1 so run_one_test can do its work</span></span><br><span class="line"><span class="comment">     * and add the command line at position 0.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    path_vec[<span class="number">1</span>] = path_vec[<span class="number">0</span>];</span><br><span class="line">    path_vec[<span class="number">0</span>] = g_string_free(cmd_line, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (path-&gt;u.test.subprocess) &#123;               <span class="comment">//判断test是否有子进程</span></span><br><span class="line">        gchar *subprocess_path = g_strdup_printf(<span class="string">"/%s/%s/subprocess"</span>,</span><br><span class="line">                                                 qtest_get_arch(), path_str);</span><br><span class="line">        qtest_add_data_func(path_str, subprocess_path, subprocess_run_one_test);</span><br><span class="line">        g_test_add_data_func(subprocess_path, path_vec, run_one_test);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        qtest_add_data_func(path_str, path_vec, run_one_test);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g_free(path_str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>path_str</code>指向一连串的字符串（例如”<code>pc/i440FX-pcihost/...</code>“），<code>path_vec</code>指向一个字符串数组（例如<code>[0] = &quot;i386/pc&quot;  [1] = &quot;pc&quot;...</code> ）</p>
<p>后续就开始执行相应的<code>test</code>函数<code>run_one_test</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run_one_test</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QOSGraphNode *test_node;</span><br><span class="line">    QGuestAllocator *alloc = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">void</span> *obj;</span><br><span class="line">    <span class="keyword">char</span> **path = (<span class="keyword">char</span> **) arg;</span><br><span class="line">    GString *cmd_line = g_string_new(path[<span class="number">0</span>]);      <span class="comment">//获取command参数</span></span><br><span class="line">    <span class="keyword">void</span> *test_arg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Before test */</span></span><br><span class="line">    current_path = path;</span><br><span class="line">    test_node = qos_graph_get_node(path[(g_strv_length(path) - <span class="number">1</span>)]);  <span class="comment">//获取test node</span></span><br><span class="line">    test_arg = test_node-&gt;u.test.arg;                                 <span class="comment">//获取test arg</span></span><br><span class="line">    <span class="keyword">if</span> (test_node-&gt;u.test.before) &#123;                <span class="comment">//如果有before函数则执行</span></span><br><span class="line">        test_arg = test_node-&gt;u.test.before(cmd_line, test_arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    restart_qemu_or_continue(cmd_line-&gt;str);   <span class="comment">//比较和前一次启动cmd是否一样，不一样就重启</span></span><br><span class="line">    g_string_free(cmd_line, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    obj = qos_allocate_objects(global_qtest, &amp;alloc);   <span class="comment">// ！！！</span></span><br><span class="line">    test_node-&gt;u.test.function(obj, test_arg, alloc);   <span class="comment">//执行test函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>qos_allocate_objects</code>函数是<strong>颇为重要</strong>的一部分，这部分就是测试函数最关键的一点–“对象”。之前所获取的都是一些<code>node</code>节点和<code>edge</code>关系，这只是一个很抽象代表的东西，并没有实例化，也就是说，没有实际设备上的结构体，例如一个设备所包含的一些功能或者元素属性。因此，我们需要实例化，来为后续测试函数做准备。先看看这个<code>qos_allocate_objects</code>函数具体做了什么：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">qos_allocate_objects</span><span class="params">(QTestState *qts, QGuestAllocator **p_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="comment">//current_path+1为[0]=i386/pc [1]=i440FX-pcihost [..]=test_node，即machine到test的路径数组</span></span><br><span class="line">    <span class="keyword">return</span> allocate_objects(qts, current_path + <span class="number">1</span>, p_alloc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">allocate_objects</span><span class="params">(QTestState *qts, <span class="keyword">char</span> **path, QGuestAllocator **p_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">    QGuestAllocator *alloc;</span><br><span class="line">    QOSGraphObject *parent = <span class="literal">NULL</span>;</span><br><span class="line">    QOSGraphEdge *edge;</span><br><span class="line">    QOSGraphNode *node;</span><br><span class="line">    <span class="keyword">void</span> *edge_arg;</span><br><span class="line">    <span class="keyword">void</span> *obj;</span><br><span class="line"></span><br><span class="line">    node = qos_graph_get_node(path[current]); <span class="comment">//先获取machine node（i386/pc）</span></span><br><span class="line">    g_assert(node-&gt;type == QNODE_MACHINE);</span><br><span class="line"></span><br><span class="line">    obj = qos_machine_new(node, qts);      <span class="comment">//执行machine的constructor函数 （1）</span></span><br><span class="line">    qos_object_queue_destroy(obj);         <span class="comment">//设置销毁函数</span></span><br><span class="line"></span><br><span class="line">    alloc = get_machine_allocator(obj);    <span class="comment">//获取前面所设置的内存空间</span></span><br><span class="line">    <span class="keyword">if</span> (p_alloc) &#123;</span><br><span class="line">        *p_alloc = alloc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;                                <span class="comment">// （2）</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;type != QNODE_INTERFACE) &#123;  <span class="comment">//判断是否为interface node</span></span><br><span class="line">            qos_object_start_hw(obj);         <span class="comment">//执行start_hw函数</span></span><br><span class="line">            parent = obj;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* follow edge and get object for next node constructor */</span></span><br><span class="line">        current++;</span><br><span class="line">        edge = qos_graph_get_edge(path[current - <span class="number">1</span>], path[current]);  <span class="comment">//获取与下一个node的edge</span></span><br><span class="line">        node = qos_graph_get_node(path[current]);          <span class="comment">//获取下一个node</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;type == QNODE_TEST) &#123;  <span class="comment">//判断下个node是否为test，是则退出并返回obj</span></span><br><span class="line">            g_assert(qos_graph_edge_get_type(edge) == QEDGE_CONSUMED_BY);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (qos_graph_edge_get_type(edge)) &#123;     <span class="comment">//判断与下个node的edge</span></span><br><span class="line">        <span class="keyword">case</span> QEDGE_PRODUCES:</span><br><span class="line">            obj = parent-&gt;get_driver(parent, path[current]); <span class="comment">//为produce，则获取实例化的interface node</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> QEDGE_CONSUMED_BY:    <span class="comment">//为consumed_by，则执行driver-&gt;constructor初始化并获取obj</span></span><br><span class="line">            edge_arg = qos_graph_edge_get_arg(edge);</span><br><span class="line">            obj = qos_driver_new(node, obj, alloc, edge_arg);</span><br><span class="line">            qos_object_queue_destroy(obj);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> QEDGE_CONTAINS:      <span class="comment">//为contain，则获取实例化的driver node</span></span><br><span class="line">            obj = parent-&gt;get_device(parent, path[current]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标记<code>1</code>处，拿<code>i386/pc</code>下的架构来说，它的<code>constructor</code>函数是<code>x86_64_pc-machine.c</code>文件中的<code>qos_create_machine_pc()</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">qos_create_machine_pc</span><span class="params">(QTestState *qts)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//申请结构体空间，并设置获取device和interface的函数</span></span><br><span class="line">    QX86PCMachine *machine = g_new0(QX86PCMachine, <span class="number">1</span>);</span><br><span class="line">    machine-&gt;obj.get_device = pc_get_device;</span><br><span class="line">    machine-&gt;obj.get_driver = pc_get_driver;</span><br><span class="line">    machine-&gt;obj.destructor = pc_destructor;</span><br><span class="line">    pc_alloc_init(&amp;machine-&gt;alloc, qts, ALLOC_NO_FLAGS); <span class="comment">// ！！！</span></span><br><span class="line">    qos_create_i440FX_host(&amp;machine-&gt;bridge, qts, &amp;machine-&gt;alloc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;machine-&gt;obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pc_alloc_init</span><span class="params">(QGuestAllocator *s, QTestState *qts, QAllocOpts flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="comment">//....</span></span><br><span class="line">    ram_size = qfw_cfg_get_u64(fw_cfg, FW_CFG_RAM_SIZE);</span><br><span class="line">    alloc_init(s, flags, <span class="number">1</span> &lt;&lt; <span class="number">20</span>, MIN(ram_size, <span class="number">0xE0000000</span>), PAGE_SIZE);</span><br><span class="line">		<span class="comment">//....</span></span><br><span class="line">&#125;<span class="comment">//主要用于获取QEMU的内存空间，取ram_size和0xE0000000的最小值，赋值给QGuestAllocator</span></span><br></pre></td></tr></table></figure>
<p>标记<code>2</code>处往下，就是循环遍历<code>machine node</code>到<code>test node</code>的过程，并在每次遍历的过程当中，都做<code>obj</code>初始化分配的工作以及结构体初始化填充的工作，使得各个<code>node</code>的实例化<code>obj</code>也都能相互链接起来。</p>
<p>结构体上的链接关系如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每个结构体都包含着QOSGraphObject，目的就是能够自顶向下链接起来</span></span><br><span class="line"><span class="comment">//最顶端的machine结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QX86PCMachine</span> &#123;</span><span class="comment">//machine node</span></span><br><span class="line">    QOSGraphObject obj;</span><br><span class="line">    QGuestAllocator alloc;</span><br><span class="line">    i440FX_pcihost bridge;  <span class="comment">//包含了i440FX的结构体</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i440FX_pcihost</span> &#123;</span><span class="comment">//driver node</span></span><br><span class="line">    QOSGraphObject obj;</span><br><span class="line">    QPCIBusPC pci;          <span class="comment">//包含了PCIBusPC结构体</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QPCIBusPC</span> &#123;</span><span class="comment">//driver node</span></span><br><span class="line">    QOSGraphObject obj;</span><br><span class="line">    QPCIBus bus;            <span class="comment">//包含了PCIBus结构体</span></span><br><span class="line">&#125; QPCIBusPC;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是interface node的话（例如pci-bus是pci-bus-pc produce的），则后续就不包含一些结构体，而只提供一</span></span><br><span class="line"><span class="comment">//些接口。其他driver需要使用该接口的话就会相应的调用。以pci-bus为例。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QPCIBus</span> &#123;</span><span class="comment">//interface node</span></span><br><span class="line">    <span class="keyword">uint8_t</span> (*pio_readb)(QPCIBus *bus, <span class="keyword">uint32_t</span> addr);</span><br><span class="line">    <span class="keyword">uint16_t</span> (*pio_readw)(QPCIBus *bus, <span class="keyword">uint32_t</span> addr);</span><br><span class="line">    <span class="keyword">uint32_t</span> (*pio_readl)(QPCIBus *bus, <span class="keyword">uint32_t</span> addr);</span><br><span class="line">    <span class="keyword">uint64_t</span> (*pio_readq)(QPCIBus *bus, <span class="keyword">uint32_t</span> addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*pio_writeb)(QPCIBus *bus, <span class="keyword">uint32_t</span> addr, <span class="keyword">uint8_t</span> value);</span><br><span class="line">    <span class="keyword">void</span> (*pio_writew)(QPCIBus *bus, <span class="keyword">uint32_t</span> addr, <span class="keyword">uint16_t</span> value);</span><br><span class="line">    <span class="keyword">void</span> (*pio_writel)(QPCIBus *bus, <span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value);</span><br><span class="line">    <span class="keyword">void</span> (*pio_writeq)(QPCIBus *bus, <span class="keyword">uint32_t</span> addr, <span class="keyword">uint64_t</span> value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*memread)(QPCIBus *bus, <span class="keyword">uint32_t</span> addr, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len);</span><br><span class="line">    <span class="keyword">void</span> (*memwrite)(QPCIBus *bus, <span class="keyword">uint32_t</span> addr, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> (*config_readb)(QPCIBus *bus, <span class="keyword">int</span> devfn, <span class="keyword">uint8_t</span> offset);</span><br><span class="line">    <span class="keyword">uint16_t</span> (*config_readw)(QPCIBus *bus, <span class="keyword">int</span> devfn, <span class="keyword">uint8_t</span> offset);</span><br><span class="line">    <span class="keyword">uint32_t</span> (*config_readl)(QPCIBus *bus, <span class="keyword">int</span> devfn, <span class="keyword">uint8_t</span> offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*config_writeb)(QPCIBus *bus, <span class="keyword">int</span> devfn,</span><br><span class="line">                          <span class="keyword">uint8_t</span> offset, <span class="keyword">uint8_t</span> value);</span><br><span class="line">    <span class="keyword">void</span> (*config_writew)(QPCIBus *bus, <span class="keyword">int</span> devfn,</span><br><span class="line">                          <span class="keyword">uint8_t</span> offset, <span class="keyword">uint16_t</span> value);</span><br><span class="line">    <span class="keyword">void</span> (*config_writel)(QPCIBus *bus, <span class="keyword">int</span> devfn,</span><br><span class="line">                          <span class="keyword">uint8_t</span> offset, <span class="keyword">uint32_t</span> value);</span><br><span class="line"></span><br><span class="line">    QTestState *qts;</span><br><span class="line">    <span class="keyword">uint16_t</span> pio_alloc_ptr;</span><br><span class="line">    <span class="keyword">uint64_t</span> mmio_alloc_ptr, mmio_limit;</span><br><span class="line">    <span class="keyword">bool</span> has_buggy_msi; <span class="comment">/* TRUE for spapr, FALSE for pci */</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>allocate_objects</code>函数的之后部分，整个循环结束之后，得到的<code>obj</code>就是<code>test node</code>所使用的<code>interface node</code>的<code>obj</code>。</p>
<p>重新回到<code>run_one_test</code>函数中来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run_one_test</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="comment">//......</span></span><br><span class="line">    obj = qos_allocate_objects(global_qtest, &amp;alloc);   <span class="comment">// ！！！</span></span><br><span class="line">    test_node-&gt;u.test.function(obj, test_arg, alloc);   <span class="comment">//执行test函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终就是执行相应的<code>test function</code>就结束了。</p>
<h3 id="0x05-QTest-Summary"><a href="#0x05-QTest-Summary" class="headerlink" title="0x05 QTest Summary"></a>0x05 QTest Summary</h3><p>至此，整个<code>qos-test.c</code>的<code>QTest</code>细节就结束了，后续的话就是一些<code>test</code>测试文件，这些留给读者自行阅读。大致概括一下<code>QTest</code>的整体流程就是每找到<code>machine</code>到<code>test</code>的路径，就执行相应的<code>test function</code>，相当于把所有编写的<code>test</code>测试用例都执行了一遍。他不是一个持续性测试（持续性喂各种不同的数据进行测试）的过程，而是“一次性”的测试，因此局限性显而易见。</p>
<p>同时，编写的<code>test</code>是基于前者<code>interface</code>提供的接口进行的，所以测试情况会受<code>interface</code>的接口限制。如果没有想要测试的设备的接口，那么完全就没有办法编写相应的<code>test</code>。</p>
<h3 id="0x06-Libfuzzer-Test-Code-Analyze"><a href="#0x06-Libfuzzer-Test-Code-Analyze" class="headerlink" title="0x06 Libfuzzer Test Code Analyze"></a>0x06 Libfuzzer Test Code Analyze</h3><p>先了解一下作者对<code>fuzz target</code>所设计的结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FuzzTarget</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;         <span class="comment">//唯一标识符 (用于传参给--fuzz-target=)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *description;  <span class="comment">//描述符，帮助理解</span></span><br><span class="line">  </span><br><span class="line">   	<span class="comment">//返回的参数会用于QEMU初始化工作中</span></span><br><span class="line">    GString *(*get_init_cmdline)(struct FuzzTarget *);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//只执行一次，并且在QEMU初始化之前执行（例如设置共享内存用于和子进程交互），也可以为空</span></span><br><span class="line">    <span class="keyword">void</span>(*pre_vm_init)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//只执行一次，在QEMU已经初始化之后执行，但在fuzz循环开始之前执行（例如检测内存映射情况），可为空</span></span><br><span class="line">    <span class="keyword">void</span>(*pre_fuzz)(QTestState *);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//从libfuzzer中获取输入并执行，为fuzz的主函数，需要处理设置、输入执行以及清理。不能为空</span></span><br><span class="line">    <span class="keyword">void</span>(*fuzz)(QTestState *, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//用于引导fuzz过程中的变异结合情况，提高代码覆盖率。从种子集中取两个输入，分别有第一个输入的data和长度</span></span><br><span class="line">  	<span class="comment">//以及第二个输入的data和长度，out代表存储变异结果的空间，max_out_size代表结果的最大存储长度，seed</span></span><br><span class="line">  	<span class="comment">//必要时用于使得变异更具有确定性。上述具体的内容可以查看官方的LLVMFuzzerCustomCrossOver API文档</span></span><br><span class="line">    <span class="keyword">size_t</span>(*crossover)(<span class="keyword">const</span> <span class="keyword">uint8_t</span> *data1, <span class="keyword">size_t</span> size1,</span><br><span class="line">                       <span class="keyword">const</span> <span class="keyword">uint8_t</span> *data2, <span class="keyword">size_t</span> size2,</span><br><span class="line">                       <span class="keyword">uint8_t</span> *out, <span class="keyword">size_t</span> max_out_size,</span><br><span class="line">                       <span class="keyword">unsigned</span> <span class="keyword">int</span> seed);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *opaque;</span><br><span class="line">&#125; FuzzTarget;</span><br></pre></td></tr></table></figure>
<p>集成<code>libfuzzer</code>这块的代码存在于<code>/tests/qtest/fuzz</code>目录下，主代码文件是<code>fuzz.c</code>，先看前期<code>init</code>的函数<code>LLVMFuzzerInitialize</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LLVMFuzzerInitialize</span><span class="params">(<span class="keyword">int</span> *argc, <span class="keyword">char</span> ***argv, <span class="keyword">char</span> ***envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="comment">//......</span></span><br><span class="line">    module_call_init(MODULE_INIT_FUZZ_TARGET); <span class="comment">//(1) 初始化fuzz target</span></span><br><span class="line">		<span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    qemu_init_exec_dir(**argv);</span><br><span class="line">    target_name = <span class="built_in">strstr</span>(**argv, <span class="string">"-target-"</span>);</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    fuzz_qtest_set_serialize(serialize); <span class="comment">//(2) 设置是否查看qtest command命令模式</span></span><br><span class="line">    <span class="comment">/* Identify the fuzz target */</span></span><br><span class="line">    fuzz_target = fuzz_get_target(target_name); <span class="comment">//(3) 获取某个特定的fuzz target</span></span><br><span class="line">    <span class="keyword">if</span> (!fuzz_target) &#123;</span><br><span class="line">        usage(**argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fuzz_qts = qtest_setup(); <span class="comment">//(4) 初始化qtest中基础QTestState的收发等操作函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fuzz_target-&gt;pre_vm_init) &#123;</span><br><span class="line">        fuzz_target-&gt;pre_vm_init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//后续就是设置QEMU的启动参数，并初始化QEMU启动模块</span></span><br><span class="line">    GString *cmd_line = fuzz_target-&gt;get_init_cmdline(fuzz_target);</span><br><span class="line">    g_string_append_printf(cmd_line, <span class="string">" %s -qtest /dev/null "</span>,</span><br><span class="line">                           getenv(<span class="string">"QTEST_LOG"</span>) ? <span class="string">""</span> : <span class="string">"-qtest-log none"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Split the runcmd into an argv and argc */</span></span><br><span class="line">    <span class="keyword">wordexp_t</span> result;</span><br><span class="line">    wordexp(cmd_line-&gt;str, &amp;result, <span class="number">0</span>);</span><br><span class="line">    g_string_free(cmd_line, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    qemu_init(result.we_wordc, result.we_wordv, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//......</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标记<code>1</code>处和前面分析<code>QTest</code>的时候提到的<code>module_call_init(MODULE_INIT_QOM)</code>类似。实际上就是执行<code>fuzz_target_init();</code>调用的函数，拿<code>i440fx_fuzz.c</code>举例，其中最底部有这么一段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register_pci_fuzz_targets</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="comment">//......</span></span><br><span class="line">    fuzz_add_qos_target(&amp;(FuzzTarget)&#123;</span><br><span class="line">                .name = <span class="string">"i440fx-qos-noreset-fuzz"</span>,</span><br><span class="line">                .description = <span class="string">"Fuzz the i440fx using raw qtest commands and "</span></span><br><span class="line">                               <span class="string">"rebooting after each run"</span>,</span><br><span class="line">                .fuzz = i440fx_fuzz_qos,&#125;,</span><br><span class="line">                <span class="string">"i440FX-pcihost"</span>,</span><br><span class="line">                &amp;(QOSGraphTestOptions)&#123;&#125;</span><br><span class="line">                );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fuzz_target_init(register_pci_fuzz_targets);</span><br></pre></td></tr></table></figure>
<p>调用<code>module_call_init</code>就是执行<code>register_pci_fuzz_targets</code>函数，初始化编写的<code>fuzz target</code>。当然，不止这一个文件调用了<code>fuzz_target_init</code>函数。</p>
<p>标记<code>2</code>处的作用是使得传输的<code>QTest</code>指令显式表示，也就是能够从<code>command</code>上看出传输的地址以及数据，但是这样会消耗部分资源，因此默认是关闭的。</p>
<p>标记<code>3</code>的具体函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> FuzzTarget *<span class="title">fuzz_get_target</span><span class="params">(<span class="keyword">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="comment">//......</span></span><br><span class="line">    QSLIST_FOREACH(tmp, fuzz_target_list, target_list) &#123;    <span class="comment">//循环处理链条上的每个fuzz target</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(tmp-&gt;target-&gt;name, name) == <span class="number">0</span>) &#123;         <span class="comment">//对比输入的name和target name</span></span><br><span class="line">            <span class="keyword">return</span> tmp-&gt;target;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显就是取出对应<code>name</code>的<code>fuzz target</code>。</p>
<p>标记<code>4</code>处具体函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> QTestState *<span class="title">qtest_setup</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qtest_server_set_send_handler(&amp;qtest_client_inproc_recv, &amp;fuzz_qts);</span><br><span class="line">    <span class="keyword">return</span> qtest_inproc_init(&amp;fuzz_qts, <span class="literal">false</span>, fuzz_arch,</span><br><span class="line">            &amp;qtest_server_inproc_recv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void qtest_server_set_send_handler(void (*send)(void*, const char*),</span><br><span class="line">                                   <span class="keyword">void</span> *opaque)</span><br><span class="line">&#123;</span><br><span class="line">    qtest_server_send = send;</span><br><span class="line">    qtest_server_send_opaque = opaque;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">qtest_send</span><span class="params">(CharBackend *chr, <span class="keyword">const</span> <span class="keyword">char</span> *str)</span> <span class="comment">//该函数会调用上面的server_send函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qtest_server_send(qtest_server_send_opaque, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">QTestState *<span class="title">qtest_inproc_init</span><span class="params">(QTestState **s, <span class="keyword">bool</span> <span class="built_in">log</span>, <span class="keyword">const</span> <span class="keyword">char</span>* arch,</span></span></span><br><span class="line">                    void (*send)(void*, const char*))</span><br><span class="line">&#123;</span><br><span class="line">		<span class="comment">//......</span></span><br><span class="line">    qtest_client_set_rx_handler(qts, qtest_client_inproc_recv_line); <span class="comment">//s-&gt;ops.recv_line赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* send() may not have a matching protoype, so use a type-safe wrapper */</span></span><br><span class="line">    qts-&gt;ops.external_send = send;</span><br><span class="line">    qtest_client_set_tx_handler(qts, send_wrapper);  <span class="comment">//  s-&gt;ops.send赋值</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//......</span></span><br><span class="line">    gchar *bin_path = g_strconcat(<span class="string">"/qemu-system-"</span>, arch, <span class="literal">NULL</span>);</span><br><span class="line">    setenv(<span class="string">"QTEST_QEMU_BINARY"</span>, bin_path, <span class="number">0</span>);</span><br><span class="line">    g_free(bin_path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> qts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本就是一些初始化<code>QTestState</code>结构体的工作，包括一些<code>send</code>和<code>recv</code>操作函数的赋值等等。</p>
<p>接下来就是正式开始执行<code>fuzz</code>的流程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LLVMFuzzerTestOneInput</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *Data, <span class="keyword">size_t</span> Size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Do the pre-fuzz-initialization before the first fuzzing iteration,</span></span><br><span class="line"><span class="comment">     * instead of before the actual fuzz loop. This is needed since libfuzzer</span></span><br><span class="line"><span class="comment">     * may fork off additional workers, prior to the fuzzing loop, and if</span></span><br><span class="line"><span class="comment">     * pre_fuzz() sets up e.g. shared memory, this should be done for the</span></span><br><span class="line"><span class="comment">     * individual worker processes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> pre_fuzz_done;</span><br><span class="line">    <span class="keyword">if</span> (!pre_fuzz_done &amp;&amp; fuzz_target-&gt;pre_fuzz) &#123;</span><br><span class="line">        fuzz_target-&gt;pre_fuzz(fuzz_qts);     <span class="comment">//首先执行fuzz之前需要执行的函数</span></span><br><span class="line">        pre_fuzz_done = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fuzz_target-&gt;fuzz(fuzz_qts, Data, Size);  <span class="comment">//正式启动循环fuzz</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其余的一些函数就比较易懂了，留给读者自行分析。接下来所要说的就是我觉得该作者在集成<code>libfuzzer</code>过程中做的最棒的一点–设计了一个<code>generic-fuzzer</code>，也就是一个通用<code>fuzzer</code>，能够<code>fuzz QEMU</code>中的任何设备。后续的分析请看（下）篇。</p>

    
  </div>

  
      <div class="git"></div>
  

</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持v1nke</div>
        <ul>
        
          <li class="item">
            <span>微信扫一扫</span>
            <img src="/images/qr-wechat.jpeg" alt="">
          </li>
        
          <li class="item">
            <span>支付宝扫一扫</span>
            <img src="/images/qr-wechat.jpeg" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2021/01/22/QEMU-USB-CVE-2020-14364漏洞分析/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2021/04/15/QEMU-QTest && Libfuzzer源码分析（下）/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
